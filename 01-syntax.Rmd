# Синтаксис языка {#syntax}

## Операторы {#operators}

### Операторы присваивания (<-, <<-, =)
Основной оператор присваивания в R - это оператор `<-`. Например, `x <- 5`. Если до этого объект не был создан, то таким образом мы создадим объект `x`, в котором содержится значение `5`. Если до этого объект существовал, то ему будет присвоено новое значение (перезаписано).
Оператор `<-` служит, наверное, одним из самых надежных визуальных маркеров, позволяющих отличить код на R от кода на других языках. Такая форма оператора присваивания обусловлена историческим контекстом - в период разработки и использования в Bell Labs языка S (предшественника R), код писали на клавиатурах, на которых была одна клавиша для печати знака `<-`. 

Несмотря на визуальную понятность оператора, он нередко подвергается критике, в частности, за то, что дает возможность ошибиться. Так, неправильно поставленный пробел меняет присвоение на сравнение: выражение `x <- 5` и `x < -5` различаются одним неправильно поставленным пробелом, однако содержательно они совершенно разные. 

Оператор `=` аналогичен оператору `<-` и может быть использован для левостороннего присваивания. Одновременно оператор `=` используется при указании значений аргументов функций. Большинство гайдов по стилю рекомендуют именно такое использование операторов`<-` и `=`:  первый для присваивания, а второй - при использовании функций.

Оператор `<<-` также является оператором левостороннего присваивания, как и `<-`, однако используется редко и, в основном, в функциях. Основное отличие - с помощью оператора `<<-` значения присваиваются в родительском окружении. Это используется, чтобы созданный во время выполнения функции промежуточный объект вывести за пределы области видимости функции и сохранить в родительском окружении. Родительским окружением может быть как глобальное окружение (что чаще), либо какое-либо еще окружение, в котором вызывается функция:

```{r 01-syntax-1 }
f1 <- function(x) {
  tmp1 <<- paste('the result of <<- operator in f1()')
  tmp2 <- x * 2
  return(tmp2)
}

print(f1(2))
print(tmp1)
```

Вместо оператора `<<-` рекомендуется для изменения значений объектов в различных окружениях использовать функцию `assign()`, где с помощью аргумента `envir` можно указать, в каком, в родительском (`parent.env()`) или в глобальном (`.GlobalEnv`), если это не одно и то же, окружении происходит операция:

```{r 01-syntax-2 }
f2 <- function(x) {
  assign(x = 'tmp1', value = paste('the result of assign() in f2()'), envir = .GlobalEnv)
  tmp2 <- x * 2
  return(tmp2)
}

print(f2(2))
print(tmp1)
```

Несмотря на то, что операторы присваивания позволяют множественное присваивание, а операторы `->` и `->>` еще и правостороннее присваивание, использование выражений вида `x = y = z = 5` или `5 -> x -> y` лучше не использовать, так как они уменьшают читабельность и прозрачность кода.

В редких случаях в левой части выражения присвоения при левосторонем присваивании может стоять не имя объекта, а вызов функции. Как правило, это касается функций, несущих определенную информацию об объекте. Наиболее часто встречающийся пример - создание или присвоение названий колонок в таблице:
```{r 01-syntax-3 }
# создаем и выводим на печать таблицу с колонками var1, var2
new_df <- data.frame(var1 = 1:3, var2 = letters[1:3])
print(new_df)

# меняем названия колонок на col1, col2 и выводим таблицу:
names(new_df) <- c('col1', 'col2')
print(new_df)
```

### Операторы арифметических действий {#math-operators}
Арифметические операторы аналогичны подобным в обычной математической записи:

- `+`, `-` - бинарные и унарные сложение и вычитание
- `*`, `/` - умножение и деление
- `^` или `**` - возведение в степень
- `%%` - остаток при делении нацело

### Операторы сравнения и логические операторы
Операторы сравнения или логические операторы обычно используются при необходимости указать какие-то условия для выбора элементов вектора или таблицы, а также в конструкциях `if/else` (см. ветвления).

Операторы сравнения:
- `<`, `<=` - меньше, меньше или равно
- `>`, `>=` - больше, больше или равно
- `==`, `!=` - равно и не равно

Логические операторы:
- `!` - отрицание, например, `!is.na(x)`
- `&`, `&&` - `И`, `бинарное И`. Оператор `&&` проверяет только первые элементы каждого множества. Например: 
```{r 01-syntax-4 }
c(3, 5) < 6 & c(3, 6) < 6
c(3, 5) < 6 && c(3, 6) < 6
```

- `|`, `||` - `ИЛИ`, `бинарное ИЛИ`. Аналогично операторам `&` и `&&`. Обычно бинарные `И`/`ИЛИ` используются разработчиками при написании функций, чтобы исключить возможность неоднозначности операции.

### Операторы доступа к данным 
Как правило, объекты в R - это таблицы, списки или сложнеы объекты с большим количеством вложенных иерархически элементов. Для того, чтобы извлечь какой-то элемент, или переписать его значение, используются операторы доступа. Здесь мы просто перечислим и дадим общее представление об этих операторах, подробнее операторы доступа к данным, особенно операторы `[` и `[[`, будут рассмотрены в разделе манипуляций с данными.

#### Операторы $ и @
Оператор `$` используется для обращения к части объекта - именованному элементу списка, колонке датафрейма и проч. Вызов выглядит следующим образом: `<object_name>$<element_name>`. В выражении можно использователь несколько операторов, особенно часто это необходимо при работе со сложными вложенными списками и объектами S3-класса. Оператор `$` обладает также полезной особенностью - название элемента можно вводить не полностью, но введенная часть должна однозначно определять требуемый элемент. Выведем первые шесть строк (функция `head()`) датафрейма `cars` и отдельно - первые шесть значений колонки `speed`, с полным и частичным указанием названия колонки:
```{r 01-syntax-5 }
head(cars)
head(cars$speed)
head(cars$sp)
```

Оператор `@` используется аналогично оператору `$` при работе с объектами S4-класса, однако требует полного названия требуемого элемента.

#### Операторы [ и [[ {#element-call}
Оператор `[` в определенной мере аналогичен оператору `$`, однако обладает более гибким функционалом. Так, в с помощью оператора можно выделять элементы по их полному названию, по номеру или вектору номеров в списке элементов, по логическому условию:
```{r 01-syntax-6 }
tmp <- c(2, 5, 6, 9)
tmp[c(1, 3)]
```
Для некоторых объектов оператор `[` переопределен, и имеет дополнительные аргументы.

Оператор `[[` похож на операторы `[` и `$`, однако на вход принимать может только одно значение - номер позиции или название элемента (по умолчанию название должно быть полным):
```{r 01-syntax-7 }
tmp <- c(v1 = 'alpha', v2 = 'beta') 
tmp['v1']
tmp[['v1']]
```

### Операторы вызова объекта (::, :::) {#object-call}
Операторы `::` и `:::` используются для доступа к объектам из какого-то определенного пространства имен. Так, `::` используется для вызова функций любого установленного, но не подключенного пакета. Оператор `:::` обеспечивает доступ вообще к любым неэкспортированным объектам пакетов, не только к функциям.

Чаще всего потребность в этих операторах возникает тогда, когда какая-то функция из специального пакета используется однократно, и подключать весь пакет нет необходимости. Например, уcтановка пакета из гитхаб-репозитория с помощью пакета `devtools`: `devtools::install_github("ropensci/plotly")`. Также `::` или `:::` используются в ситуациях, когда в нескольких пакетах встречаются одинаковые названия функций или объектов.  Например, `fromJSON()` встречается одновременно в пакетах `jsonlite`, `RJSONIO` и `rjson`.

В целом, при использовании этих операторов, надо отдавать себе отчет, что они усложняют код для восприятия, при этом одновременно делают его более прозрачным, так как явно указано, какая функция и какого пакета используется.

## Конвейеры {#pipes}
Оператор конвейера `%>%` не входит в базовые библиотеки R и принадлежит пакету `magrittr`, однако весьма распространен, в частности, широко используется в пакетах экосистемы `tidyverse`. Оператор `%>%` используется для того, чтобы связать в последовательность несколько операций, когда в последующее выражение передается результат предыдущего. В результате сокращается количество кода и/или повышается читабельность. Например, три идентичных вычисления, первое использует оператор конвейера, второе - вложенные выражения, а третье просто каждую операцию производит в отдельном выражении:
```{r 01-syntax-8 }
library(magrittr)

x <- 12 ^ 2 %>% sqrt %>% -2

x <- sqrt(12^2) - 2

x <- 12
x <- x ^ 2
x <- sqrt(x)
x <- x - 2
```

Так как все операторы, по сути, являются функциями, то и оператор конвейера - точно также является самостоятельной функцией. Как следствие, использование конвейеров влечет за собой дополнительные расходы ресурсов, что может быть нежелательно при программировании процессов, требующих высокой производительности.

## Вызов функций {#syntax_fun}
Функции составляют основу языка R - практически все операции совершаются с использованием функций, будь то действие с объектом или вывод графика, или печать значения объекта.

Вызов функции выглядит следующим образом: `function_name(arglist)`. Например:
```{r 01-syntax-9 }
mean(x = 1:10)
```

В приведенном примере `mean` - это название функции, а `x` - название аргумента функции. Функция в примере вычисляет среднее значение по вектору значений аргумента `x`. 

Полный список аргументов функции можно посмотреть в справке по функции. Список аргументов функции импорта csv-файлов выглядит следующим образом (можно посмотреть в справке, можно воспользоваться функцией `args()`):
```{r 01-syntax-10 }
args(read.csv)
```

При вызове функции аргументы можно задавать разными способами. Первый способ - по названию, однозначно указывать название аргумента и его значение: `read.csv(file = 'myfile.csv')`. Второй способ - позиционный, согласно сигнатуре, т.е., когда значения аргументов перечислены в функции в том же порядке, как они объявлены в документации: `read.csv( 'myfile.csv', FALSE, ';')`. 

В приведенном примере документации функции `read.csv()` ряду аргументов уже задаются значения, например, `header = TRUE`. Эти значения называются "значения аргументов по умолчанию", и если при вызове функции для этих аргументов не указаны другие значения, то используются именно заданные по умолчанию. Это позволяет корректно выполнять выражение `read.csv(file = 'myfile.csv')` (или `read.csv('myfile.csv')`), несмотря на то, что значение задано только для одного аргумента, `file`.

В самом конце списка аргументов в приведенном примере используется ключевое слово `...` (dot-dot-dot, три точки, эллипсис). Эта конструкция позволяет создавать функции с произвольным количеством аргументов, или же использовать дополнительные аргументы в уже написанной функции. В примере ниже функция возвращает значение первого из указанных дополнительно аргументов:
```{r 01-syntax-11 }
f1 <- function(x, ...) {
  x <- x^2
  return(..1)
}
f1(x = 3, 5, 9)
```
Следует помнить, что если `...` указаны в середине списка аргументов, то для всех последующих аргументов позиционное указание значений становится невозможно, и необходимо явно задавать пару `аргумент = значение`.


## Служебные символы {#service-symbols}

### Фигурные скобки {#curved-bracers}
Фигурные скобки используются в тех ситуациях, когда необходимо несколько выражений объединить в один блок. Чаще всего это необходимо при объявлении функций, в циклах и, в некоторых случаях, при использовании функций ветвления (if ... else/ifelse/switch). Результатом выполнения блока будет результат последнего выражения:
```{r 01-syntax-12 }
result <- {
  y <- 2 * 3
  z <- y ^ 2
  x <- y + z
}
print(result)
```
В том случае, когда тело функции составляет одно выражение, то фигурные скобки можно опустить:
```{r 01-syntax-13 }
# пишем выражение в фигурных скобках
result <- {
  y <- 2 * 3
}
print(result)

# пишем выражение без фигурных скобок
result <- y <- 2 * 3
print(result)

```


### Комментарии
В R для комментированию используется символ `#`. Если в какое-то место на строке поставить знак комментария, то вся оставшаяся часть строки будет считаться закомментированной. Исключение - если знак комментария находится внутри выражения, окруженного кавычками:

```{r 01-syntax-14 }
x <- 5 # это комментарий
x <- "# а вот это уже не комментарий"
```

Обычно строку комментария ставят перед комментируемым выражением. Однако если комментарий короткий, то можно, как и в примере выше, после комментируемого выражения, на той же строке.

На данный момент R не поддерживает комментирование блоками, как это можно делать в других языках с помощью выражения `/* commented lines of code */`, и каждую строчку надо комментировать отдельно.

За пределами базового R знак `#` может иметь иные значения, например, в в rmarkdown он используется для создания заголовков и внутренних ссылок.

### Кавычки
В R используются три вида кавычек - кавычки ("), апостроф (') и обратный апостроф(\`). Простые кавычки и апостроф взаимозаменяемы, в коде можно использовать как и то, и другое, в том числе и комбинированно. Единственное, следует выдерживать стилистическую однородность и использовать какой-нибудь тип как основной, а второй - только в тех ситуациях, когда надо написать сложное выражение. Например, такие ситуации возникают при написании запроса к SQL-базе данных - в SQL, как правило, апострофы используются для текстовых значений и дат, а кавычки для названий таблиц: `dbGetQuery(con, "select * from mytable where dt >= '2018-01-01'")`. 

Обратный апостроф используется при необходимости определенным образом выделить символьную запись. Например, обратные апострофы используются в том случае, когда колонка датафрейма или иной объект имеет пробелы или другие символы в названии, названа с использованием кириллицы или другого, не латинского шрифта и т.д. Например:

```{r 01-syntax-15 }
`это кириллица` <- 'объект с кириллическим названием и пробелом'
print(`это кириллица`)
```

Помимо обращения к объектам с специфичным названием, обратный апостроф может использоваться при создании собственных операторов:
```{r 01-syntax-16 }
`%~%` <- function(x, y) 
  paste("new operator's result:", x,  "^", y, "=", x ^ y)
2 %~% 3
```

Также обратный апостроф используется в markdown-разметке - для выделение фраз или создания коротких исполнямых выражений выражений в самом тексте, а так же для создания отдельных чанков кода. Например:

```{r 01-syntax-17, eval = F, include = T, wrapper = T}
x <- 2 * 9
```

## Зарезервированные слова {#reserved-words}
Как и во многих других языках, в R часть слов является зарезервированными, то есть, за ними закреплено определенное значение (функционал), и пользователь не имеет возможности использовать их в качестве имен объектов. Основные зарезервированные слова (согласно документации R Foundation), при необходимости их можно посмотреть с помощью `?Reserved`:
```{r 01-syntax-18, eval = F}
if else repeat while function for in next break
TRUE FALSE NULL Inf NaN
NA NA_integer_ NA_real_ NA_complex_ NA_character_
... ..1 ..2 etc
```

Слова, которые уже обозначают функции используемых пакетов или глобальных переменных, не рекомендуется использовать в качестве названий объектов.

## Code Style Guide {#stile-guide}
