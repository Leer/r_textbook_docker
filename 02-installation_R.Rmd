# Начало работы в R

R в работе опирается на несколько ключевых компонент - собственно, сам язык, интерпертатор языка, математические библиотеки, компиляторы Fortran/C/C++ и различные пользовательские пакеты.

Соответственно, установка R, так или иначе, включает в себя установку этих компонент. Наиболее часто используемая схема - это установка с сайта проекта языка и, одновременно с этим, базового компилятора (GNU R) и стандартных библиотек для работы с алгоритмами линейной алгебры (BLAS/LAPACK).

В зависимости от операционной системы, компиляторы Fortran/C/C++ уже могут быть установлены (*nix-системы), пользователям Windows рекомендуется скачать и установить `Rtools`. Впрочем, некоторые пакеты при установке по умолчанию также устанавливают Rtools (если речь идет о Windows).

Выполнение этих этапов уже позволит работать в R, однако почти всегда необходимы дополнительные пакеты (наборы специализированных функций). Пакеты ставятся уже из среды R, средствами языка. Некоторые пакеты требуют наличия дополнительных библиотек или других языков (JDK, Node JS и тому подобное), но это уже стоит решать при возникновении таких ситуаций, а не при первой установке R.

Базовый R имеет собственный графический интерфейс, тем не менее, для более комфортной интерактивной работы обычно устанавливают какую-либо самостоятельную IDE (RStudion, JetBrains plug-in, Visual Studio и т.д.). Естественно, если предполагается просто выполнение уже написанных R скриптов на сервере, то в IDE нет необходимости.

Таким образом, подготовка к работе включает в себя следующие этапы:

- установка языка R с сайта (https://www.r-project.org/, для каждой OS есть соответствующие разделы). Опционально - установка альтернативного интерпретатора и/или приложений, в которые он интегрирован.

- (опционально) установка альтернативных математичеcких библиотек

- установка [Rtools](https://cran.r-project.org/bin/windows/Rtools/) (для Windows), пользователb *nix-систем могут, по желанию, поменять базовый для своей системы набор компиляторов (например, `gcc` на `clang`)

- установка IDE (если предполагается интерактивная работа)

- установка необходимых пакетов и их зависимостей


## Интерпретаторы
Существует несколько интерпретаторов языка R, с несколько разной функциональностью и степенью разработанности. Как правило разработка новых интерпретаторов направлена на увеличение производительности, либо же на расширение функционала. 

Некоторые из них перестали разрабатываться давно (`Rho/CXXR`, `Riposte`), некоторые интерпретаторы, которые разрабатываются частными компаниями, обновляются чуть реже (`TERR`, `Renjin`, `pqR`). Некоторые наработки `pqR` в свое время были даже включены в базовый интерпретатор, при этом `pqR` развивается и в настоящее время, хоть и медленными темпами.

<!-- Старые: -->

<!-- - [Rho](https://github.com/rho-devel/rho) -->

<!-- - [Riposte](https://github.com/jtalbot/riposte) -->

<!-- - [pqR](http://www.pqr-project.org/) -->

<!-- - [Renjin](https://github.com/bedatadriven/renjin) -->

Актуальные (на момент написания) интерпретаторы:

- [GNU-R](https://www.r-project.org/) Базовый открытый интерпретатор, написан на смеси R, С и Fortran. Разрабатывается командой R Foundation и, по сути, является интерпретатором по умолчанию.

- [FastR](https://github.com/oracle/fastr): по уверениям разработчиков, быстрый (минимум в три раза быстрее GNU-R) интерпретатор, реализованный в виртуальной машине GraalVM. Направленность GraalVM на скорость и возможность взаимодействия разных языков с одними и теми же объектами позволяет достаточно просто вызывать и применять R-код к объектам в Python (или других языках экосистемы GraalVM), или встраивать R-код в приложения на Java. 

- [TERR](https://docs.tibco.com/products/tibco-enterprise-runtime-for-r): TIBCO Enterprise Runtime for R, основанный на Java интерпретатор от компани TIBCO, разработчика программного обеспечения, в том числе и BI-систем. Так как интерпретатор проприетарный, столкнуться с ним можно только при работе с продуктами TIBCO.

- [Microsoft R Open](https://mran.microsoft.com/open): интерпретатор, ранее известный как Revolution R Open, основной продукт компании Revolution Analytics. Revolution R Open создавался как среда многопоточных вычислений для бизнес-компаний, в частности, фармацевтического и биотехнологического секторов. В 2015 году Microsoft поглотила Revolution Analytics, интерпретатор был переименован в Microsoft R Open, а вокруг него стала выстраиваться целая экосистема - репозиторий MRAN, интеграция с Visual Studio, интеграция с библиотекой MKL и так далее. Возможно, через некоторое время Microsoft R Open будет включен в инфраструктуру платформы Microsoft Azure. 


Несмотря на привлекательность некоторых решений, у многих интерпретаторов есть одна сложноразрешмая проблема - совместимость с пакетами, размещенными в CRAN. Разработчики, конечно же, стараются тестировать и в ручном, и в автоматическом режиме, как работают их интерпретаторы с CRAN-пакетами. Так или иначе, это может быть долгая работа, несмотря на большой, но все же ограниченный круг наиболее используемых пакетов. 

## BLAS / LAPACK
Немалая часть статистических операций основывается на алгоритмах линейной алгебры. R использует в вычислениях стандарт BLAS API (Basic Linear Algebra Subprograms) и основанную на нем библиотеку LAPACK (Linear Algebra PACKage). 

Узнать, какие версии BLAS и LAPACK установлены в системе, можно в `sessionInfo()`:
```{r 16-installation-R-1}
sessionInfo()$BLAS
sessionInfo()$LAPACK
```

Базовые реализации обладают рядом ограничений, в частности, однопоточностью и фиксированностью некоторых параметров (например, размером блоков). Поэтому, для низкоуровневой оптимизации вычислений, можно воспользоваться альтернативами:

 - ATLAS - Automatically Tuned Linear Algebra Software, высокопроизводительная реализация BLAS с некоторыми функциями из LAPACK, которая может быть использована на разных платформах

 - OpenBLAS - open-source реализация BLAS, форк GotoBLAS, может использоваться с Intel MKL. По некоторым бенчмаркам может быть на порядок быстрее BLAS

 - cuBLAS - созданная NVIDIA библиотека для выполнения процедур линейной алгебры на GPU, по некоторым бенчмаркам может быть в 35+ раз быстрее, чем Intel MKL BLAS

 - Intel MKL - Math Kernel Library, созданная Intel математическая библиотека, ориентированная на использование в вычислениях процессоров Intel и под разными операционными системами. Включает в себя BLAS, LAPACK, ScaLAPACK и ряд других процедур. Intel MKL используется в Microsoft R Open.
 
 - AMD ACML - оптимизированная под AMD-процессоры математическая библиотека (как Intel MKL для Intel-процессоров)


<!-- ## Rtools / gcc+ / clang -->

## Пакеты

Пакеты - наборы специализованных функций, предназначенных для решения определенной группы задач. Например, пакет `ggplot2` предназначен для создания разнообразных графиков, а пакет `RPostgreSQL` содержит функции создания подключения и работы с PostgreSQL-базой данных.

При установке R устанаваливается несколько базовых пакетов, в частности `stats`, `graphics`, `grDevices`, `utils`, `datasets`, `methods`, `base`. Этого вполне достаточно для многих операций - пакет `stats` содержит базовые статистические тесты, пакеты `graphics` и `grDevices` помогают создать и отрисовать/сохранить основные типы графиков, пакеты `utils`, `methods` и `base` в целом обеспечиват функционирование языка.

Тем не менее, создаются отдельные пакеты - для каких-то узких групп статистических методов, или, в общем виде, задач, а также для улучшения уже существующих решений. Например, базовый класс таблиц `data.frame` сейчас в чистом виде практически не используется, так как есть более эффективные и удобные альтернативы-надстроки, такие как `data.table`. Также считается хорошей практикой превращать набор рабочих функций в пакеты - как минимум, это обеспечивает простоту их совместного использования с коллегами.

Все пакеты, которые хранятся в официальном репозитории (CRAN) имеют файлы описаний (DESCRIPTION) и  документацию в стандартном формате. Многие старые и хорошо проработанные пакеты имеют еще и пользовательские гайды и виньетки (vignettes, документы с примерами и описаниями основных функций пакета), демо-примеры, в некоторых случаях подробные онлайн-материалы (это особенно характерно для tidyverse-пакетов и Shiny).


### Установка пакетов
Для установки пакетов используется функция `install.packages()`, где в аргументах указывается название пакета или вектор названий. В Windows пакеты, как правило, уже представлены в бинарном виде, для *nix-систем установка пакетов происходит путем сборки из исходников.

```{r 16-installation-R-2, eval=FALSE}
# примеры команд установки одного пакета и двух пакетов
install.packages('glue')
install.packages(c('glue', 'httr'))
```

У функции достаточно много других аргументов, наиболее часто используемые - `repos`, для указания репозитория и `dependencies`, для указания, надо ли устанавливать все пакеты-зависимости или нет. В некоторых случаях `dependencies = TRUE` может очень замедлить установку, если у пакета достаточно много зависимостей - так, пакет `caret` является своебразным мета-пакетом для машинного обучения, и полный список используемых им пакетов достигает нескольких десятков. Еще один аргумент, `lib`, задает, в какую папку необходимо устанавливать пакеты. Обычно это либо системная папка (Windows), либо пользовательские папки (Windows, *nix)

При установке пакетов на Windows надо позаботиться, чтобы либо у процесса были права на запись в системную папку (запускать IDE от имени администратора, например), либо чтобы имя пользователя было латиницей - так как если у процесса не будет прав записи в сиcтемную папку, то пользователю будет предложено установить пакет в личную папку пользователя. Если в пути будет кириллица, то высока вероятность, что путь будет не найден и установить пакет не получится. Также можно просто указать прямо, в какую папку следует установить пакет, путь также не должен содержать кириллицу.

Список установленных пакетов можно получить с помощью функции `installed.packages()`, которая возвращает таблицу пакетов и их парамеры (версия, требуемая версия R, какие пакеты импорирует при запуске, тип лицензии и т.д.):
```{r 16-installation-R-3}
installed.packages()[1:5,]
```

Для обновления пакетов есть функция `update.packages()` - анализирует, у каких пакетов есть более новые версии, и предлагает пользователю обновить их. Если коллекция пакетов давно не обновлялась, есть смысл выставить аргумент `ask = FALSE`, так как в противном случае будет требоваться подтверждение обновления каждого пакета.

Удалить пакеты можно с помощью функции `remove.packages()`:
```{r 16-installation-R-4, error=TRUE, eval=FALSE}
remove.packages('glue')
```

<!-- ```{r, include=FALSE} -->
<!-- install.packages('glue') -->
<!-- ``` -->

### Репозитории
В настоящее время есть четыре крупных репозитория, из которых можно скачать и установить пакеты. Выбор репозитория зависит, в основном, от задач и от рабочего окружения. Чаще всего используются пакеты, размещенные в CRAN и на github.

 - [CRAN](https://cran.r-project.org): The Comprehensive R Archive Network. Основной и единственный официальный репозиторий R-пакетов. В CRAN нельзя просто так отправить пакет, все новые пакеты (как и новые версии пакетов) проходят автоматические тесты и просматриваются командой R Foundation. Репозиторий имеет несколько десятков зеркал по всему миру, поэтому можно выбрать ближайшее. Также на сайте репозитория есть списки пакетов (CRAN Task Views), где доступные пакеты сгруппированы по темам (Bayesian, Databases, Graphics, Web и т.д.) и коротко аннотированы.
 
 - github: Авторы многих пакетов предоставляют доступ к dev-версиям своих пакетов в github-репозитории. Нередко бывает так, что в CRAN лежит одна версия, а в githib-репозитории - другая, более новая или еще не до конца оттестированная. Впрочем, нередки ситуации, когда пакет доступен только на github. Помимо github, пакеты также могут лежать и в других гит-системах - gitlab, bitbucket. Для установки пакетов с github обычно используют функцию `install_github()` пакета `devtools`. Аналогично, `install_gitlab()` и `install_bitbucket()` для gitlab и bitbucket
 
 - [Bioconductor](https://www.bioconductor.org/): репозиторий сообщества проекта Bioconductor. Также, как и в CRAN, пакеты тестируются и просматриваются. В основном содержит пакеты, предназначенные для решения задач в области биоинформатики. Для установки пакетов из репозитория Bioconductor, можно воспользоваться как функцией `devtools::install_bioc()`, так и функцией `install()` пакета `BiocManager` (с помощью этого пакета устанавливаются и базовые пакеты проекта Bioconductor).
 
 - [MRAN](https://cran.microsoft.com/): Microsoft R Application Network, репозиторий Microsoft R Open. По сути является копией CRAN, с одной очень важной особенностью - это не синхронная копия, а ежедневные снапшоты базы CRAN, как еще называют, 'time machine'. Соответственно, при желании можно установить пакеты тех версий, которые были доступны в CRAN на определенную дату. В определенной мере это полезно, если есть желание восстановить или поддерживать в изолированном виде систему пакетов для выполнения каких-то скриптов, обновление и поддержка которых не планируется. Пакеты устанавливаются также, как и с CRAN, но необходимо указать явно репозиторий, особенно если планируется использовать снапшот базы. Например, `install.packages('glue', repos = 'https://cran.microsoft.com/snapshot/2020-03-14/')`. Тем не менее, кажется, в последнее время репозиторий не обновляется.


### Подключение пакетов
Для подключения пакетов используется функция `library()`, в которую передается название пакета. Название функции, как и в целом названия `library` и `package` может несколько сбивать с толку - во многих языках программирования внешние коллекции функций как раз и называются библиотеками. Тем не менее, для простоты можно воспользоваться метафорой, что множество установленных в системе пакетов -  это библиотека пакетов (метафорических "книг") и выражение `library(pkgname)` является выбором определенного пакета ("книги") из этой библиотеки.

```{r 16-installation-R-5, eval=FALSE}
detach('package:data.table')
```


```{r 16-installation-R-6}
# подлючаем lubridate
library(lubridate)

# проверяем, что пакет подключен
grep('lubridate', search(), value = TRUE)
```

При подключении пакета происходит анализ пространства имен функций пакета, и если в подключаемом пакете есть функции, идентичные названиям функций из ранее подключенных пакетов, то эти ранее подключенные функции скрываются и могут быть вызваны при явном указании пакета. Это поведение по умолчанию и его можно отключить аргументом `warn.conflicts = FALSE`, но тогда придется самостоятельно проверять наличие возможных конфликтов с помощью `conflicts()`. 

Например, из сообщения при подключении пакета `lubridate` видно, что функция `date()` базового пакета скрывается и при вызове `date()` будет вызываться функция пакета `lubridate`:
```{r 16-installation-R-7}
# смотрим, в каких пакетах есть функция date
findFunction('date')

# вызываем скрытую функцию date()
base::date()
```

В некоторых скриптах, особенно в написанных давно или за авторством не очень опытных пользователей, можно встретить подключение пакетов с помощью `require()`. В настоящее время настоятельно не рекомендуется пользоваться этой функцией, либо пользоваться только при подлючении дополнительных проверок. Основная причина в том, что при отсутствии пакета `require()` выдаст пользователю  предупрежедение / warning, что такого пакета нет, `library()` же явно остановит выполнение скрипта с ошибкой. Особенно важно это может быть при отключенных предупреждениях или когда скрипт передается другому пользователю или вообще выполняется неинтерактивно.
```{r 16-installation-R-8, error=TRUE}
require(noname)
library(noname)
```

По умолчанию функция `library()` принимает только одно название пакета, в него нельзя передать вектор из названий подключаемых пакетов. В качестве альтернатив, можно воспользоваться дополнительными пакетами с таким функционалом, либо же подключить список пакетов в цикле, с проверкой на то, установлен пакет или нет и прочими информационными сообщениями. Пример такого цикла:
```{r 16-installation-R-9, error=TRUE}
packages_list <- c('data.table', 'ggplot2', 'noname')
for (i in packages_list) {
  if (!nzchar(system.file(package = i))) {
    msg <- paste('Пакет ', i, 'не установлен!')
    stop(msg, call. = FALSE)
  }
  library(i, character.only = TRUE, verbose = FALSE)
  message(paste('Пакет ', i, 'подключен'))
}
```


Отключить ранее подлюченный пакет можно с помощью функции `detach()`, в которой в формате `package:pkgname` надо указать отключаемый пакет:
```{r 16-installation-R-10}
# отключаем пакет
detach('package:lubridate')

# проверяем
grep('lubridate', search(), value = TRUE)
```


## Среды разработки и запуск R скриптов

### Работа с R в командной строке

В командной строке можно запустить R без подгрузки оконного менеджера. Иногда это полезно для короткого тестирования, особенно когда предполагается выполнение скриптов на удаленном сервере и запустить графический интерфейс не никакой возможности. В целом такой запуск схож с работой в консоли любой IDE, но без сопутствующих приятных и комфортных инструментов типа автодополнения.
```{bash 16-installation-R-11, eval=FALSE}
konhis@kergma:~$ R

R version 3.6.3 (2020-02-29) -- "Holding the Windsock"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> print("hello")
[1] "hello"
> q()
Save workspace image? [y/n/c]: n
```

Чаще, конечно, командная строка используется для запуска скриптов по расписанию. Для этого есть интерфейс `Rscript`, со своим набором аргументов и опций. В общем виде команда в командной строке с использованием `Rscript` имеет такой вид:
```{r 16-installation-R-12, eval=FALSE}
Rscript [options] [-e expr [-e expr2 ...] | file] [args]
```

В опциях может быть указано `--verbose` - деталицация всех процессов, а также `--default-packages=list`, где `list` - список пакетов через запятую, которые будут загружены перед выполнением скрипта. 

Таким образом с помощью `Rscript` можно и просто выполнять выражения на R (удобно при написании файлов конфигураций для докер-контейнеров например), можно также и выполнять R-скрипты.

```{r 16-installation-R-13, echo=FALSE}
scr <- "write.csv(head(mtcars), 'mtcars.R', row.names = FALSE)
print('hello!')
"
write(scr, file = 'cli_test.R')
```

Допустим, у нас есть вот такой скрипт - в нем есть сохранение в файл первых шести строк датасета `mtcars` и вывод на печать сообщения `hello`.
```{bash 16-installation-R-14}
cat cli_test.R
```

Запустим выполнение скрипта в командной строке с помощью `Rscript`, и посмотрим содержание созданного `mtcars.R`:
```{bash 16-installation-R-15}
Rscript --verbose cli_test.R
cat mtcars.R
```

Удаляем созданный файл:
```{bash 16-installation-R-16}
rm mtcars.R
```

У Rscript есть альтренатива, которая активно использовалась ранее - `R CMD BATCH`. Выполнение скриптов с помощью этого интерфейса выглядит следующим образом:

```{bash 16-installation-R-17}
R CMD BATCH cli_test.R
cat mtcars.R
```

При этом в консоли нет вывода, который был при выполнении скрипта через `Rscript`, строчки `hello`, которую мы в скрипте печатаем с помощью `print()`ю Весь вывод, который получается с помощью `R CMD BATCH` записывается в отдельный файл `*.Rout`

```{bash 16-installation-R-18}
cat cli_test.Rout
```

`R CMD BATCH` устаревший вариант, который в настоящее время можно не использовать для вызова скриптов в консоли. При этом надо иметь ввиду, что `BATCH` - лишь одна из команд интерфейса `R CMD` (вызова R с определенными командами). В целом интерфейс `R CMD` в настоящее время используется для настройки и администрирования - в частности, для установки, сборки и тестирования пакетов. А для выполнения скриптов и команд достаточно будет и `Rscript`.



```{bash 16-installation-R-19, echo=FALSE}
rm mtcars.R cli_test.Rout
```

```{r 16-installation-R-20, echo=FALSE}
unlink('cli_test.R')
```


### Работа с R в IDE
Несмотря на некоторое изящество дизайна окна терминала, вести олноценную разработку на R в командной строке может быть неудобно. Большинство практиков, так или иначе, используют какие-нибудь IDE -  Integrated development environment, интегрированная среда разработки. Практически все популярные IDE для работы с R включают в себя текстовый редактор, хоткеи и автодополнение кода, средства отладки, инспектор объектов, поддержку визуализаций и так далее. При установки языка также устанавливается и нативный оконный интерфейс - по сути, текстовый редактор, консоль и возможность отрисовывать графики.

Самая популярная  внастоящий момент IDE для R - RStudio. Помимо разработки IDE, компания поддерживает большое число R-разрабочиков. В частности, доминирующее количество пакетов `tidyverse` написано командой Хэдли Викхема, а сам Викхэм немало занимается стратегическим развитием языка.

 - Rstudio desktop: в базовой версии бесплатна, платная дает возможность обратиться в техподдержку. Основные функции IDE - текстовый процессор, консоль, возможность работать в проектах, интеграция с Git и командной строкой, широкая поддержка rmarkdown (в том числе шаблонов и чанков на других языках), подключение и просмотр баз данных, инспектор объектов и поддержка визуализаций, инструменты для рефакторинга и отладки.
  
 - RStudio Server: в базовой версии бесплатна, платная версия позволяет увеличить количество пользователей, предоставляет тех поддержку, гибкие возможности администрирования, дополнительные средства безопасности, инструменты совместной работы. Фунционал как IDE идентичен функционалу десктопной версиию.
 
 - RStudio Cloud: фактически, облачный аналог Rstudio Server, позволяет работать в командах и держать проекты онлайн. Есть шпаргалки по пакетам и туториалы. В целом, хорошо подходит для образовательных целей (учебные проекты студентов, напимер), но для полноценной работы может быть недостаточно (достаточно жесткие лимиты по памяти), также есть ограничения на количество участников проекта.

Прочие IDE менее полпулярны, но также используются. Наиболее часто упоминаемые альтернативы RStudio:

- JetBrains plugin. Доступен в любом или почти в любом продукте JetBrains. От продуктов JetBrains унаследованы хорошие инструменты и, в целом подход к рефакторингу кода.

- R Tools for Visual Studio (RTVS): расширение для Visual Studio, позволяет устанавливать интерпретатор Microsoft R Open. В VS 2019 не используется. 

- RKward: достаточно старая, но еще живая и разивающаяся IDE. Представляет собой нечто среднее между RStudio (но без rmarkdown и некоторых других инструментов) и JASP (оконный интерфейс к стат.тестам). 

- jupyter notebook: в jupyter можно установить ядро R (r в jupyte**r** намекает) и работать также, как с кодом на python - исполняемые ячейки, автодополнение, поддержка markdown, поддержка визуализаций.

- Google Colab: аналог jupyter notebook, только онлайн - им можно делиться с коллегами, например, как Google-документами или таблицами.

- плагины для Emacs, Vim, Atom, Sublime: что-то среднее межу IDE и командной строкой.
