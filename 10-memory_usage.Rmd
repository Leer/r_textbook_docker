# Работа с памятью в R
## Хранение объектов
Для мониторинга используемой памяти можно обращаться к выводу функции `gc()` (основной ее функционал - сборка мусора, garbage collection). 

```{r 10-memory-usage-1 }
gc(full = TRUE)
```

В R есть некоторое различие в том, как хранятся и мониторятся разные объекты, поэтому в выводе `gc()` мы и видим две строки. Первая, `Ncells` - это так называемые cons cells (пришедшие в R из Lisp и его особенностей хранения объектов в памяти). В R cons cells используются для хранения объектов, относящихся к самому языку - окружения, замыкания, парные списки, названия объектов и так далее. Полную статистику по этим объектам можно посмотреть с помощью функции `memory.profile()`. 

Вторая строчка вывода `gc()`, `Vcells`- это, собственно, статистика используемых пользователем объектов. Правда, на данный момент это не выделяемая память (`heaps`, как в старой версии), а блоки по 8 байт.

Группа `used (Mb)`  отображает, сколько ячеек было использовано для хранения всех текущих объектов, а так же объем задействованной памяти в мегабайтах. Группа колонок `gc trigger (Mb)` отражают, прикаком количестве ячеек и памяти будет запущен сборщик мусора, группа `max used  (Mb)` - статистики на момент предыдущего запуска сборщика.

При интерпретации вывода `gc()` в первую очередь надо смотреть на первую колонку `(Mb)`, так как именно сумма значений обеих строк по этой колонке отражает состояние на текущий момент. Притом, наибольший фокус должен быть, конечно, на строку `Vcells` - по сравнению с пользовательскими объектами объекты `Ncells` намного меньше и их сложно раздуть.

Использовать функцию `gc()` только для мониторинга памяти может быть несколько неудобно, по ряду причин. В первую очередь, это все же функция для вызова сборщика мусора, поэтому ее выполнение может быть медленным в некоторых процедурах (то есть, не надо ее использовать в цикле). Во-вторых, ее данные могут быть несколько неточны, поэтому оценивать загруженность оперативной памяти лучше средствами операционной системы.


## Размер объекта
При работе с большими большими объектами нередко возникает необходимость контролировать, какой объем оперативной памяти занимает объект. Наиболее полезные инструменты здесь - функция `object.size()` базового пакета `utils` и функция `obj_size()` пакета `lobstr`. Обе функции отдают размер в байтах:
```{r 10-memory-usage-2 }
x <- rnorm(10e5)
object.size(x)
lobstr::obj_size(x)
```

Результат функции `object.size()` можно представить в нужном формате с помощью `format()` и аргумента `units`, который позволяет задать единицу измерения ("b", "Kb", "Mb", "Gb" и проч.) и стандарт представления единицы измерения (`standard`, со допустимыми значениями "legacy", "IEC", "SI" и "auto"). Стандарты `legacy` и `IEC` считают байты по степеням двойки, то есть, 1024 байта равны 1 килобайту. Стандарт `SI` опирается на десятичную шкалу, то есть, считает, что 1 килобайт равен 1000 байтам.
```{r 10-memory-usage-3 }
format(object.size(x), units = 'Mb', standard = 'legacy')
format(object.size(x), units = 'MiB', standard = 'IEC')
format(object.size(x), units = 'Mb', standard = 'SI')
```

Оценки размеров объектов в памяти с помощью функции `object.size()` достаточно грубые, так как не учитывают ни окружения, которому принадлежит объект, ни название объекта, ни ситуаций, когда части сложного объекта делятся с другими объектами (характерно для списков и таблиц, подробнее в параграфе shallow copy). Во-вторых, размеры объектов могут несколько различаться на 64- и 32-битных системах.

## Лимиты памяти
R хранит объекты в оперативной памяти. Как следствие, это накладывает некоторые ограничения на размер объектов, в зависимости от операционной системы и ее архитектуры, а так же архитектуры приложения. Стоит отметить, что использование 32-битных версий R на 64-битных ОС так же имеет свои особенности (в частности, на Windows), однако это достаточно редкое сочетание, и мы его не будем рассматривать.

Пользователи чаще всего сталкиваются с таким сообщением об ошибке: `cannot allocate vector of size` (`не могу разместить вектор размером`). Размер, который упоминается в этой ошибке - это необходимое количество памяти сверх уже выделенного (а не сколько всего требуется памяти). В некоторых случаях это ошибка возникает из-за того, что операционная система не может выделить столько памяти под процесс (в некоторых случаях из-за высокой фрагментированности свободной памяти). В основном же эта ошибка возникает, когда размер объекта превышает $2^{31} - 1$ байтов по какому-либо измерению (длина вектора, количество элементов в матрице, длина колонки и проч).

Для *nix-систем количество памяти, выделяемое под процесс, зависит от разрядности системы - для 32-битных систем под процесс выделяется 3Gb (если не считать учитывать резервируемое под ядро), а в 64-битной системе уже намного больше, 128Tb. 

В Windows ситуация несколько сложнее. Во-первых, в 32-х битных системах под процесс выделяется 2Gb (при определенных настройках - 3Gb). В 64-х битных системах больше, но с ограничением в 8Tb. Ввиду того, что Windows ограничивает размер выделяемой памяти под процесс, в Rесь инструменты управлениями этими лимитами - функции `memory.size()` и `memory.limit()`. Первая возвращает текущий или максимальный лимит памяти. Вторая возвращает текущий лимит или же увеличивает лимит памяти. Обе функции могут быть использованы только в Windows, в *nix-системах они будут отдавать `Inf`.

Стоит отметить, что понимать, какие есть лимиты памяти в операционной системе и в приложении полезно, но рядовой пользователь с ними редко сталкивается. Скорее, возникновение ошибки `cannot allocate vector of size` свидетельствует либо о плохо или с ошибкой написанном коде (что чаще), либо же о плохо построенном процессе работы с данными.


## Трассировка объектов
Для отслеживания адреса объекта в памяти и его изменения при различных операциях используется функция `tracemem()`:
```{r 10-memory-usage-4 }
x <- 1:5
tracemem(x)
```

При изменении элемента объекта адрес меняется и изменение адресов отображается сразу, без повторного вызова `tracemem()`:
```{r 10-memory-usage-5 }
x[5] <- 6L
```

Для отключения трассировки можно воспользоваться функцией `untracemem()`, только для начала сохраним актуальный адрес объекта:
```{r 10-memory-usage-6 }
# сохраняем 
prev_address <- tracemem(x)

# отключаем трассировку и изменяем
untracemem(x)
x[3] <- 99
```

При желании, после отключения трассировки, можно сделать какую-нибудь новую операцию (или несколько) и c помощью `retracemem()` отследить изменение адреса с последнего известного до текущего: 
```{r 10-memory-usage-7 }
# добавляем еще одно изменение
x <- 9

# смотрим изменение адреса с предыдущего известного
retracemem(x, previous = prev_address)
untracemem(x)
```

Функция `tracemem()` использует вывод C-функции `duplicate()`, которая вызывается при копировании объектов, как следствие, `tracemem()` бессмысленна или неприменима к функциям, окружениям и прочим объектам, которые нельзя дуплицировать.

Помимо `tracemem()` для получения адреса объекта можно использовать более вызов внутренней функции `inspect()`, которая также возвращает адрес в памяти и C-тип данных, а так же функцию `lobstr::obj_addr()`, которая является оболочкой над `inspect()`:
```{r 10-memory-usage-8 }
tracemem(x)
.Internal(inspect(x))
lobstr::obj_addr(x)
```


## Хранение разных типов данных
Для лучшего понимания основных типов данных в R рассмотрим их с точки зрения хранения в памяти. Это можно сделать как с помощью `tracemem()`, так и с помощью функций `ref()`, `obj_addr()` и `obj_addrs()` пакета `lobstr`, которая возвращает более детальную информацию об объекте и его элементах.

### Векторы
Векторы значений атомарных типов, за исключением строкового, имеют только адрес начала вектора. Со строковыми значениями ситуация несколько иная - в R используется так называемый глобальный кэш строковых значений (global string pooling). Это значит, что каждое новое строковое значение получает свой адрес и попадает в кэш, все же дальнейшие обращения к этой строке используют закэшированное значение (то есть, обращаются по тому же адресу). Таким образом вектор строковых значений будет содержать значения из кэша и какое-то количество ссылок на эти значения, которых может быть больше, чем уникальных строковых значений:

```{r 10-memory-usage-9 }
x_char <- sample(c('ab', 'ac', 'cb'), 7, replace = TRUE)
x_char <- sort(x_char)
print(x_char)

lobstr::ref(x_char, character = TRUE)

lobstr::obj_addrs(x_char)
```

Такая особенность хранения строк может давать ощутимый прирост в оптимизации хранения и использования данных. Помимо очевидного хранения только уникальных строковых значений, вместо каждого вхождения, строки можно использовать как альтернативы численным значениям. В частности, когда в качестве идентификатора наблюдения или еще какого-либо объекта (тех же штрих-кодов) используется большое число, можно хранить эти идентификаторы как строковые. За счет глобального кэша это будет почти также эффективно, как и с численными идентификаторам, так как указатели на адрес в кэше в любом случае численные. При этом, по опыту, строковое хранение идентификаторов безопаснее для использования (как минимум, нет опасности бесконтрольного перехода в академическую нотацию и использование плавающей точки или же переполнения типа).

### Списки и таблицы
Списки и таблицы являются коллекциями ссылок на векторы, каждый из которых имеет собственный адрес. Соответственно, можно отдельно отслеживать изменения подсписков или колонок в таблице. Например, когда мы добавляем новый элемент в список, видно, что меняется адрес всего списка, но адреса уже существующих подсписков остаются такими же:
```{r 10-memory-usage-10 }
# создадим список и посмотрим его адрес и адреса его подсписков
my_list <- list(e1 = 1:3, e2 = letters[1:5], e3 = month.abb[1])
lobstr::ref(my_list)

# создаем новый подсписок
my_list$e4 <- sample(5)
lobstr::ref(my_list)
```

Аналогично с таблицами:
```{r 10-memory-usage-11 }
# создаем таблицу и смотрим ее адреса
my_df <- data.frame(col1 = 1:5, col2 = letters[1:5], col3 = month.abb[1:5], stringsAsFactors = FALSE)
lobstr::ref(my_df)

# создаем новую колонку и смотрим изменения
my_df$col4 <- sample(5)
lobstr::ref(my_df)
```




## Подходы к копированию и изменению объектов
### Copy-on-modify
В R реализован вызов по значению (call-by-value). Правда, в несколько нетрадиционном виде - его корректнее было бы назвать вызовом по соиспользованию (call-by-sharing), в R Internals он называется call by value illusion. Смысл заключается в следующем - когда мы создаем копию объекта, то первоначально адреса исходного объекта и копии совпадают:
```{r 10-memory-usage-12 }
# создаем объект
x <- 1:5

# создаем его копию
y <- x

# смотрим адреса обоих объектов
tracemem(x)
tracemem(y)
```

То есть, до какого-то момента объект и его копия делят один и тот же адрес в памяти. По-настоящему копия создается в тот момент, когда над копией производится какое-то действие:
```{r 10-memory-usage-13 }
y[6] <- 99L
untracemem(x)
untracemem(y)
```

Одновременно с механизмом copy-on-modify проявляется и обратная сторона процесса - изменение объекта всегда сопровождается его копированием, в некоторых случаях изменение может быть даже скрыто от пользователя. например, когда мы хотим добавить к вектору целых значений numeric-значение.
```{r 10-memory-usage-14 }
x <- 1:5
class(x)
tracemem(x)

x[6] <- 6
class(x)
```

Как мы видим, сначала за счет неявного преобразования типов (integer в numeric) происходит копирование и изменение объекта, а потом происходит добавление нового элемента, также с копированием и созданием объекта новой длины.

### Shallow copy
Полное копирование объекта при его изменении (deep copy) - это достаточно дорогостоящая процедура, особенно при больших объемах данных, так как, фактически, требует двух- или даже трех-кратного объема памяти объекта для проведения минимальных операций. В частности, из-за такого механизма R долгое время считался очень медленным языком. Тем не менее, в версии 3.1.0 была введен новый механизм копирования - shallow copy, поверхностное копирование. В первую очередь это касается списков и таблиц:

Основная идея механизма - копировать только тот элемент (подсписок или колонку), которая реально изменяется. Остальные элементы осталять неизменными до тех пор, пока не возникнет какая-то необходимость в их изменении. По сути, механизм shallow copy - сочетание особенности хранения списков в памяти и механизма copy-on-modify.

```{r 10-memory-usage-15 }
# создаем таблицу и смотрим ее адреса
my_df <- data.frame(col1 = 1:5, col2 = letters[1:5], col3 = month.abb[1:5], stringsAsFactors = FALSE)
lobstr::ref(my_df)

# создаем копию таблицы
my_df_copy <- my_df
lobstr::ref(my_df_copy)

# создаем новую колонку и смотрим изменения
my_df_copy$col1 <- my_df_copy$col1 * 2
my_df_copy$col4 <- sample(5)
lobstr::ref(my_df_copy)
```

При копировании таблицы адреса таблицы и ее копии, а так же колонок в таблице и копии совпадали. После изменения первой колонки и создания четвертой колонки в копии адрес копии и измененных / созданных колонок изменился. При это вторая и третья колонки, которые мы не меняли, остались по тому же адресу, что и в исходной таблице, в совместом использовании.

Как следствие, логичным выводом будет, что если мы изменим строку, то изменятся все колонки. То есть,  это очень невыгодная операция, особенно при больших размерах таблицы - обновлять надо будет полностью всю таблицу, а не только изменяемые колонки:
```{r 10-memory-usage-16 }
# смотрим адреса таблицы и колонок
lobstr::ref(my_df_copy)

# переприсваиваем в строку ее же значение (формально ничего не меняется)
my_df_copy[2, ] <- my_df_copy[2, ]

# смотрим еще раз адреса
lobstr::ref(my_df_copy)
```


### Modify-in-place
Помимо copy-on-modify, также есть возможность модификации объектов без копирования, на месте, modify-in-place. Подобные модификации возможны для векторов, а так же для окружений - при изменении объекта внутри окружения, адрес самого окружения не меняется:
```{r 10-memory-usage-17 }
# создаем новое окружение и один объект в нем
my_env <- new.env()
my_env$a <- 1:5
lobstr::ref(my_env)

# меняем объект
my_env$a[6] <- 99
lobstr::ref(my_env)
```

На практике сильнее всего (да и полезней) изменение на месте, без копирования, реализовано в пакете `data.table`. При изменении колонки вся таблица не копируется, а меняется только колонка или даже ее часть. 
```{r 10-memory-usage-18, message=FALSE}
library(data.table)
my_dt <- data.table(col1 = 1:5, col2 = letters[1:5], col3 = month.abb[1:5])
lobstr::ref(my_dt)

my_dt[, col1 := col1 * 2]
lobstr::ref(my_dt)
```

Однако к `data.table` также применима логика copy-on-modify, что вызывает казусы, когда стандартным путем создается и меняется копия таблицы - изменения также проявляются и в исходной таблице:
```{r 10-memory-usage-19 }
# создаем таблицу и ее копию
my_dt <- data.table(col1 = 1:5, col2 = letters[1:5], col3 = month.abb[1:5])
my_dt_copy <- my_dt

# смотрим их адреса
lobstr::ref(my_dt)
lobstr::ref(my_dt_copy)

# изменяем колонку в копии таблицы
my_dt_copy[, col1 := col1 * 2]

# смотрим результат
my_dt_copy
my_dt

# проверяем на тождество
all.equal(my_dt, my_dt_copy)

# еще раз смотрим адреса
lobstr::ref(my_dt)
lobstr::ref(my_dt_copy)
```

Для того, чтобы избегать подобных ситуаций, следует пользоваться явной функцией копирования `data-table` объектов - `data.table::copy()`. 

## Сборщик мусора
Сборщик мусора в R использует классический алгоритм - подсчет ссылок на объекты в памяти. То есть, подсчитывается, сколько ссылок есть на объект при каждом изменении, и если количество ссылок равно нулю, то объект может быть удален, а занимаемая им память возвращена операционной системе. 

При этом сборщик мусора работает "поколениями" - исходя из предположения, что на новые объекты ссылки могут чаще меняться, чем на старые, новые объекты просматриваются сборщиком мусора чаще. К сожалению, такой механизм вынужден просматривать весь кэш строковых значений, что в некоторых ситуациях может замедлять работу сборщика мусора.

Сборщик мусора в R работает в автоматическом режиме, однако в некоторых случаях есть смысл форсировать процесс и вызвать сборщик вручную. Основная функция вызова сборщика мусора - уже описанная ранее функция `gc()`. Аргумент full `= TRUE` позволяет игнорировать поколения объектов, в результате сборщик мусора просматривает все объекты.

Также есть функция `gcinfo()`, если ее запустить с аргументом `verbose = TRUE`, то она присутствует в фоновом режиме во время сессии, и при автоматическом срабатывании сборщика мусора сообщает пользователю текущие статистики `Ncells/Vcells`. Функции `gctorture()` и `gctorture2()` используются в очень редких случаях (и, в основном, разработчиками R), так как форсируют сборщик мусора при каждом размещении объекта в памяти, что существенно замедляет работу.


Помимо сборщика мусора в R есть возможность вручную запускать финализатор - во время выполнения какой-либо операции или же при завершении сессии. Тем не менее, функция `reg.finalizer()` используется достаточно редко, и ее применяют обычно только к R6-классам.

