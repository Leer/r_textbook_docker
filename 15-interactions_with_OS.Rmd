# Взаимодействие с ОС

## Работа с файлами
### Пути и названия файлов и директорий

Если предполагается использовать код в разных операционных системах, то имеет смысл учесть различие в формировании путей, в частности, прямые и обратные слэши в адресах файлов. Особенно это важно, когда при выполнении скрипта предполагается сохранение его или его результатов по определенному адресу. Также стоит помнить, что простое копирование путей из проводника Windows может не работать, так как R/RStudio предполагают использование прямых слэшей в путях.

Самый простой способ создания адреса обычно основан на использовании `paste()` + разделитель (`\` или `'/`). Корректнее воспользоваться функцией `file.path()`:
```{r 15-interactions-with-OS-1}
my_path <- file.path('.', 'dir_name', 'file_name.csv')
my_path
```

Иногда полезно использовать `file.path()` вместе с функцией `normalizePath()` и с аргументом `mustWork = FALSE`, если файл еще не создан. В частности, это повышает надежность пути. Также с помощью `normalizePath()` можно узнать полный адрес файла:

```{r 15-interactions-with-OS-2}
normalizePath('./data/spss_example.sav')
```

### Название и расширения файла
Достаточно часто возникает необходимость получить название файла или его расширение, или же просто удалить из пути все, кроме собственно названия файла. Например, нередко в названии файла может быть дата его создания или же идентификатор респондента.

Конечно, подобные задачи легко решаются регулярными выражениями, однако можно воспользоваться и базовыми функциями, в частности `basename()`, которая возвращает название файла и его расширение.
```{r 15-interactions-with-OS-3}
basename('./data/spss_example.sav')
```

В пакете `tools`, который идет в базовом наборе пакетов, имеет целый ряд полезных функций для работы с названиями файлов, в частности, `file_path_sans_ext()`, которая возвращает адрес файла, без расширения:
```{r 15-interactions-with-OS-4}
library(tools)
file_path_sans_ext('./data/spss_example.sav')
file_path_sans_ext(basename('../data/spss_example.sav'))
```

Извлечение названия директории файла проще и для него достаточно воспользоваться функцией `dirname()`:
```{r 15-interactions-with-OS-5}
dirname('./data/spss_example.sav')
```

### Создание файлов и директорий
При сохранении файлов (записи файлов на диск) приходится учитывать, что нельзя одновременно создать директорию и записать в нее файл - необходимо сначала создать директорию с помощью функции `dir.create()` и только потом в нее записать файл. 

```{r 15-interactions-with-OS-6}
# создаем директорию
my_dir_path <- './data/new_dir'
dir.create(path = my_dir_path)
```

Если попытаться создать директорию, когда директория с таким именем уже существует, то R выдаст предупреждение. Поэтому перед созданием директории стоит проверить, есть ли уже такая директория:
```{r 15-interactions-with-OS-7}
# повторяем создание
dir.create(path = my_dir_path)

# проверяем наличие
dir.exists(paths = my_dir_path)
```

В работе с файлами прослеживается такая же логика - можно создать файл с помощью функции `file.create()` и потом в него записать какой-то вектор. 
```{r 15-interactions-with-OS-8}
# создаем путь 
my_file_path <- file.path(my_dir_path, 'vec.txt')
print(my_file_path)

# создаем файл по этому пути
file.create(my_file_path)
write('записываем строку в файл', file = my_file_path)

# проверяем, что записалось:
readLines(my_file_path)
```

Как правило, необходимость в такой логике возникает очень редко, все же для сохранения объектов есть другие, более подходящие и удобные функции. Тем не менее, инструменты для низкоуровневой работы с файлами могут быть полезны - например, проверка на наличие файла, получение его метаинформации или просто смена прав доступа (для *nix-систем).

```{r 15-interactions-with-OS-9}
# проверяем на наличие
file.exists(my_file_path)

# смотрим даты создания, mode и проч.
file.info(my_file_path)
```

### Листинг файлов и директорий
Для создания списка файлов определенной директории можно воспользоваться функцией `list.files()`. Притом можно не просто просматривать файлы директории, но и выбирать конкретные файлы по паттерну (например, удобно читать потоком xlsx-файлы, и игнорировать временные excel-файлы). Функция может работать рекурсивно по вложенным директориям, а также возвращать полные пути и адреса файлов.
```{r 15-interactions-with-OS-10}
sav_files <- list.files(path = './data', pattern = '\\.sav$', full.names = TRUE)
sav_files
```

Аналогично можно анализировать структуру папок. Например, ранее мы создавали `new_dir` в директории `/data`, можно выбрать ее и все поддиректории:
```{r 15-interactions-with-OS-11}
list.dirs(path = './data')
```


### Удаление файлов
Функция для удаления файлов или директорий выглядит несколько неинтуитивно на первый взгляд. Тем не менее, она весьма логична, так как удаляет символическую ссылку на объект.
Использование очень простое - адрес файла иди директории передается в аргумент `x`. Для удаления директории необходимо использовать аргумент `recursive = TRUE`:
```{r 15-interactions-with-OS-12}
# удаляем файл my_file_path
unlink(my_file_path)
file.exists(my_file_path)

# удаляем директорию my_dir_path
unlink(my_dir_path, recursive = TRUE)
dir.exists(my_dir_path)
```

### Временные файлы и директории
Эпизодически возникают ситуации, когда необходимо промежуточный результат операции куда-то сохранить, чтобы потом дополнительно прочитать и обработать. Например, когда в файле данных много ошибок - лишних разделителей колонок или строк, можно его построчно импортировать, почистить строки от лишних знаков, также построчно сохранить и потом уже прочитать функцией для импорта таблиц со всеми необходимыми аргументами.

В таких случаях, чтобы не усложнять себе жизнь придумыванием уникальных имен и адресов файлов, можно воспользоваться временными файлами. Временные файлы создаются в временной директории, которая создается при запуске R-сессии (то есть, каждая сессия имеет собственную временную директорию).

```{r 15-interactions-with-OS-13}
# создаем название и путь временного файла
my_temp_file <- tempfile()
my_temp_file

# сохраняем iris во временный файл
write.csv(iris, my_temp_file, row.names = FALSE)

# импортируем первые 3 строки временного файла
read.table(my_temp_file, nrows = 3, header = TRUE, sep = ',')
```


## Работа с системными командами
Для того, чтобы из R вызвать какой-нибудь bash-скрипт, исполняемый файл или какую-либо команду, используют одну из двух функций - `system()` или `system2()`. 

Первая реализация механизма, `system()`, в \*nix-системах `system()` передает команду в командную строку, где она и выполняется. в Windows для вызова команд из командной строки есть функция `shell()`, а `system()` напрямую обращается к исполняемому файлу. Соответственно, результаты одной и той же функции в разных операционных системах могут не совпадать. Также в разных системах могут различаться обработка ошибок (`stderr`).

Первый аргумент функции `system()` - строка с текстом команды и ее аргументами, аргумент `intern = TRUE` используется в тех случаях, когда результат необходимо вернуть в рабочее окружение R-сессии. 

Вызовем R в командной строке с аргументом `-e` (expression), то есть, что необходимо выполнить указанное выражение `'2 + 2'`:
```{r 15-interactions-with-OS-14}
system("Rscript -e '2 + 2'")
```

Повторим операцию, только результат выполнения команды запишем в объект `from_cl`:
```{r 15-interactions-with-OS-15}
from_cl <- system("Rscript -e '2 + 2'", intern = TRUE)
str(from_cl)
```

Функция `system2()` - в определенной мере развитие `system()`, однако обе функции нельзя признать взаимозаменяемыми. В частности, `system2()` не зависит от платформы, аргументы команды передаются в отдельном строковом векторе. Также отличается и обработка потоков вывода / ошибок (stdout / stderr).

Вызовем R в командной строке и выполним выражение `'2 + 2'`:
```{r 15-interactions-with-OS-16}
system2("Rscript", args = "-e '2 + 2'")
```

Повторим и запишем результат в `from_cl2`:
```{r 15-interactions-with-OS-17}
from_cl2 <- system2("Rscript", args = "-e '2 + 2'", stdout = TRUE)
str(from_cl2)
```
