# Объекты и структуры данных {#objects}

## Векторы {#type_atomic}
В R используется шесть атомарных типов данных (подробнее о классах и типах см. #types_classes):

 - `character`. Используется для текстовых значений. Любой набор знаков, заключенный в кавычки, в R воспринимается как текстовое значение. Два нюанса - знак `#`, заключенный в кавычки, перестает быть символом, обозначающим комментарий. А обратный слэш, `\` все также остается знаком экранирования, что позволяет использовать в текстовых строках такие спец.символы как, например, `\n`. 
 - `complex`- используется при работе с комплексными числами.
 - `numeric` (или `double`). Используется для численных значений (с плавающей точкой).
 - `integer` - целые численные значения.
 - `logical` - Логические значения TRUE/FALSE.
 - `raw` - достаточно редко используемый тип данных, побайтовая запись в шестнадцатеричном формате.

Все числа в R хранятся в только виде чисел с плавающей запятой и двойной точностью. Числа с одинарной точностью можно симулировать в помощью функции `single()` или `as.single()`, приписав `numeric`-объекту атрибут `Csingle`. Однако это не настоящий хранимый формат и его использование имеет смысл только при обращении к некоторым функциям, написанным на C или Fortran. Хранение чисел в формате с плавающей запятой может приводить к некоторым казусам, когда требуется каким-то образом обрабатывать численные значения, которые не умещаются в 32 бита. Максимально возможное целочисленное значение можно определить с помощью `.Machine$integer.max`, все, что больше него, будет сконвертировано в `double` с плавающей запятой. Так как очень редко такие значения используются как численные и, чаще всего, это просто длинные идентификаторы (пользователей, например), то есть смысл их импортировать и хранить в виде строковых значений. Пример некорректной обработки целочисленных значений:

```{r 02-objects-ands-structures-1 }
15280137481015627194 - 15280137481015627776
```

 
В R используется достаточно простая система автоматического преобразования атомарных типов по логике от "самого строгого к самому гибкому", то есть по цепочке `logical` -> `integer` -> `numeric` -> `complex` -> `character` (тип `raw` не включается в эту систему). Такое преобразование позволяет использовать конструкции вида `sum(5 == 5)`, потому что логический результат сравнения (`TRUE`) будет преобразован в целое численное значение (`1`, так как `TRUE` преобразовывается в `1`, а FALSE - в `0`), и, следовательно, можно вычислить количество верных утверждений. Подобные процедуры крайне часто используются когда, например, надо посчитать количество определенных значений в векторе значений (или в колонке в таблице). Вообще, для избежания неожиданных результатов, крайне рекомендуется избегать неявных преобразований и контролировать типы самостоятельно.

Простая последовательность объектов одного атомарного типа называется вектором. Векторы создаются с помощью функции `c()` (`c` - от `combine`). Например:

```{r 02-objects-ands-structures-2 }
x <- c(1, 3, 5)
print(x)
```

Простое присвоение `x <- 'alpha'` также является созданием вектора, просто это вектор единичной длины. В том случае, если попытаться создать вектор из последовательности элементов разных атомарных типов, то все элементы будут преобразованы к самому общему типу в заданной последовательности:

```{r 02-objects-ands-structures-3 }
print(c(TRUE, 1, 2, FALSE, FALSE))
print(c(1, 3.6, 2, 5.1))
print(c('a', 3.6, 'b', 5.1))
print(c(TRUE, 3.6, 'b', 2))
```

В редких случаях используются векторы с именованными элементами (аналоги словарей в некоторых других языках программирования):

```{r 02-objects-ands-structures-4 }
x <- c(var1 = 12, var2 = 23, var3 = 34)
print(x)
```

Простую неименованную последовательность атомарного типа можно задать также другими командами, наиболее часто используемые из них: 
 - `seq()` - создание последовательности значений в указанном интервале, с заданным шагом (`seq` от `sequence`). Например: 

```{r 02-objects-ands-structures-5 }
x <- seq(from = 10, to = 2, by = -2)
print(x)
```
Первые два аргумента задают первое и последнее значения последовательности, а аргумент `by` - шаг последовательности (по умолчанию равен единице). Знак `-` для значения аргумента `by` маркирует, что последовательность убывающая.

 - выражение `:` - короткая форма функции `seq()`, используется для создания последовательности целых чисел, где последующее отличается от предыдущего на `1`. Так, выражение `5:1` тождественно выражению `seq(5, 1, -1)`.
 
- `rep()` - повтор какого-либо элемента заданное число раз. В качестве элемента может выступать практически любой объект R (в зависимости от осмысленности в целом подобного выражения). Аргументы `times` или `each` задают, какое количество раз повторять весь объект или каждый элемент объекта соответственно:

```{r 02-objects-ands-structures-6 }
x <- c('a', 'b', 'c')
rep(x, times = 2)
rep(x, each = 2)
```

Если значения аргументов задавать позиционно, то первый аргумент - это итерируемый объект, а второй аргумент - аргумент `times`:
```{r 02-objects-ands-structures-7 }
rep(x, 2)
```

- `sample()` - создание последовательности случайно выбранных значений из какого-то заданного вектора значений. Первый аргумент задает выборку, из которой необходимо извлечь подвыборку, второй аргумент (`size`) определяет объем извлекаемой выборки. Аргумент `replace` определяет, выборка извлекается с возвращением элементов или нет:
```{r 02-objects-ands-structures-8 }
sample(x = 1:5, size = 5, replace = FALSE)
sample(x = 1:5, size = 5, replace = TRUE)
```

- `vector()` - функция создания вектора значений определенного типа (обычно атомарного, но можно и создавать и более сложные объекты, например, списки, тогда в результате также будет список), где первый аргумент задает тип, а второй - длину вектора (количество элементов в последовательности). По умолчанию созданная последовательность заполнена значениями `FALSE`, если вектор логический, `0` и `''` если вектор численный или текстовый, соответственно. Одно из самых простых применений подобной конструкции - предварительная преаллокация памяти:
```{r 02-objects-ands-structures-9 }
x <- vector('character', 5)
x[2] <- 'second'
print(x)
```

- `raw()`, `logical()`, `integer()`, `numeric()`, `complex()`, `character()` - функции создания векторов, аналогичные `vector()`, для каждого из атомарных типов отдельно. В качестве аргумента эти функции принимают требуемую длину создаваемого вектора и создают вектор значений по умолчанию (`00` для raw-векторов, `FALSE` для логических векторов, `0` для численных и `""` для текстовых)

## Массивы  {#type_arrays}
Векторы, по сути, являются одномерными массивами элементов атомарных типов. В R, помимо подобных одномерных массивов, также можно создавать и многомерные массивы - двумерные массивы называются матрицами, многомерные, соответственно, многомерными массивами или многомерными матрицами. Все элементы массивов также должны быть элементами одного типа.

Матрицы создатся с помощью функции `matrix()`, где первым аргументом задается набор значений, а вторым и третьим аргументами - количество строк и столбцов в матрице. Заполнение ячеек массива происходит по колонкам - сначала заполняется построчно первая колонка, потом вторая (если есть) и т.д. Название строк и колонок, при желании, можно задать с помощью аргумента `dimnames` в виде списка векторов названий:
```{r 02-objects-ands-structures-10 }
x <- matrix(data = 1:4, nrow = 2, ncol = 2, dimnames = list(c('r1', 'r2'), c('c1', 'c2')))
print(x)
```

Многомерные массивы задаются аналогичным образом, только вместо аргументов количества строк и колонок используется аргумент `dim` (от `dimension`), задающий размерность массива. При `dim = c(2, 2)` будет создан двумерный массив 2*2, матрица, как и в примере выше.
```{r 02-objects-ands-structures-11 }
x <- array(data = 1:4, dim = c(2, 2), dimnames = list(c('r1', 'r2'), c('c1', 'c2')))
```

Если создать и вывести на печать трехмерный массив, который, в определенной мере можно назвать стопкой двумерных массивов, то на печать будут выведены матрицы для каждого элемента третьего измерения, для n-мерных массивов аналогично. Например, ниже мы создаем и выводим трехмерный массив размером 2\*2\*2. В  результате мы получаем две матрицы `[, , v1]` и `[, , v2]`:

```{r 02-objects-ands-structures-12 }
array(data = 1:8, dim = c(2, 2, 2), dimnames = list(c('r1', 'r2'), c('c1', 'c2'), c('v1', 'v2')))
```

Следует помнить, что массивы - это все те же векторы атомарных значений, просто с атрибутом размерности:

```{r 02-objects-ands-structures-13 }
x <- 1:10
dim(x) <- c(2, 5)
print(x)
```

## Списки  {#type_lists}
Списки - это объекты, которые можно представить в виде контейнеров, в которых могут содержаться объекты любых типов (в том числе и другие списки) любого уровня вложенности. По сути, списки представляют собой наборы ссылок на другие объекты. Для создания списка используется команда `list()`, где в аргументах через запятую перечисляются все элементы, которые необходимо включить в список. Например:

```{r 02-objects-ands-structures-14 }
x <- seq(from = 13, to = 0, by = -3)
y <- rep(x = 'c', times = 3)
z <- TRUE

my_list <- list(x, y, z)
print(my_list)
```

Помимо простого объединения объектов в списки и последующим вызовом элементов по номеру в списке, можно создавать именованные списки, где каждые элементы будут иметь заданное название. Например:

```{r 02-objects-ands-structures-15 }
x <- seq(from = 13, to = 0, by = -3)
y <- rep(x = 'c', times = 3)
z <- TRUE

my_list <- list(seq_example = x, 
                rep_example = y, 
                atomic_example = z)
print(my_list)
```


## Таблицы (датафреймы)  {#type_dataframes}
`data.frame` - базовый для R формат, который используется для хранения таблиц. Другими словами, таблица - это набор наблюдений по строкам и пространство признаков этих наблюдений в виде набора колонок. На уровне структуры `data.frame` - это все те же списки, в которых могут храниться разные по типу объекты, однако с требованием равенства длины объектов. Важно - все значения одной колонки могут быть только одного типа, а не как в Excel, OpenOffice или каком другом табличном процессоре.

Таблицы можно создать с помощью функции `data.frame()`, где, аналогично с созданием списка, через запятую перечисляются векторы, значения которых будут представлены в виде колонок. Так как все колонки должны быть одной длины, то и длины векторов, соответственно, должны быть одинаковы. Возможны и другие варианты создания `data.frame`-объектов путем преобразования из других объектов с помощью функции `as.data.frame()`.

```{r 02-objects-ands-structures-16 }
# создаем data.frame-объект
x <- seq(from = 10, to = 0, by = -2)
y <- rep(x = 'a', times = 6)
z <- sample(x = 1:20, size = 6, replace = FALSE)

dataset <- data.frame(column1 = x,
                      column2 = y,
                      column3 = z)

str(dataset)
```


## Факторы  {#type_factors}
Факторы (`factor`) - специфичный для R формат, это упорядоченный вектор номинальных или интервальных значений, аналог категориальных шкал. При этом объект с типом `factor` содержит как собственно значения, так и уровни, по которым эти значения упорядочены. Обычно факторы используют для упорядочивания номинальных или текстовых данных, а так же в различных статистических моделях и некоторых графиках. Создадим вектор значений `low`, `medium`, `high`, и сконвертируем его в фактор, где `high` - значение с самым низким рангом, а `low` - с самым высоким:

```{r 02-objects-ands-structures-17 }
quality <- c("low", "high", "medium", "high", "low", "medium", "high")
quality_f <- factor(quality, levels = c("high", "medium", "low"))
print(quality_f)
```
При выводе на печать, помимо собственно значений фактора, выводятся так же его уровни, в порядке возрастания (если не задавать уровни при конвертации в фактор, то уровни задаются в соответствии с алфавитным порядком). Следовательно, если отсортировать фактор, то значения будут выведены в соответствии с уровнями, в то время как простой атомарный вектор значений, на основе которых был создан фактор, будет отсортирован в алфавитном порядке:

```{r 02-objects-ands-structures-18 }
sort(quality)
sort(quality_f)
```

Факторы можно конвертировать в числа, в результате будет вектор значений, в котором значения фактора сконвертирован в номер его уровня (ранг категориальной переменной):

```{r 02-objects-ands-structures-19 }
print(quality_f)
as.numeric(quality_f)
```

Есть два нюанса при работе с факторами, которые могут существенно затруднить работу. Первый - уровни фактора хранятся в атрибутах. А второй - как правило, большинство функций импорта автоматически, если не указано обратное, конвертируют текстовые значения в факторы. В результате легко можно попасть в ситуацию, что если из базы данных импортируется несколько миллионов уникальных строк, то при импорте они конвертируются в факторы. А так как уровни фактора хранятся в атрибутах, то хранение таблицы удорожается в два раза, а при выборке из датасета десятка строк, объект с этими десяти строками будет содержать еще и все значения уровней из исходного массива. 

```{r 02-objects-ands-structures-20 }
# удалим все значения medium и law
quality_f <- quality_f[quality_f == 'high']
print(quality_f)
```

Для предотвращения подобных ситуаций рекомендуется либо в аргументах функций импорта указывать `stringsAsFactors = TRUE` (если аргумент `stringsAsFactors` есть, конечно же), либо сразу в опциях сессии  или в .RProfile указывать `options(stringsAsFactors = FALSE)`.

## Дата, дата и время  {#type_date}
Работа с датами и временем традиционно вызывает много сложностей, в частности, из-за формата представления данных или из-за необходимости учитывать временную зону. В R можно работать как просто с датами, так и с более сложными сущностями в виде даты и времени. Самое базовое правило при работе с датами и временем - стараться выбирать наиболее простой и общий формат. Как правило, это формат `Date`.

### Date
Формат (если корректнее, то класс) `Date` используется при работе с датами. `Date`-объект не содержит информацию о времени или временной зоне и предствляет собой количество дней с 1 января 1970 года (1970-01-01), представленное в человекочитаемом формате дат. В базовом R получить объект класса `Date` можно преобразованием других объектов с помощью функции `as.Date()`:

```{r 02-objects-ands-structures-21 }
# преобразование текстового значения
x <- as.Date('2018-04-01')
class(x)

# преобразование количества дней
x <- as.Date(17622, origin = '1970-01-01')
class(x)

# преобразование POSIXct-значения
x <- as.POSIXct(1522540800, origin = '1970-01-01')
x <- as.Date(x)
class(x)
```

`Origin` - это, в общем смысле, база, от которой отсчитывается количество дней или секунд до настоящего момента. По умолчанию это момент `1970-01-01 00:00:00`, который служит точкой отсчета в Unix (и прочих POSIX-совместимых операционных системах) системе описания моментов времени:

```{r 02-objects-ands-structures-22 }
# снимаем атрибут класса Date, в результате получаем количество дней
unclass(as.Date('2018-04-01'))

# вычитаем полученное количество из исходной даты
as.Date('2018-04-01') - 17622
```

Наиболее часто используемый формат представления дат - это формат `yyyy-mm-dd`, однако нередко встречаются иные варианты, особенно если импортируются данные из табличных процессоров типа Excel или Google Spreadsheet, например `mm/dd/yy` или `dd.mm.yyyy`. В таких случаях в функции `as.Date()` необходимо указывать используемый формат представления дат (подробнее в манипуляциях с датами):

```{r 02-objects-ands-structures-23 }
x <- as.Date('4/1/18', format = '%m/%d/%y')
str(x)
```

Так как формат `Date` - это, в неявном виде, количество дней, то при неаккуратном использовании можно столкнуться с ситуацией, когда объект даты конвертирутся и используется в численном виде. Например, если добавить объект даты к численному вектору, то он будет представлен в виде численного значения:

```{r 02-objects-ands-structures-24 }
# добавляем к численному вектору
c(1, 4, 9, as.Date('2018-04-01'))
```

### POSIXct, POSIXlt
Для работы с данными даты и времени используют функции `as.POSIXct()` и `as.POSIXlt()` (`cl` от `calendar time`, `lt` от `local time`). Обе функции работают c данными в юникс-формате (количество секунд с `1970-01-01 00:00:00`) и в качестве дополнительного аргумента требуют указать временную зону:

```{r 02-objects-ands-structures-25 }
# создаем as.POSIXct-объект
x_ct <- as.POSIXct(1522571987, origin = '1970-01-01', tz = 'UTC')
str(x_ct)

# создаем as.POSIXlt-объект
x_lt <- as.POSIXlt(1522571987, origin = '1970-01-01', tz = 'UTC')
str(x_lt)
```

Основное различие между функциями `as.POSIXct()` и `as.POSIXlt()` - первая, аналогично `Date`, хранит информацию в численном виде и представляет в текстовом виде, а также содержит метку временной зоны в атрибуте. Вторая - список параметров даты (день, месяц, год, час и т.д.), которую обозначает юникс-таймстамп в указанной временной зоне:

```{r 02-objects-ands-structures-26 }
# снимаем атрибут POSIXct-класса с объекта
unclass(x_ct)

# снимаем POSIXlt-класс с объекта и разворачиваем список
unlist(unclass(x_lt))
```

Следует учитывать, что время в юникс-формате - это всего лишь длина временного интервала в секундах и информацию о временной зоне не содержит. Функции `as.POSIXct()` и `as.POSIXlt()` по умолчанию проставляют временную зону локали, если не указано обратное. Как следствие, могут быть ситуации, когда в базе данных хранятся данные времени в юникс-формате (как правило, это так) и время на сервере выставлено по Гринвичу (GMT/UTC), а при импорте на локальный компьютер дата корректируется с учетом локальной временной зоны (несмотря на то, что используется одно и то же численное значение даты в юникс-формате):

```{bash 02-objects-ands-structures-27, eval = FALSE}
psql_server=> select to_timestamp(1522540800) as server_timestamp;
      server_timestamp      
------------------------
 2018-04-01 00:00:00+00
```

```{r 02-objects-ands-structures-28 }
# этот же таймстамп, без указания временной зоны локали
as.POSIXct(1522540800, origin = '1970-01-01')
```

## Формулы  {#type_formula}
Формульная нотация для записи регрессионной модели предложена Роджерсом и Вилкинсоном в 1973 году (@wilkinson1973symbolic), позднее ее включили в язык `S` (@chambers1991statistical) и, следовательно, она попала в `R`. На данный момент формулы - специальный объект, который описывает схему взаимодействия зависимой переменной (таргета) и независимых переменных (предикторов), а так же взаимодействие предикторов между собой. Простой пример формулы, описывающий одну зависимую переменную и две независимые:
```{r 02-objects-ands-structures-29, eval=FALSE}
y ~ x + z 
```

Слева от знака тильды назодится зависимая переменная (LHS, left-hand side). В стандартном использовании слева только одна переменная, если же необходимо указать несколько зависимых и/или их взаимодействие, то следует воспользоваться соответствующими пакетами. Справа от тильды, right-hand side (RHS) - две незавсимые переменные. Знак `+` в формулах означает независимое влияние переменных. По сути, формульная нотация - это своего рода DSL внутри `R`, так как в нотации привычные знаки и операторы имеют собственное значение:

- `+` используется для того, чтобы перечислить переменные-предикторы. 

- `-` используется, чтобы указать, влияние какого фактора необходимо исключить из модели

- `:` передает в качестве предиктора модели только взаимодействие факторов (аналогично `x1 * x2 - x1 - x2`)

- `*` задает как изолированное влияние каждого фактора, так и их взаимодействие (аналогично `x1 + x2 + x1:x2`)

- `|` используется в тех ситуациях, когда необходимо ввести в модель случайные эффекты

- `-1` или `0` в формуле указывает, что из модели следует исключить случайный член (intercept)

- `.` позволяет указывать в качестве предикторов все колонки в таблице, помимо зависимой переменной
 
Легче всего показать разницу в формулах с помощью простейшей линейной регрессии. Создадим несколько переменных, из которых разными методами сконструируем зависимую переменную:

```{r 02-objects-ands-structures-30 }
# создаем три предиктора
x1 <- rnorm(1000, 0, 1)
x2 <- rnorm(1000, 3, 5)
x3 <- rnorm(1000, -2, 2)
```

Создадим зависимую исходя из возможных вариантов взаимодействия предикторов. Следует помнить, что знак `*` в обычном выражении и в формуле интерпретируется по-разному.
```{r 02-objects-ands-structures-31 }
y <- 3 * x1 + 2 * x2 + 6 * (x2 * x3) + 7
```

Зададим и применим модель (`:`означает взаимодействие факторов). Модель должна вычислить заданные нами коэффициенты, которые мы использовали при создании вектора `y`:

```{r 02-objects-ands-structures-32 }
lm(y ~ x1 + x2 + x2:x3)
```
Аналогичный результат можно получить, если задать модель не через `:`, а через `*` и `-`:

```{r 02-objects-ands-structures-33 }
lm(y ~ x1 + x2 + x2*x3 - x3)
```


Так как поведение операторов в формулах иное, чем в обычных выражениях, то при необходимости использовать в формуле собственно сложение или другие операции, следует воспользоваться функцией `I()` (от `Inhibit`):

```{r 02-objects-ands-structures-34 }
y <- 4 * (x1 * x2)

# неправильная формула, так как * задает взаимодействие и независимое влияние, а не перемножение
lm(y ~ x1 * x2)

# правильная формула, I() позволяет воспринимать * как умножение
lm(y ~ I(x1 * x2))
```

Формулу можно создать несколько путями - просто создать текстовую переменную, либо же воспользоваться функцией `formula()`, в конце концов, можно просто написать `my_formulae = y ~ x`. Результаты потом можно использовать в соответствующих функциях. То, что формула - по сути, текстовое описание модели, позволяет создавать генераторы моделей (хотя представить ситуацию, в которой это необходимо, все же непросто). Пример случайной генерации моделей, сочетающих два независимых предиктора и взаимодействие еще двух предикторов:

```{r 02-objects-ands-structures-35 }
# создаем вектор текстовых значений имен предикторов
predictors <- c('x1', 'x2', 'x3', 'x4')
for (i in 1:5) {
  tmp <- paste(
    # выбираем независимые факторы
    paste(sample(predictors, 2), collapse = ' + '),
    # выбираем взаимодействующие факторы
    paste(sample(predictors, 2), collapse = ':'),
    sep = ' + ')
  tmp <- paste('y ~', tmp)
  print(tmp)
}
```

Формулы обычно используются в линейных моделях, случайных лесах и многих прочих функциях, в которых требуется описание модели взаимосвязи нескольких переменных. Тем не менее, ряд пакетов также использует собственную интерпретацию формул и знака тильды:

- пакеты `lattice`, `plotly` использует тильду для указания переменных, по которым строится график.

- в пакете `ggplot2` тильда используется для создания отдельных панелей графиков (фасет) и их расположения

- пакет `dplyr` и ряд других пакетов `tidyverse` используют `~` в некоторых функциях, например, `dplyr::case_when()`.


## Выражения и вызовы функции {#type_expression}
Выражения - объект, который содержит запись операции (операций) на R, чтобы можно было выполнить записанную операцию не сразу, а в необходимом месте (так называемое unevalueted expression). Подробнее про парсинг и выполнение выражений см. #eval. В базовом R выражения можно создать с помощью функции `expression()`, по аналогии с созданием вектора:

```{r 02-objects-ands-structures-36 }
# создаем выражение из двух операций
my_exp <- expression(x <- 6, x ^ 2)
print(my_exp)

# вызываем вызажение
eval(my_exp)
```

Второй вариант создания выражения - это парсинг текстовой строки, в котором также записана операция на языке R. Для подобного парсинга используется функция `parse()` и строковая запись передается в аргумент `text`. Также в функции `parse()` можно указывать кодировку записи, что может быть полезно, когда скрипт был написан и сохранен в одной кодировке, а вызывается в в рабочей среде с другой кодировкой. В примере ниже мы хотим записать две операции в одну строку, поэтому их необходимо разделить `;`:

```{r 02-objects-ands-structures-37 }
# записываем операции в строковый объект
my_exp <- "x <- 6; x ^ 2"
class(my_exp)

# парсим стровую запись операций
my_exp <- parse(text = my_exp)
class(my_exp)

# выполняем результат парсинга
eval(my_exp)

```

Функция `call()` создает несколько похожий на выражения объект, только при вместо записи какой-либо операции содержит запись вызова функции - первым аргументом в `call()` передается название функции, последующими аргументами - значения, которые должны быть переданы в аргументы этой функции:

```{r 02-objects-ands-structures-38 }
# создаем вызов функции возведения в степень
my_call <- call('^', 3, 2)
class(my_call)

# выполняем объект вызова функции
eval(my_call)
```

На практике нередко встречается другой вариант работы с вызовами функции, когда с помощью `do.call()` вызывают функцию со списком аргументов и сразу получают результат. Самый наглядный пример - это вызов функции `merge()`:

```{r 02-objects-ands-structures-39 }
df1 <- data.frame(var1 = letters[1:3], df1_col = sample(5, 3))
df2 <- data.frame(var1 = letters[1:3], df2_col = sample(month.abb, 3))
df3 <- data.frame(var1 = letters[1:3], df3_col = rnorm(3))
list_df <- list(df1, df2, df3)

do.call('merge', c(list_df[1:2], list(by = 'var1', all.x = TRUE)))

# аналог с помощью Reduce
Reduce(function(x, y) merge(x, y, by = "var1"), list_df)
```



## NULL, NA, Inf, NaN {#type_na}
Ряд специальных значений или объектов используется в сиутациях, когда значения или объекта нет, значение недоступно или некорректно:

 - `NA` - `not avaliable`. Ситуация, когда значение пропущено или неопределено. Например, для какой-то строки в колонке таблицы нет значения или когда текстовое значение пытаются преобразовать в численное или логическое. Следует учитывать, что `NA` - это, в первую очередь, логическое значение, маркирующее, что значение пропущено, и будет ошибкой приравнять его к нулю, например, или к `NULL`. Когда известно, какого типа значения вектора, можно использовать специализированные вариации `NA` - `NA_character_`, `NA_integer_`, `NA_real_` или `NA_complex_`.
 - `NULL` - пустой (null) объект с собственным одноименным типом. Объект `NULL` не может быть использован одновременно с другими объектами, например, при создании последовательности, а присвоение какому-то элементу объекта значения `NULL` удаляет этот элемент. Чаще всего это встречается при работе с списками или таблицами, так как присвоение элементу значения `NULL` удаляет из списка ссылку на заданный объект.
 - `NaN`, `Inf` - `not a number` и `infinite` соответственно. Используются при работе с численными значениями и появляются при некорректных с математической точки зрения операциях - `0/0` и `1/0` соответственно. Значение `Inf` может быть как положительным, так и отрицательным.


## Окружения  {#type_envir}
Окружения, в самом общем виде - именованные коллекции объектов, объектами обычно являются объявленные функции, данные, другие окружения. Окружения в некотором смысле похожи на именованные списки (#type_lists), но сходство только внешнее, так как окружения, в отличие от списков, не имеют порядок объектов (соответственно, объекты окружения нельзя вызвать по их номеру, как в листе) и ансамбль окружений может быть представлен в виде дерева - у любого окружения есть родительское окружение. 

Различают несколько типов окружений:

- пустое окружение (`emptyenv()`, `R_EmptyEnv` - зарезервированние название объекта пустого окружения в памяти) - окружение, которое является самым `древним` родительским окружением (то есть, все прочие окружения являются дочерними относительно пустого). Пустое окружение не содержит никаких объектов:
```{r 02-objects-ands-structures-40 }
ls(emptyenv())
```

- базовое окружение (`baseenv()`), окружение пакета `base`, родительским окружением для него является пустое окружение:
```{r 02-objects-ands-structures-41 }
baseenv()
parent.env(baseenv())
```

- глобальное окружение (`globalenv()` или `.GlobalEnv` при интерактивной работе, `R_GlobalEnv` - зарезервированние название объекта глобального окружения в памяти). Глобальное окружение создается при загрузке интерактивного рабочего пространства. Как правило, большая часть работы в R протекает в глобальном окружении. Родительским окружением для глобального окружения является окружение последнего загруженного пакета:
```{r 02-objects-ands-structures-42 }
parent.env(.GlobalEnv)
```

- текущее окружение (`environment()`) - любое окружение, в котором производится какое-то действие в настоящий момент. Так, при работе в глобальном окружении функция `environment()` вернет `R_GlobalEnv`. При вызове `environment()` внутри какой-либо функции результатом будет адрес объекта окружения окружения в памяти. При необходимости, окружение функции можно записать в отдельный объект в родительском окружении.
```{r 02-objects-ands-structures-43 }
tmp <- function(b) {
     print(environment())
     b <- b * 2
     b
}
tmp(4)
```

Так как каждое окружение, по сути, включает в себя собственно объекты окружения, а так же указание на родительское окружение, то возможны ситуации поиска и использования объекта из родительского окружения или создание объекта в родительском окружении. В примере ниже в глобальном окружении создается объект, а потом этот объект используется в другой функции глобального окружения, несмотря на то, что он не передан в качестве аргумента. Второй момент - в функции, объявленной в глобальном окружении, используется созданный объект, а так же используется оператор `<<-` для создания нового объекта в родительском глобальном окружении при вызове функции. Также в функции используется оператор `<<-` для создания объекта окружения функции в глобальном окружении, чтобы после завершения работы функции можно было посмотреть, какие внутренние объекты были созданы в при выполнении функции.

```{r 02-objects-ands-structures-44 }
# создаем объект в глобальном окружении
x_global <- 5

# создаем функцию в глобальном окружении
my_fun <- function(x) {
  # в окружении функции создаем новый объект
  z_inside <- x + x_global
  
  # создаем объект в родительском  окружении
  z_global <<- z_inside * 2
  
  # записываем окружение функции в объект в родительском окружении
  fun_environment <<- environment()
  
  return(z_inside)
}
# вызываем функцию
my_fun(3)

# пытаемся вызвать объект, созданный функцией в глобальном окружении
print(z_global)
```
Использование объекта из родительского окружения в дочерних окружениях возможно за счет организованного поиска по дереву родительских окружений - используемый объект сначала ищется в текущем окружении и если не находится, то поиск продолжается по родительским окружениям. Объект `z` был создан внутри окружения функции, и там же и остался, а объекты `z_global` и `fun_environment` принадлежат глобальному (родительскому для окружения функции) окружению, несмотря на то, что упоминаются в теле функции:
```{r 02-objects-ands-structures-45 }
ls(fun_environment)

c('z_inside', 'z_global', 'fun_environment') %in% ls(.GlobalEnv)
```


За пределами функций использование окружений достаточно ограничено. Как правило, это либо ситуативные модификации функций пакетов или эзотерические практики организации объектов в интерактивном рабочем пространстве. Однако у окружений есть одна, нечасто используемая характеристика - можно использовать окружения как хеш-таблицы, в которых операции поиска, вставки или удаления по ключам значений (названию) осуществляются в среднем быстрее, чем по обычным таблицам. 

Например, создадим два объекта - таблицу, в которой в одной колонке будет вектор `имен` - текстовых значений, а во второй - численное значение (`0L`). Второй объект - хешированное окружение с таким же количеством объектов, как строк в таблице. Каждый объект этого окружения имеет название, соответствующее значениям в первой колонке таблицы, а значения объектов - значениям из второй колонки таблицы (0L для всех объектов, как и для всех строк таблицы).

```{r 02-objects-ands-structures-46 }
# создаем вектор уникальных "имен"
vector_letters <- paste(
  sample(letters, 10e4, replace = TRUE),
  sample(10e4, replace = FALSE), 
  sep = '_')

# создаем таблицу
simple_df <- data.frame(var1 = vector_letters, var2 = 0L)

# создаем хешированное окружение
hash_env <- new.env(hash = TRUE)
for (i in vector_letters) hash_env[[i]] <- 0L
```

Как можно увидеть по бенчмаркам, поиск значения определенного объекта в хешированном окружении существенно быстрее поиска соответствующих значений в таблице:

```{r 02-objects-ands-structures-47 }
microbenchmark::microbenchmark(
  df_search = simple_df[simple_df$var1 == vector_letters[999], ],
  hash_env_search = hash_env[[vector_letters[999]]],
  1000, unit = 'ms')
```


## Функции {#type_function}
Функции - такие же объекты R, как и списки, окружения и т.д. Функции состоят из трех основных элементов - списка аргументов, тела функции и ее окружения. Объявим простейшую функцию:

```{r 02-objects-ands-structures-48 }
new_fun <- function(x) {
  # комментарий в функции
  x <- sqrt(x)
  x
}

new_fun(3)
```

Список аргументов является одной из форм списков, унаследованных от S - `pairlist`, и может быть вызван с помощью функции `formals()` или, в более удобной для чтения форме, функции `args()`. Так как список аргументов - это отдельный объект, то, при желании, можно извлечь названия аргументов и/или модифицировать список аргументов, например, добавить аргументу значение по умолчанию. Стоит отметить, изменение аргументов подобным образом - крайне редкая практика, притом, потенциально опасная, так как снижает прозрачность и понятность кода.

```{r 02-objects-ands-structures-49 }
# смотрим аргументы функции
args(new_fun)
formals(new_fun)

# смотрим класс списка аргументов
class(formals(new_fun))

# добавляем аргументу значение по умолчанию:
formals(new_fun) <- list(x = 9)

# вызываем функцию с обновленным списком аргументов
new_fun()
```

Тело функции - код, который находится в фигурных скобках и описывает все действия, которые выполняются при вызове функции. Код тела функции можно вызвать с помощью функции `body()`, однако возвращен будет только исполняемый код, т.е. комментарии будут опущены. В том случае, когда хочется посмотреть весь код функции, можно просто вывести на печать объект функции. Впрочем, оба метода не работают для примитивных функций (см.ниже про `.Primitive`). Как и список аргументов, тело функции можно модифицировать, передав ему новое значение в виде выражения (см.также NSE), и точно также, по возможности, следует избегать подобных практик:

```{r 02-objects-ands-structures-50 }
# смотрим тело функции
body(new_fun)

# выводим на печать всю функцию
print(new_fun)

# модифицируем тело функции и вызываем обновленную функцию
body(new_fun) <- expression(x ^ 3)
new_fun()
```

Третий элемент функций - это рабочее окружение функции (другими словами, область видимости функции). Про окружения речь шла ранее (см. #type_envir). В окружениях функций возможно как локальное, так и глобальное присвоение, есть механизмы поиска используемых объектов по дереву родительских окружений, если объект не найден в текущем окружении. Функция `environment()` возвращает, в зависимости от того, как и в какой момент вызвана, либо окружение, в котором объявлена функция, либо адрес объекта окружения функции в памяти. В последнем случае объект окружения можно сохранить и использовать, в том числе и в родительском окружении: 

```{r 02-objects-ands-structures-51 }
# объявляем функцию, в которой есть вывод на печать списка объектов и адрес окружения функции
new_fun2 <- function(x) {
  print(environment())
  print(ls())
  x <- sqrt(x)
  return(x)
}

# смотрим, в каком окружении объявлена функция
environment(new_fun2)

# смотрим, как работает вызов environment() в теле функции
new_fun2(3)
```

Стоит учесть, что ряд функций напрямую обращается к коду на C и не имеет кода на R. Такие функции называют примитивными, их относительно немного и все они принадлежат базовому пакету (`base`). В силу того, что примитивные функции обращаются к C-коду напрямую, их поведение может иногда отличаться от прочих функций, написанных на R. В том числе эти функции возвращают `NULL` при попытке увидеть их pairlist-список аргументов (через `formals()`), тело и окружение функции. Пример примитивной функции:

```{r 02-objects-ands-structures-52 }
print(sqrt)
args(sqrt)
formals(sqrt)
body(sqrt)
environment(sqrt)
```

