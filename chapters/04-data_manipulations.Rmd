# Манипуляции с данными {#manipulations}

## Выбор элемента объекта 

### Выбор элемента вектора
Выбор элементов векторов указывается с помощью оператора `[` по следующей схеме: `x[<condition>]`. Эт#о читается как `'элементы вектора x, которые удовлетворяют условию <condition>'`. В качестве условия может быть указатель номера элемента в последовательности (индекс), так и какое-то логическое условие. При использовании оператора `[` в `<condition>` может быть передан вектор значений (или логическое выражение, возвращающее вектор значений), а оператор, напомним, `[[` принимает только одно значение (вектор единичной длины).

#### Выбор по номеру позиции
Простой вариант выбора определенных элементов последовательности - по номеру в последовательности (по индексу, индекс начинается с 1). Например, в последовательности `4, 3, 2` на третьем месте находится значение `2`. В коде выбор третьего элемента этой последовательности выглядит вот так:
```{r 04-data-manipulations-1 }
x <- c(4, 3, 2)
x[3]
```

В список номеров последовательности также можно передавать не только единичное значение, но и вектор значений номеров последовательности, который мы хотим извлечь. Например:
```{r 04-data-manipulations-2 }
x <- c(4, 3, 2, 1)
x[c(2, 4)]
```


#### Выбор по значению
Также возможен выбор элементов вектора, которые удовлетворяют условию. Например, те, которые больше 10, или все, которые равны 3, или все четные. Логика такого выделения следующая: кажый элемент последовательности сравнивается с условием, и если сравнение верное (`5 == 5`, `TRUE`), то этот элемент возвращается как подходящий под условие. Фактически, метка `TRUE` здесь является указателем элемента, который надо вернуть, аналогично номеру позиции при выделении по номеру позиции.

```{r 04-data-manipulations-3, echo = FALSE}
set.seed(1234)
```

Например:
```{r 04-data-manipulations-4 }
# создаем вектор 8 случайных значений из массива от 1 до 10
x <- sample(1:10, 8)
str(x)

# сравниваем каждое значение с 5
x_cond <- x > 5
str(x_cond)

# делаем выбор по условию, с указанием вектора, удовлетворяет элемент условию или нет
x[x_cond]

# аналогично, но без создания отдельного вектора
x[x > 5]
```


#### Выбор по наличию в другом векторе

Нередко встречаются ситуации, когда необходимо выбрать значения вектора, которые присутствуют в другом векторе. Например, из списка группы студентов выбрать тех, кто указан в списке недопущенных к сессии. Для этого используется выражение `x %in% y`. Оператор `%in%` проверяет, встречается ли каждый элемент вектора `х` в векторе `y`. Как и в сравнении по условию, в результате получается логический вектор, который можно использовать для выделения элементов. Выделенные элементы можно записать в отдельный объект. 

Например:
```{r 04-data-manipulations-5 }
x <- c('aaa', 'abc', 'bgs', 'gtr', 'ant', 'cer')
y <- c('tue', 'bgs', 'mtw', 'cer', 'lka')

# сравниваем элементы списков
x %in% y

# выделяем те элементы списка х, которые есть в у
x[x %in% y]

# записываем результат в отдельный объект
z <- x[x %in% y]
str(z)
```

### Выбор элемента списка
Выбор элементов списка также использует выбор по номеру элемента. Следует учитывать, что для списков несколько различается поведение операторов `[` и `[[`. Так, оператор `[` позволяет выделить элемент списка в виде отдельного списка:
```{r 04-data-manipulations-6 }
# создадим список
my_list <- list(seq_example = seq(from = 13, to = 0, by = -3), 
                rep_example = rep(x = 'c', times = 3), 
                atomic_example = TRUE)
str(my_list)
```


```{r 04-data-manipulations-7 }
# выберем первый элемент списка
first_element <- my_list[1]
str(first_element)
```

Оператор `[[` позволяет вызвать значения вызываемых элементов списка. Так, `my_list[[1]]` вызовет не первый элемент в виде списка, а значения первого элемента в виде вектора (как они и были заданы):
```{r 04-data-manipulations-8 }
# выберем значения первого элемента списка
first_element_values <- my_list[[1]]
str(first_element_values)
```

Также для именованных списков можно использовать выделение по имени элемента. Для указания элемента списка используется оператор `$` и конструкция вида `list_name$element_name`. Например:

```{r 04-data-manipulations-9 }
# смотрим на список
my_list

# выбираем элемент seq_example
str(my_list$seq_example)
```


### Выбор строк или столбцов в data.frame

#### Выбор строк в data.frame
Выбор строк в `data.frame` осуществляется аналогично выбору элементов в векторе - по номеру строки или по какому-то условию. При выборе по номеру строки также можно указать вектор номеров строк, которые необходимо вернуть. При выборке строки по условию проверяется, удовлетворяет ли условию каждый элемент строки в определенной колонке, и если удовлетворяет, выделяется вся строка.

Так как `data.frame` - это, в какой-то мере, двумерный массив, то логика указания и выделения строк и столбцов аналогичная, и имеет общий вид `dataset[выбор строк, операции над колонками]`. 

```{r 04-data-manipulations-10 }
# создаем датасет
df_dataset <- data.frame(var1 = sample(1:12, 8, replace = T),
                      var2 = sample(letters[1:15], 8, replace = T),
                      var3 = seq(8, 1, -1),
                      var4 = rep(c('abc', 'xyz'), 2))
str(df_dataset)
```
 
Выбор строки или нескольких строк полностью аналогичен операциям над векторами - можно указать номер желаемой сроки, или вектор строк. Если указывать вектор строк, то необходимо помнить, что вектор всего лишь указывает, какой элемент вектора необходимо извлечь, соответственно, какойнибудь элемент можно извлечь несколько раз, можно задать свой порядок номеров извлекаемых строк и так далее.
```{r 04-data-manipulations-11 }
#  выбор по одному номеру строки
df_dataset[5, ]

# выбор по нескольким номерам строк
# сначала создаем вектор номеров строк, пятую строку извлекаем дважды, после восьмой строки извлекаем еще и первую
my_rows <- c(2, 5, 5, 8, 1)

# выводим строки, которые мы указали в векторе
df_dataset[my_rows, ]

# или, аналогично, сразу указываем, какие строки хотим выделить
df_dataset[c(2, 5, 8), ]
```


В том случае, когда необходимо выбрать какие-то строки по условию относительной той или иной колонки, то необходимо указать требуемую колонку с помощью оператора `$` (или любым другим образом, ниже подробнее про указание и выделение колонок). Точно также, по сути, сначала производится логическое сравнение вектора значений указанной колонки, и результат в виде вектора логических значений `TRUE/FALSE` уже используется для указания целевых строк (для которых результат сравнения истенен, `TRUE`)
```{r 04-data-manipulations-12 }
# выбор по условию
# выводим все строки, в которых в колонке var4 есть значение 'xyz'
df_dataset[df_dataset$var4 == 'xyz', ]

# выводим все строки, в которых в колонке var3 значения больше 5
df_dataset[df_dataset$var3 > 5, ]

# выводим все строки, в которых значения в колонке var1 - четные
df_dataset[(df_dataset$var1 %% 2) == 0, ]

# вывод сочетания условий - только те строки, где в var4 значения 'xyz'
# и где в var3 значения больше 5
df_dataset[df_dataset$var4 == 'xyz' & df_dataset$var3 > 5, ]
```


#### Выбор колонки в data.frame
Синтаксис `data.frame` позволяет несколькими путями выбрать одну колонку. Первый вариант предполагает использование порядкового номера колонки в датасете. Номер колонки задается с помощью оператора `[` (чаще всего) и при этом надо помнить, что в двумерных массивах сначала, до запятой, задаются строки, а потом - колонки. В редких случаях можно использовать оператор `[[`, и тогда переданный номер сразу интерпертируется как номер колонки в датасете. В результате подобной операции мы получаем вектор значений:

```{r 04-data-manipulations-13 }
df_dataset[, 3]
class(df_dataset[, 3])
```

Несмотря на то, что это очень простой и очевидный вариант, его использовать не рекомендуется, особенно в ситуации большого проекта, совместной работы над кодом или каких-то исследовательских задачах, во всех ситуациях, когда возможно случайное или слабоконтролируемое изменение порядка колонок в датасете или добавление/удаление колонок, или что-то подбное. Общая рекомендация в данном случае - использовать названия колонок вместо численных индексов, или же вообще использовать оператор `$` или `[[`. Например:

```{r 04-data-manipulations-14 }
# выделяем колонку по имени 
df_dataset[, 'var3']

# выделяем по имени и с помощью оператора [[
df_dataset[['var3']]

# выделяем колону по имени и с помощью оператора $
df_dataset$var3
```

При всем удобстве оператора `$`, не следует забывать, что его использование, за счет постоянных повтором названия таблицы, делает код визуально тяжелым и несколько избыточным, что затрудняет чтение кода. Использование оператора `[[` в целом достаточно редкая практика, хотя тоже возможная. Лучшим вариантом будет использовать вызов колонок в виде `data.frame[, 'your_col_name']` при указании колонки или колонок, и `data.frame['your_rows', ]` для указания строк(и).

Также следует иметь ввиду разное поведение операторов `[` и `[[` при указании колонок - если использовать синтаксис списков, а не массивов (то есть, не использовать запятую для указания, что берутся колонки таблицы), то эти операторы воспринимают таблицу как список. Соответственно, результат использования оператора `[` будет таблицей, а `[[` - вектором:
```{r 04-data-manipulations-15 }
# смотрим содержание таблицы
str(df_dataset)

# смотрим класс второй колонки при вызове через синтаксис матриц
df_dataset[, 2]
class(df_dataset[, 2])

# смотрим класс второй колонки при вызове через `[`
df_dataset[2]
class(df_dataset[2])

# смотрим класс второй колонки при вызове через `[[`
df_dataset[[2]]
class(df_dataset[[2]])

```


#### Выбор нескольких колонок в data.frame
Выбор нескольких колонок осуществляется с помощью либо вектора номеров колонок в таблице, либо вектора названий колонок. Вектор значений можно задать как отдельный объект или же, для лаконичности, сразу с помощью `c()`. Оператор `$` в данном случае неприменим, как и `[[`:
```{r 04-data-manipulations-16 }
# выделяем с помощью вектора индексов
df_dataset[, c(1, 2)]

# выделяем с помощью вектора названий колонок
df_dataset[, c('var1', 'var2')]
```

## Сортировка и упорядочивание векторов и таблиц
Для сортировки векторов используются функции `sort()` и `order()`. Функция `sort()` просто сортирует и упорядочивает значения по возрастанию (действие по умолчанию, для обратной сортировки надо задать значение `TRUE` для аргумента `decreasing`):
```{r 04-data-manipulations-17, echo = FALSE}
set.seed(1234)
```
```{r 04-data-manipulations-18 }
# создаем вектор случайных значений из множества 1:10
x <- sample(10)
str(x)
```

```{r 04-data-manipulations-19 }
# сортируем по возрастанию и по убыванию
sort(x)
sort(x, decreasing = TRUE)
```


Функция `order()` действует несколько немного сложнее - она возвращает вектор номеров позиций, на которых должны стоять соответствующие значения сортируемого вектора. Например, в векторе `x` содержатся числа от 1 до 10, в случайном порядке. Результат функции `order()` демонстрирует, что если мы хотим упорядочить по возрастанию исходный вектор, то нам необходимо первым поставить седьмое значение из вектора `x` (`x[7]`), вторым - первое значение (`x[1]`), третьим - десятое значение вектора `x` (`x[10]`) и так далее.
```{r 04-data-manipulations-20 }
x
order(x)
```

В том случае, если использовать функцию `order()` для сортировки и упорядочивания значений векторов, то необходимо результат функции передавать, с помозью оператора `[` в качестве вектора, какие значения в каком порядке мы хотим извлечь из вектора. В таком случае получаем аналогичный функции `sort()` результат:
```{r 04-data-manipulations-21 }
x[order(x)]
sort(x)
```

При работе с таблицами для задач сортировки строк или столбцов используется функция `order()` для указания индексов строк или столбцов. Функция `sort()` здесь нерелевантна и при неосмысленном использовании может привести к ошибкам или неверному результату. Это возможно потому что функция `sort()` отдает вектор сортированных значений, а не индексы. Например, в таблице `df_dataset` всего восемь строк. Если использовать `sort()` в виде выражения `df_dataset[sort(df_dataset$var1), ]`, то мы, фактически, запрашиваем таблицу, которая составлена из строк по номерам согласно значениям в колонке `var1`, по возрастанию (1, 4, 4, 6, 6, 8, 11, 12). В этом векторе запрашиваются 11 и 12 строки датасета, несмотря на то, что сам датасет состоит из восьми строк. В результате получается несколько иной результат, чем предполагался:
```{r 04-data-manipulations-22 }
df_dataset
df_dataset[sort(df_dataset$var1), ]
```

Функция `order()` в качестве результата отдает не сам упорядоченный вектор значений, а, фактически, вектор-инструкцию, как надо переставить значения в исходном векторе, чтобы получить упорядоченный вектор. Соответственно, применительно к таблицам - как надо переставить местами строки, чтобы получить таблицу с упорядоченными значениями по одной или нескольким колонкам:
```{r 04-data-manipulations-23 }
df_dataset
df_dataset[order(df_dataset$var1), ]
```

Так как сортировка таблиц, по сути, является перезаписыванием таблицы с новым порядком строк или колонок, то можно обойтись без использования функции `order()`, и вручную указать, как и в какой последовательности должна быть упорядочена таблица. Также это подходит и для ситуаций, когда неприменима сортировка по возрастанию или убыванию:
```{r 04-data-manipulations-24 }
# сортируем колонки в произвольном порядке
df_dataset  <- df_dataset[, c('var2', 'var1', 'var4', 'var3')]
df_dataset
```

## Изменение, создание и удаление элементов объектов
В задачах на изменение значения элемента векторов, списков или таблиц используется следующая логика - указывается элемент объекта, с которым надо произвести какое-то действие, и этому элементу присваивается новое значение. Например, у нас есть вектор из 10 значений в случайном порядке от 1 до 10, и мы хотим возвести в квадрат третий элемент:
```{r 04-data-manipulations-25, echo = FALSE}
set.seed(1234)
```
```{r 04-data-manipulations-26 }
# создаем вектор
x <- sample(10)
str(x)
```
```{r 04-data-manipulations-27 }
# возводим в квадрат третий элемент:
x[3] <- x[3] ^ 2
str(x)
```

Создание новых элементов или удаление уже существующих производятся аналогично - указывается индекс элемента (или его название, если применимо), и присваивается какое-то значение. Для создания элемента - любой объект, если он не нарушает уже существующую структуру (например, в таблице на пять строк нельзя создать колонку с шестью значениями), если в векторе создавать значение иного типа, чем был, то все значения будут преобразованы к более общему по правилам преобразования. 
```{r 04-data-manipulations-28 }
# создаем 11 элемент вектора x, текстовых
x[11] <- 'x'
str(x)
```

Для удаления элемента вектора можно просто сделать переприсвоение этому объекту тех же значений, за исключением того, которое требуется удалить:
```{r 04-data-manipulations-29 }
# удалим 3 значение вектора x
x <- x[-3]
str(x)
```

При необходимости удаления строк или колонок из таблицы или для удаления элемента списка также можно воспользоваться логикой переприсвоения (для строк таблиц это, практически, единственный вариант). Для удаления колонок таблицы или элементов списка можно также воспользоваться присвоением удаляемой колонки значения `NULL` (не путать с `NA`, это разные типы и объекты!). Удаление элемента через присвоения значения `NULL` возможно только для элементов списков (`list`) или колонок таблиц (так как таблицы - это один из вараинтов списков):
```{r 04-data-manipulations-30 }
# смотрим структуру и удаляем var4
str(df_dataset)
df_dataset[, 'var4'] <- NULL

# еще раз смотрим структуру
str(df_dataset)
```


## Манипуляции с таблицами
### Построчное объединение таблиц, rbind()
Функция `rbind()`(от `row bind`) используется для объединение двух или более таблиц по строкам. В результате получается таблица с таким же количеством колонок, но с увеличенным числом строк - по количеству строк в объединяемых таблицах.

Нередко в объединяемых таблицах отсутствует какая-нибудь колонка, или колонки перепутаны. В таких случаях необходимо первоначально создать и заполнить `NA` недостающие колонки и/или отсортировать колонки у нужном порядке.
```{r 04-data-manipulations-31 }
# создаем первую таблицу
df1 <- data.frame(tb = 'table_1',
                  col1 = sample(9, 3),
                  col3 = 'only in table1',
                  col2 = sample(letters, 3))
str(df1)
```

```{r 04-data-manipulations-32 }
# создаем вторую таблицу
df2 <- data.frame(tb = 'table_2',
                  col4 = 'only in table2',
                  col1 = sample(9, 3),
                  col2 = sample(letters, 3))
str(df2)
```


```{r 04-data-manipulations-33 }
# создаем колонки
df1$col4 <- NA
df2$col3 <- NA

# сортируем
df1 <- df1[, c('tb', 'col1', 'col2', 'col3', 'col4')]
df2 <- df2[, c('tb', 'col1', 'col2', 'col3', 'col4')]
```

```{r 04-data-manipulations-34 }
# объединяем по строкам
rbind(df1, df2)
```




### Поколоночное объединение таблиц, cbind()
Функция `cbind()` (от `columns bind`) используется для объединения нескольких векторов или таблиц равной длины. В результате получается объединенная таблица такой же длины как каждый из объединяемых векторов, в случае объединения таблиц - с таким же количеством строк, как в каждой из объединяемых таблиц, и с суммарным количеством колонок. По сути, создание `data.frame` - это `cbind()` нескольких векторов равной длины.

При использовании `cbind()` в работе с таблицами необходимо помнить, что это, буквально, "склейка" таблиц, независимо от порядка наблюдений по строкам. В противном случае можно получить наблюдение, где часть колонок описывает характеристики этого наблюдения, а другая часть - каких-то других наблюдений.

Другой нюанс, который также необходимо учитывать - при объединении таблиц названия колонок останутся прежними. Так что если в нескольких таблицах встречается, например, колонка `col1`, то в финальном датасете также будет несколько колонок с таким названием, по количеству сливаемых таблиц, в которых она была. В свою очередь, это усложняет задачи выбора колонки по названию и запутывает, в какой колонке какое содержание.


```{r 04-data-manipulations-35 }
# выведем разнее созданные таблицы
print(df1)
print(df2)

# объединим по колонкам
cbind(df1, df2)

# теперь отсортируем вторую таблицу по колонке col1
cbind(df1, df2[order(df2$col1)])
```


### Слияние таблиц по ключу, merge()
Одна из самых, наверное, важных операций при работе с таблицами - построчное слияние двух или нескольких таблиц. При использовании функции `merge()` каждому значению в ключевой колонке первой таблицы сопоставляется строка параметров наблюдения другой таблицы, с таким же значением в ключевой колонке, как и в первой таблице. В других языках программирования, в SQL, в частности, аналогичная функция может называться `join`.
Несмотря на сложность формулировки, выглядит это достаточно просто:
```{r 04-data-manipulations-36 }
# создаем датасет 1, в синтасисе data.frame
dt1 <- data.frame(key_col = c('r1', 'r2', 'r3'),
                  col_num = seq_len(3))

# создаем датасет 2, в синтасисе data.frame
dt2 <- data.frame(key_col = c('r3', 'r1', 'r2'),
                  col_char = c('c', 'a', 'b'))

# сливаем построчно по значениям в колонке key_col
merge(x = dt1, y = dt2, by = 'key_col')
```

Здесь первая таблица задается аргументом `x`, вторая таблица - аргументом `y`, а колонка (или колонки), по значениям которой происходит слияние таблиц, задается аргументом `by`. Если аргумент `by` не указан, то слияние происходит по тем колонкам, которые имеют одинаковое название в сливаемых таблицах.  Притом, таблицы можно сливать по значениям колонок разными именами, тогда надо отдельно указать, по значениям каких колонок в первой и второй таблице происходит слияние, и для этого вместо общего аргумента `by` используют аргументы `by.x` и `by.y` для первой и второй таблицы соответственно.

В первом приближении операция слияния `merge()` похожа на результат работы функции `cbind()`. Однако, из-за того, что при слиянии происходит сопоставление по значениям ключевых колонок, в результате получается решается проблема слияния колонок, в которых разный порядок строк. Сравните:

```{r 04-data-manipulations-37 }
cbind(dt1, dt2)

merge(x = dt1, y = dt2, by = 'key_col')
```


Второе существенное отличие от `cbind()` - обработка ситуаций, когда в таблицах разное количество наблюдений. Например, в первой таблице данные по первой волне опросов, а во второй - данные по тем, кто из принявших участие в первой волне, принял участие и во второй волне, а так же какие-то новые опрошенные респонденты. Разное количество наблюдений в сливаемых таблицах порождает четыре варианта слияния, все они задаются аргументом `all` с постфикасми:
- `all` = FALSE. Значение аргумента по умолчанию, в результате слияния будет таблица с наблюдениями, которые есть и в первой, и во второй таблице. То есть, наблюдения из первой таблицы, которым нет сопоставления из второй таблицы, отбрасываются. В примере с волнами это будет таблица только по тем, кто принял участи и в первой, и во второй волнах опросов:
```{r 04-data-manipulations-38 }
# создаем данные первой волны
wave1 <- data.frame(id = paste0('id_', seq_len(5)),
                    col1 = sample(10, 5))
print(wave1)
```
```{r 04-data-manipulations-39 }
# создаем данные второй волны
wave2 <- data.frame(id = paste0('id_', c(1, 3, 5, 6, 7, 8)),
                    col2 = sample(letters, 6))
print(wave2)
```
```{r 04-data-manipulations-40 }
# сливаем так, чтобы оставить только тех, кто был в обеих волнах
merge(x = wave1, y = wave2, by = 'id', all = FALSE)
```

- `all.x` = TRUE. Всем наблюдениям из первой таблицы сопоставляются значения из второй. Если во второй таблице нет соответствующих наблюдений, то пропуски заполняются `NA`-значениями (в нашем примере в колонке `col2`):
```{r 04-data-manipulations-41 }
# сливаем так, чтобы оставить тех, кто был в первой волне
merge(x = wave1, y = wave2, by = 'id', all.x = TRUE)
```
 
- `all.y` = TRUE. Обратная ситуация, когда всем наблюдениям из второй таблицы сопоставляются значения из первой, и пропущенные значения заполняются `NA`-значениями (в нашем примере в колонке `co12`):
```{r 04-data-manipulations-42 }
# сливаем так, чтобы оставить тех, кто был во второй волне
merge(x = wave1, y = wave2, by = 'id', all.y = TRUE)
```

- `all` = TRUE. Объединение предыдущих двух вариантов - создается таблица по всему набору уникальных значений из ключевых таблиц, по которым происходит слияние. и если в какой-то из таблиц нет соответствующих наблюдений, то пропуски также заполняются `NA`-значениями:

```{r 04-data-manipulations-43 }
# сливаем так, чтобы оставить тех, кто был в какой-то из обеих волн
merge(x = wave1, y = wave2, by = 'id', all = TRUE)
```

При работе с несколькими таблицами можно столкнуться с ограничением, что базовая функциz `merge()` работает только с парами таблиц. То есть, если вдруг необходимо слить по одному ключу сразу несколько таблиц (например, не две волны опросов, а пять), то придется строить последовательные цепочки попарных слияний. Правда, возможен альтернативный вариант - писать собственные функции или использовать соответствующие функции из других пакетов. В частности, `full_join()` из пакета `dplyr`.



### wide-long трансформации, reshape
Обычная форма представления данных в таблицах - когда одна строка является одним наблюдением, а в значениях колонок отражены те или иные характеристики этого наблюдения. Такой формат традиционно называется `wide`-форматом, потому что при увеличении количества характеристик таблица будет расти вширь, путем увеличения числа колонок. Пример таблицы в `wide`-формате.
```{r 04-data-manipulations-44 }
# создаем таблицу с идентификатором респондента, его возрастом, ростом и весом
dt_wide <- data.frame(
  wave = paste0('wave_', rep(1:2, each = 2)),
  id = paste0('id_', seq_len(4)),
  age = c(45, 13, 29, 69),
  height = c(163, 142, 178, 155),
  weight = c(55, 40, 85, 63))
dt_wide
```


Тем не менее, нередко встречается другой формат, в котором на одно наблюдение может приходиться несколько строк (по количеству измеренных характеристик этого наблюдения). В таком случае таблица состоит из колонки, в котором содержится какой-то идентификатор объекта, колонки одной или нескольких), в которых содержатся идентификаторы характеристик объекта, и колонки, в которой содержатся значения этих характеристик. Такой формат называется длинным, `long`-форматом данных, потому что при увеличении количества измеряемых характеристик, таблица будет расти в длину, увеличением строк.

```{r 04-data-manipulations-45 }
# создаем таблицу с идентификатором респондента, его возрастом, ростом и весом
dt_long <- data.frame(
  # две волны, по два респондента в каждой
  wave = paste0('wave_', rep(1:2, each = 6)),
  # на каждого респондента задаем три строки
  id = paste0('id_', rep(1:4, each = 3)),
  # три характеристики повторяем для четырех респондентов
  variable = rep(c('age', 'height', 'weight'), 4),
  # задаем значения характеристик, с учетом того, как упорядочены первые две колонки
  value = c(45, 163, 55,
            13, 142, 40,
            29, 178, 85,
            69, 155, 63))

dt_long
```

#### dcast()

Для того, чтобы трансформировать `long`-формат в `wide`-формат, используется функция `dcast()` пакета `reshape2` (либо пакета `data.table`). Также можно использовать функцию `reshape()` из базового набора функций R, однако эта функция достаточно медленная и отличается весьма неудобным синтаксисом.

Для того, чтобы превратить созданную выше таблицу в `long`-формате в широкий формат, выражение будет выглядеть следующим образом (сама операция называется решейп):
```{r 04-data-manipulations-46 }
library(reshape2)
dcast(data = dt_long, formula = wave + id ~ variable, value.var = 'value')
```

Здесь аргумент `data` - определяет таблицу, которую мы хотим трансформировать. 

Аргумент `formula` задает, что в результирующей таблице будет задавать уникальное наблюдение, и значения какой колонки будут разделены на самостоятельные колонки. Формулу можно прочитать как `строки ~ колонки` в результирующей таблице. В нашем случае уникальное наблюдение мы задаем парой переменных `wave` и `id`, поэтому мы их указываем до тильды через `+`. Колонки же мы создаем по значениям переменной `variable`, после тильды. Следует отметить, что ситуация, когда строка задется несколькими переменными через оператор `+` весьма частая, а вот в правой части формулы несколько переменных встречаются достаточно редко, обычно все же на колонки раскладывают по значениям одной переменной. 

Аргумент `value.var` содержит текстовое название переменной, значения которой будут отражены в результирующей таблице по колонкам для каждого наблюдения. 

Иногда случаются ситуации, когда необходимо провести сначала агрегацию по одной из колонок, описывающих наблюдение. Например, вычислить средние значения возраста, роста и веса для каждой волны. Это можно сделать в два этапа - сначала провести агрегацию, и потом решейп. Также можно сразу сделать решейп, и воспользоваться дополнительным аргументом `fun.aggregate`, который сразу, при решейпе, агрегирует данные. Например, если использовать сначала агрегацию, а потом трансформацию в `wide`-формат:
```{r 04-data-manipulations-47 }
# агрегируем наблюдения по волнам и характеристикам
tmp <- aggregate(value ~ wave + variable, dt_long, mean)
tmp

# трансформируем в wide-формат. колонки id уже нет в таблице, поэтому удаляем из формулы
dcast(data = tmp, formula = wave ~ variable, value.var = 'value')
```

Аналогично, но с использованием аргумента `fun.aggregate`. В значения аргумента передаем название функции без кавычек и скобок, в нашем случае это `fun.aggregate = mean`:
```{r 04-data-manipulations-48 }
dcast(data = tmp, formula = wave ~ variable, value.var = 'value', fun.aggregate = mean)
```


#### melt()
Обратная трансформация также возможна, из `wide`-формата в `long`-формат. Для этого используется функция `melt()`: 

```{r 04-data-manipulations-49 }
melt(data = dt_wide, 
     id.vars = c('wave', 'id'),
     measure.vars = c('age', 'height', 'weight'),
     variable.name = 'variable',
     value.name = 'value')
```

Здесь аргумент `id.vars` задает переменные, которые будут использоваться для уникальной идентификации наблюдения. Аргумент `measure.vars` определяет те колонки, которые войдут длинную таблицу как значения переменной характеристик наблюдений (когда каждая строка - отдельная характеристика наблюдения, несколько строк на одного пользователя). Аргументы `variable.name` и `value.name`  задают, соответственно, названия колонок характеристик наблюдения и значений этих характеристик в финальной таблице. В принципе, эти аргументы необязательны, так как `melt()` самостоятельно присваивает названия этим колонкам, если они не указаны, но могут сильно упростить и сделать более прозрачным код. Пример решейпа в long-формат без указания названий колонок характеристик и их значений:

```{r 04-data-manipulations-50 }
melt(data = dt_wide, 
     id.vars = c('wave', 'id'),
     measure.vars = c('age', 'height', 'weight'))
```
## Манипуляции с датами и временем

### Форматирование и парсинг дат и времени
При работе с датами нередко возникает ситуация, когда необходимо либо привести текстовую запись даты (или даты и времени) к какому-то виду, либо извлечь из даты месяц, день недели или какой-либо другой параметр. Для все этих задач используется функции `as.Date()` и `strftime()` , где в аргумент `format` передается буквенный код требуемого формата (по стандарту ISO 8601). Наиболее часто используемые коды:

- %Y год со столетием, четырехзначный формат
- %y год в двузначном формате
- %m месяц в двузначном формате (01-12)
- %B Полное название месяца на языке локали
- %b Сокращенное название месяца на языке локали
- %U Номер недели месяца в двузначном формате (00–53), неделя начинается с первого *воскресенья* года (первый день первой недели)
- %W Номер недели месяца в двузначном формате (00–53), неделя начинается с первого *понедельника* года (первый день первой недели)
- %V Номер недели месяца в двузначном формате (00–53), согласно стандарту ISO 8601, неделя начинается с первого *четверга* года (если четыре и больше дней недели в новом году, считая неделю с понедельника - то это первая неделя года, иначе - неделя предыдущего года). Не используется на ввод (создание даты из текстовой записи).
- %j день года в трехзначном формате (001–366).
- %d день месяца в двузначном формате (01–31).
- %w номер дня недели (0–6, 0 означает воскресенье).
- %u номер дня недели (1–7, 1 означает понедельник). Не используется на вывод (извлечение данных из даты) в Windows.
- %A полное название дня недели на языке локали
- %a сокращенное название дня недели на языке локали
- %H час в двузначном формате (00–23).
- %M минута в двузначном формате (00–59).
- %S секунда в двузначном формате (00–61), в том числе с поддержкой високосных секунд (в POSIX-совместимых системах високосные секунды игнорируются)
- %F Аналог стандартной ISO 8601 записи даты,  `%Y-%m-%d`
- %D Локально-специфичная запись даты по стандарту ISO C99, `%m/%d/%y`
- %T Эквивалентно `%H:%M:%S`.

Коды можно использовать как для создания дат (input), так и извлечения из дат требуемой информации (output), например, номера дня или месяца. Следует учитывать, что, согласно справке функции `strftime()` некоторые коды могут неодинаково работать на ввод и вывод, а так же зависеть от используемой операционной системы.

При создании дат на вход подается текстовая запись, а в записи формата, помимо кодов указывается использованный разделитель. Например, когда есть номер недели и день недели, сначала создаем текстовую запись с пробелом в виде разделителя, а потом в функции `as.Date()` прописываем, как форматировать полученную запись:
```{r 04-data-manipulations-51 }
# создадим дату из номера недели и номера дня недели
x <- paste(2018, 40, 1)
str(x)
x_date <- as.Date(x, format = '%Y %W %w')
str(x_date)
```
Для обратной операции, извлечения данных из даты, используем `strftime()` и также указываем, какие значения нужны, как именно парсить дату:
```{r 04-data-manipulations-52 }
# извлекаем из сформированной даты номер недели и день
strftime(x_date, c('%W', '%w'))
```

### Вычисление дат и времени

Так как форматы `Date` и `POSIXct` представляют собой количество дней и секунд с 1 января 1970 года (по умолчанию), то при работе с датами и временем можно использовать операции сложения и вычитания (другие арифметические операции не определены для объектов `Date` и `POSIXct`):
```{r 04-data-manipulations-53 }
# создаем объект х с текущей датой
x <- Sys.Date()
str(x)

# прибавляем семь дней к текущей дате
x_7 <- x + 7
str(x_7)

# вычитаем 10 дней
x_10 <- x - 10
str(x_10)
```

Подобным образом поступаем и с `POSIXct`-датой, с учетом того, что изменение даты и времени происходит на количество секунд. Если требуется изменить собственно дату, то надо количество дней умножить на 86400 (60*60*24):
```{r 04-data-manipulations-54 }
# создаем объект х_px с текущими датой и временем
x_px <- Sys.time()
str(x_px)

# прибавляем семь секунд к текущему времени
x_px7 <- x_px + 7
str(x_px7)

# вычитаем 10 дней
x_px10 <- x_px - 10 * 86400
str(x_px10)
```

Сложно представить такую необходимость, однако, при желании, для дат и времени можно определить собственные арифметические операторы, так как выражение `Sys.Date() - 1` сводится к выражению `structure(unclass(Sys.Date()) - 1, class = "Date")`. Выражение `Sys.time() - 1` аналогично сводится к `.POSIXct(unclass(Sys.time()) - 1, attr(Sys.time(), "tzone"))`.


### Вычисление интервалов
Помимо сложения и вычитания дат с числами, можно также вычислять длительность интервала между двумя датами. Для этого используется функция `difftime()`, которая в качестве аргументов принимает даты конца и начала интервала, а также указание, в каком виде должен быть представлен интервал (секунды, минуты, часы, дни, недели). В результате получается численное значение с мерой интервала в атрибуте:
```{r 04-data-manipulations-55 }
x1 <- Sys.Date()
x2 <- Sys.Date() + 7
x_diff <- difftime(x2, x1, units = 'weeks')
print(x_diff)
str(x_diff)
```

Простое вычитание дат дает такой же результат, как и использование функции `difftime()` (что неудивительно, так как в она используется в функции бинарного вычитания дат). По умолчанию полученный интервал представлен в днях ли в секундах, для `Date` и `POSIXct` соответственно. В последнем выражении время меньше семи секунд, так как само вычисление выражения требует времени, а `Sys.time()` возвращает текущее системное время:
```{r 04-data-manipulations-56 }
# вычитаем из увеличенной на 7 дней даты дату
Sys.Date() + 7 - Sys.Date()

# вычитаем из увеличенного на 7 секунд времени время
Sys.time() + 7 - Sys.time()
```

Полученный в результате вычитания дат объект имеет свой собственный класс, `difftime`. С этим объектом также можно работать - совершать арифметические операции сложения и вычитания (и даже умножения и деления), использовать в вычислении интервалов:
```{r 04-data-manipulations-57 }
print(x_diff)

# умножаем интервал на 3
print(x_diff * 3)

# увеличиваем дату на вычисленный ранее интервал
x_dd <- Sys.Date() + x_diff
str(x_dd)
```
