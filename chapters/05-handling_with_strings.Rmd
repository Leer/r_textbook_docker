# Работа со строками и текстами {#strings}
## Операции со строками
### Смена регистра, tolower() и toupper()
Одна из самых простых операций со строковыми значениями - это смена регистра, перевод заглавных букв в строчные и наоборот. Одни из наиболее частых способов использования - уникализировать значения (чтобы `Слово` и `слово` были идентичными объектами), привести к требуемому стандарту (например, идентификатор мобильного устройства использует только заглавные буквы, а в логах почему-то оказались строчные) и проч.
```{r 05-handling-with-strings-1 }
tolower('Слово')
toupper('6d92078a-8246-4Bb4-AE5B-76104861e7DC')

```

### Слияние строк
#### paste() и paste0()
Для слияния строк обычно используется две базовые функции `paste()` и `paste0()`. Основное различие между функциями в используемом разделителе - `paste0()` используется тогда, когда требуется слить строки без какого-либо разделителя, `paste()` - когда надо задать какой-то разделитель, по умолчанию используется пробел. Если в функции `paste()` использовать аргумент `sep = ''`, то результат будет идентичен результату функции `paste0()`. В обе функции можно передавать атомарные объекты разного типа, все они будут приведены к строковому типу (значение `NA` будет прочитано как NA, `TRUE` аналогично):

```{r 05-handling-with-strings-2 }
paste0('пример №', 1, ': демонстрируем работу функции paste0()')
```

```{r 05-handling-with-strings-3 }
paste('пример №', 2, ': демонстрируем работу функции paste()', sep = '_')
```

Функция `paste()` векторизирована и воспринимает все аргументы (кроме как `sep` и `collapse`) как отдельные векторы, которые и обрабатывает поэлементно. Это значит, что если векторы будут разной длины, то короткий вектор будет обрабатываться циклично, что приведет к удвоениям значений, по длине самого длинного вектора. В примере ниже одинарные векторы `'пример'`, `':'` и `'строка'` повторяются трижды, по длине вектора `c(3, 4, 5)`. Вектор `c(1:2)` состоит из двух элементов, в то время как в результате должно быть использовано три элемента из него, поэтому первый элемент берется повторно. 
```{r 05-handling-with-strings-4 }
paste('пример', c(3, 4, 5), ':', 'строка', c(1:2), sep = '_')
```

Если в функцию `paste()` передать только один вектор, то результат будет идентичен исходному вектору - так как нет другого вектора, с элементами которого можно было бы проводить слияние. В тех случаях, когда есть необходимость слить все элементы одного вектора в одно строковое значение, используется аргумент `collapse`:
```{r 05-handling-with-strings-5 }
paste(letters[1:5], sep = ', ')
paste(letters[1:5], collapse = ', ')
```

Чаще всего разница между аргументами `sep` и `collapse` проявляется при работе с таблицами. Так, `sep` используется в тех случаях, когда необходимо создать колонку или вектор значений из значений других колонок, то есть, путем поэлементного слияния векторов (колонок). `collapse` используется тогда, когда надо собрать из значений колонки одинарный вектор, нередко одновременно с группировкой (одинарный вектор для каждого уникального значения группирующей переменной):
```{r 05-handling-with-strings-6 }
# создаем датасет и колонку
df <- data.frame(var1 = rep(c('id1', 'id2'), each = 3),
                   var2 = sample(letters, 6),
                   var3 = sample(6))
df$var4 <- paste(df$var2, df$var3, sep = '_')

# получаем одно значение из всех значений колонки var2
paste(df$var2, collapse = '_')

# получаем одно значение из всех значений колонки var2 с группировкой по колонке var1
aggregate(var2 ~ var1, data = df, FUN = paste, collapse = '_')
```

#### glue()
`glue` - функция одноименного пакета, аналогична по назначению функции `paste()`. Функция `glue()`, по сути, является синтаксическим сахаром и имеет только одно отличие, которое существенно облегчает работу в ряде задач - требуемое значение можно передать сразу в строку с помощью фигурных скобок, а не дополнительным вектором. В этом `glue()` схожа с `sprintf()` (в целом, подобные конструкции можно найти во многих языках программирования):
```{r 05-handling-with-strings-7 }
my_value <- 999

# выражение с использованием paste()
paste0('сейчас используем значение: ', my_value, ', в функциях paste()/paste0() это сложно для восприятия')

# выражение с использованием glue()
glue::glue('сейчас используем значение: {my_value}, в функции glue() это выглядит проще')
```

Функция `glue()` чаще всего используется в тех ситуациях, когда в какой-то блок кода необходимо передавать большой ряд изменяемых значений (как правило, это глобальные переменные, объявленных ранее). Например, с помощью `glue()` можно писать запросы к базам данных по одному и тому же периоду, или использовать один запрос  сразными токенами API-доступа. Например, так бы выглядели запросы к PostgreSQL за последние 5 дней от текущей даты:
```{r 05-handling-with-strings-8 }
# создаем объекты с требуемыми датами 
t_start <- Sys.Date() - 5
t_end <- Sys.Date()

# формируем SQL-запрос 
query <- glue::glue("select * from my_table where ts between '{t_start}' and '{t_end}';")
query
```
### Разделение и выделение строк
#### Разделение строк, strsplit()
Наряду со слиянием строк, нередка обратная ситуация, когда надо разделить строку на одну или несколько частей. Чаще всего для таких задач используется функция `strsplit()` или ее аналоги в дополнительных пакетах, например `data.table::tstrsplit()`. `strsplit()` в качестве аргументов принимает объект-строку, символ, по которому надо разделить строку и метка, принимать ли символ-разделитель как есть, или принимать как regexp-выражение (в том случае, если разделитель имеет дополнительное значение как регулярное выражение). 
```{r 05-handling-with-strings-9 }
my_string <- 'ab_cd.efg.hi_jk'

# разбиваем строку по символу '_'
strsplit(my_string, '_')

# используем как разделитель точку как regexp-обозначение любого символа
strsplit(my_string, '.')

# используем как разделитель точку as is
strsplit(my_string, '.', fixed = TRUE)
```

В результате `strsplit()` возвращает список, в котором первым и единственным элементом списка служит вектор требуемых значений. Следовательно, для того, чтобы получить какой-то определенный элемент списка, необходимо прямо его указать с помощью операторов `[` и `[[`:

```{r 05-handling-with-strings-10 }
strsplit(my_string, '_')[[1]][1:2]
```

#### Выделение строк, substr() и strtrim()
Функции `substr()` и `strtrim()` используются в ситуациях, когда необходимо каким-то образом сократить длину строки или же извлечь определенную ее часть. Например, подобные ситации возникают в тех случаях, когда критично количество символов в названии файла или таблицы. Так, по базовым настройкам баз данных Oracle, название таблиц не может быть длиннее 30 символов. Соответственно, при экспорте данных в базу необходимо контролировать длину строк:
```{r 05-handling-with-strings-11 }
# создаем длинное название таблицы
new_db_table_name <- '1_very_long_name_for_dummy_table_into_my_database'

# определяем, какой длины полученное название
nchar(new_db_table_name)

# создаем новое название, оставляем только 30 символов
strtrim(new_db_table_name, 30)

# создаем новое название, оставляем только 3-32 символы
substr(new_db_table_name, start = 3, stop = 32)
```

### Изменение части строки, gsub() и sub()
Выделение строк с помощью `substr()` и `strtrim()` обладает одним большим недостатком - необходимо знать количество символов в строке, или же задавать какой-то интервал желаемых символов. В большинстве случаев оказывается удобнее ориентироваться на содержание строки, а не просто на количество и порядковые номера символов в ней. В других случаях бывает необходимо заменить какие-ниюудь символы в строке - например, убрать знаки препинания из предложения, или каким-то другим образом почистить строковые значения. Все эти задачи можно, при большом желании и упорстве, решить с помощью `substr()`, однако будет намного проще и эффективнее воспользоваться функцией `gsub()`. Функция `gsub()` ищет в заданной строке требуемый паттерн (фиксированный набор символов или же регулярное выражение), и заменяет его на другой произвольный набор символов, как правило, на пустую строку, то есть, на отсутствие символов - `''`. Функция `gsub()` заменяет все найденные по соответствию паттерна части строки, функция `sub()` - только первое вхождение.
```{r 05-handling-with-strings-12 }
# предложение, в котором есть опечатки
my_string <- 'Senten8ce with err0ors'

# удаляем числа с помощью regexp-паттерна и заменяем слово with
my_string <- gsub(pattern = '[0-9]', replacement = '', x = my_string)
my_string

# заменяем слово with, указываем доп.параметры
my_string <- gsub(pattern = 'with', replacement = 'without', x = my_string, fixed = TRUE)
my_string
```


### Извлечение части строки, regmatches() 
Функция `gsub()` - очень мощный инструмент при работе со строковыми данными, особенно при препроцессинге. Тем не менее, некоторые задачи с ее помощью выполнить достаточно сложно, в первую очередь из-за того, что функция предполагает поиск и замену какого-то набора символов, удовлетворяющих паттерну. То есть, в ситуациях, когда нужно, наоборот, удалить все, кроме определенного набора символов, требуется достаточно много нетривиальных усилий, чтобы решить задачу с помощью `gsub()`. Средствами регулярных выражений сделать операцию логического отрицания можно лишь в относительно простых случаях, а вот задачи типа вычленения e-mail адреса из строки сделать уже достаточно сложно. В подобных ситуациях лучше использовать пару функций `regexpr()` и `regmatches()`. Первая функция определяет номер символа, с которого начинается требуемая комбинация символов и длину определенного набора. Функция `regmatches()` используется для извлечение строки на основе результата `regexpr()` (при необходимости можно воспользоваться и `substr()`). Попробуем разными методами извлечь e-mail из строки:

```{r 05-handling-with-strings-13 }
# задаем e-mail
my_email <- 'my e-mail address is fenrir999@asgard.com'

# извлечение с помощью gsub() и regexp-групп
gsub('(.*\\s)([A-Za-z0-9]+\\@[A-Za-z0-9]+\\.[A-Za-z]+)', '\\2', my_email)

# извлечение с помощью regexpr() и regmatches()
regmatches(my_email, regexpr("([A-Za-z0-9]+@[A-Za-z0-9]+\\.[A-Za-z]+)", my_email))

# извлечение с помощью regexpr() и substr()
tmp <- regexpr("([A-Za-z0-9]+@[A-Za-z0-9]+\\.[A-Za-z]+)", my_email)
substr(my_email, start = tmp[1], stop = tmp[1] + attr(tmp, "match.length"))
```


## Регулярные выражения
### Паттерны
В примерах к функциям `gsub()` и  `regexpr()` мы упоминали и применяли особые конструкции, которые используются при обработке строковых данных - регулярные выражения. Регулярные выражения (англ. Regular Expressions, regexps)- это специальный язык для описания шаблонов строк, который используется для поиска определенных строк, проверки их на соответствие какому-либо шаблону и другой подобной работы. В функцих `gsub()` и  `regexpr()` мы как раз искали необходимые нам части строк с помощью паттернов (шаблонов), написанных в виде регулярнх выражений.

Реализация регэкспов в разных языках программирования может различаться, в R используется расширенная версия регулярных выражений (ERE, стандарт POSIX 1003.2) с некоторыми собственными дополнениями, а так же Perl-совместимые регулярные выражения (PCRE 8.36). Согласно станларту POSIX 1003.2, длинна регулярных выражений не может превышать 256 байтов. Впрочем, как показывает практика, с таким ограничением мало кто сталкивается в своей работе.

С регулярными выражениями есть, к сожалению, одна достаточно неприятная особенность - если выражение написано неправильно (в частности, при использовании  метасимволов), то в результате, в зависимости от контекста использования, будет либо пропуск нужных элементов, либо просто отсутствие какого-либо эффекта. Поэтому есть смысл упрощать работу с регулярными выражениями, особенно если нет достаточного опыта их использования. Например, разбивать делать изменение части строки в несколько этапов, или же просто тестировать регулярные выражения небольшими блоками.

### Символы
В большинстве своем символы в регулярных выражениях обозначают сами себя, за некоторыми исключениями (#text_metasymbol). Каждый символ в паттерне задает соответствие только одному символу в строке, поэтому в тех случаях, когда необходимо указать какой-то символ из определенного набора или указать, что какой-то символ повторяется некоторое количество раз подряд, следует использовать символьные классы или квантификаторы соответственно.

В R ряд функций для поиска и замены строк по паттерну имеют две версии - первая обрабатывает только первоей найденное значение, соответствующее паттерну, вторая версия - все найденные по паттерну значения. Например, функция `sub()` находит и заменяет перве вхождение искомого символа, `gsub` - все вхождения:
```{r 05-handling-with-strings-14 }
# задаем строку
my_string <- 'mystring998989'

# удаляем символ 9, первое вхождение
sub('9', "", my_string)

# удаляем все символы `9` с помощью функции gsub() 
gsub('9', "", my_string)
```
Если в паттерне указать несколько символов, то поиск по строке будет произведен именно по такому сочетанию символов. Например, удалим из строки (заменим на пустую строку) сочетание `89`:
```{r 05-handling-with-strings-15 }
# удаляем сочетание символов 89, первое вхождение
sub('89', "", my_string)

# удаляем сочетание символов 89, все вхождения
gsub('89', "", my_string)
```

Следует учитывать, что некоторые символы или сочетания символов могут быть проинтерпретированы либо как управляющие конструкции регулярных выражений (см. #text_metacharacters) и тогда потребуются дополнительные указания, как должны быть обработаны эти символы. Во-вторых, некоторые группы символов могут просто иметь дополнительные фиксированные значения. Так, для кодирования перехода на новую строку, табуляции и некоторых других непечатаемых символов используются определенные обозначения: `\n`, `\r`, `\t`, `\v`, `\f`. Соответственно, если в строке встретится какое-то из этих сочетаний, то строка будет прочитана и обработана не как строка, содержащая символы обратного слеша и буквы, а как строка с спец.символом (в случае с табуляцией - `\t`):
```{r 05-handling-with-strings-16 }
string_with_tab <- 'metachara\tcters'
cat(string_with_tab)

# пробуем удалить из строку букву t
gsub('t', '_DELETED_', string_with_tab)
```
Подобные символы, тем не менее, можно обрабатывать как и все прочие:
```{r 05-handling-with-strings-17 }
gsub('\t', '_DELETED_', string_with_tab)
```

### Классы символов
Задачи на поиск конкретного символа с помощью регулярных выражений встречаются, но, в целом, стоит признать, что обычно треубется большая гибкость поиска. Например, не конкретный символ или сочетание символов, а какой-либо символ из набора - знаки пунктуации или же цифры.

Cамостоятельно указать какой-то набор символов с помощью квадратных скобок (стоит помнить, что квадратные скобки как метасимволы регулярных выражений и квадратные скобки в R - это разные конструкции). При этом можно либо просто перечислить все символы набора, либо, если они принадлежат какому-то известному множеству (например, цифры), то указать первый и последний элементы множества через знак дефиса (`-`). Также можно сочетать сокращенные формы записи наборов символов. Символы кириллического и латинского алфавитов - разные множества, точно также как строчные и прописные буквы.

Внутри классов поведение метасимволов может различаться в зависимости от места их указания в наборе символов класса. Например, `^` первым символов в наборе символов задает логическое отрицание `не из этих символов`, и чтобы избежать такого поведения, знак `^` надо поставить на любое место кроме первого в цепочке. Знак `]`, если есть необходимость его вкючения в набор символов, наоборот, надо ставить первым в наборе, в противном случае он будет проинтерпретирован как завершение класса. Знак `-`, если указан не первым и не последним, интерпретируется как знак интервала в известном диапазоне символов (например, `[0-9]` означает от `0` до `9`, а `[09-]` - символы `0`, `9` и `-`)

```{r 05-handling-with-strings-18 }
# задаем строку
my_string <- 'D9586bNd879мрЯпп'

# укажем, что удалить надо любую из цифр
gsub('[0123456789]', '', my_string)
gsub('[0-9]', '', my_string)

# удаляем цифры, а так же строчные буквы кириллицы и латиницы
gsub('[0-9a-zа-я]', '', my_string)
```

#### Символьные классы в POSIX
Стандарт POSIX 1003.2 поддерживает несколько определенных обозначения для часто испольуземых символьных классов. Эти обозначения формируются по схеме `[[:` + `название класса` + `:]]`:

- `[:alnum:]`: все буквы и цифры, сочетание символьных классов `[:alpha:]` и `[:digit:]`.

- `[:alpha:]`: буквы алфавита в обоих регистрах, для прописных и строчных букв есть отдельные символьные классы: `[:lower:]` и `[:upper:]`.

- `[:punct:]`: знаки пунктуации, ```!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~.```.


- `[:digit:]`: арабские цифры `0123456789`.

- `[:xdigit:]`: цифры в шестнадцатеричном формате, `0123456789ABCDEFabcdef`.

- `[:graph:]`: графические знаки, объединенный класс, состоящий из классов `[:alnum:]` и  `[:punct:]`.

- `[:print:]`: печатаемые знаки, класс `[:graph:]`, дополненный пробелом.

- `[:blank:]`: непечатаемые символы (пробел, знак табуляции, в зависимости от локали - неразрывный пробел и возможные другие непечатаемые символы).

- `[:cntrl:]`: управляющие символы (в таблицах символов ANSCII коды 000-031 и 121 в десятичной, 000-037 и 177 в восьмеричной системе, 000-07F в шестнадцатеричной системах счислений)

- `[:space:]`: некоторые управляющие символы, которые используются для создания разрывов между символами - пробел, переход на новую строку, возврат каретки, перевод страницы и т.д. В зависимости от локали может содержать дополнительные знаки.

#### Дополнительные символьные классы
Помимо обозначений символьных классов, которые поддерживаются стандартом POSIX, также в R реализован ряд собственных символьных классов, которые, как правило, обозначают наиболее часто используемые комбинации:

- `\\d`: цифры, аналогично `[0-9]`

- `\\D`: не цифры, обратно `\\d`, аналогично `[^0-9]`

- `\\w`: символы, которые используются в письме, аналогично `[A-z0-9_]`

- `\\W`: обратный `\\w` набор, символы, которые не используются в письме

- `\\S`: все знаки, кроме пробела. Аналогично `[^[:space:]]` или `[^\\s]`

```{r 05-handling-with-strings-19 }
# задаем строку
my_string <- 'D9586bNd879мрЯпп'

# удаляем все цифры с помощью класса [0-9]
gsub('[0-9]', '', my_string)

# удаляем все цифры с помощью класса [:digit:]
gsub('[[:digit:]]', '', my_string)

# удаляем все цифры с помощью класса \\d
gsub('\\d', '', my_string)
```

### Метасимволы {#text_metacharacters}
Ряд символов имеет дополнительное значение - эти символы используются не только сами по себе, но и как определенные конструкции языка регулярных выражений. В частности, это символ `[`, который используется для создания произвольного символьного класса. Полный список выглядит следующим образом:

 - `.`: подстановочный знак (wildcard), используется в тех случаях, когда необходимо указать, что на этом месте может быть любой знак
 
 - `\`: используется для экранирования метасимволов

 - `|` : логический оператор `или`

 - `(` и `)`: используются для указания групп символов

 - `[`: вместе с `]` используется для указания символьных классов

 - `^`: якорь, указывающий на начало строки, а так же логический оператор отрицания, используемый в символьных классах

 - `$`: якорь, указывающий на конец строки
 
 - `*`, `+` и `?` - квантификаторы, указывающие, что предыдущий символ или группа символов могут или должны повториться некоторое количество раз
 
 - `{`: вместе с `}` исползуется как квантификатор, указывающий конкретное количество повторений предыдущего символа или группы символов
 
 - `<` и `>`: используется в Perl-совместимых регулярных выражениях

Для того, чтобы эти метасимволы воспринимались не как элементы языка регулярных выражений, а как есть, их необходимо экранировать двумя символами `\\`. Необходимость в двух символах `\\` для экранирования возникает из-за того, что строковая запись регулярного выражения в R и собственно выражение на языке регулярных выражений несколько различаются. В частности, интерпретатор R также воспринимает обратный слеш как символ экранирования:

```{r 05-handling-with-strings-20 }
string_with_escapes <- c('\\a', '\\z', '\\')
writeLines(string_with_escapes)
```

Таким образом, если мы хотим удалить из строки символы, которые могут быть проинтерпретированы как управляющие конструкции на языке регулярных выражений, мы должны либо экранировать эти символы двумя обратными слешами `\\`, либо в функции, использующей регулярное выражение, задавать аргумент `fixed = TRUE`):
```{r 05-handling-with-strings-21 }
# пробуем удалить символы .* без экранирования
gsub('.*', '_DELETED_', 'metachara.*cters')

# пробудем удалить с экранированием каждого символа
gsub('\\.\\*', '_DELETED_', 'metachara.*cters')

# используем аргумент fixed = TRUE, чтобы воспринимать паттерн не как регулярное выражение
gsub('.*', '_DELETED_', 'metachara.*cters', fixed = TRUE)

```


### Логические операции
В регулярных выражениях логические операции представлены в достаточно ограниченном виде, можно даже сказать, крайне бедно. Наиболее очевидная из существующих операции - это `ИЛИ`, когда надо задать несколько вариантов комбинаций символов. В частности, это крайне полезный инструмент для фильтрации вектора строковых значений по определенному критерию. Например, регулярными выражениями с логическим оператором можно просто выделить из списка логов те файлы, которые были созданы в 2015-2016 годах:
```{r 05-handling-with-strings-22 }
models <- c('log_2014.csv', 'log_2015.csv', 'log_2016.csv', 'log_2017.csv', 'log_2018.csv')
models[grep('2015|2016', models)]
```
Второй логический оператор - `^`, используется в тех случаях, когда надо исключить символы определенного класса. Следует помнить, что `^` используется в этом значении сугубо внутри `[]`, в противном случае будет интерпретироваться в другом значении.
```{r 05-handling-with-strings-23 }
# заменяем на '_' любой из символов d, e, f
gsub('[def]', '_', 'fadbcdefghe')

# заменяем на '_' все, кроме символов d, e, f
gsub('[^def]', '_', 'fadbcdefghe')
```

### Квантификаторы
Для того, чтобы в паттерне указать, что какой-то символ или группа символов может повторяться, используют специальные управляющие знаки - квантификаторы:

 - `?`: предыдущий символ или группа символов в паттерне может встречаться 0 или 1 раз. Также вместе с другими квантификаторами используется для нежадного поиска.

 - `*`: предыдущий символ или группа символов в паттерне может встречаться 0 или больше раз.

 - `+`: предыдущий символ или группа символов в паттерне может встречаться 1 или больше раз.

 - `{n}`: предыдущий символ или группа символов может встречаться в паттерно строго `n` раз.

 - `{n,}`: предыдущий символ или группа символов может встречаться в паттерно `n` и более раз. Конструкции `{0,}` и `{1,}` тождественны `*` и `+` соответственно.

 - `{n,m}`: предыдущий символ или группа символов может встречаться в паттерно `n` раз, но не более, чем `m` раз. Конструкции `{0,1}` и `?` тождественны.

Простейший пример использования квантификаторов - когда надо обработать какой-то символ, который встречается несколько раз. Например, скрыть последние четыре цифры в номере телефона:
```{r 05-handling-with-strings-24 }
phone_number <- 'my phone number: +7-929-138-5896'
gsub('[0-9]{4}', 'XXXX', phone_number)
```

### Подстановочные знаки
Подстановочные знаки используются в тех ситуациях, когда надо просто указать, что в этом месте может быть любой символ. Несмотря на множественное число (wildcards), в регулярных выражениях в качестве подстановочного знака используется только метасимвол `.`, который обозначает `любой знак`.

Обычно подстановочный знак используется в сочетании с квантификаторами, указывающими, что в этом месте может быть любое количество символов. Например, использование подстановочных знаков может помочь строку, из которой известно только несколько символов. Попробуем из списка строк выбрать только адреса электронной почты в домене ru, исходя из предположения, что требуемые адреса содержат знак `@` и сочетание `.ru`:

```{r 05-handling-with-strings-25 }
emails <- c('myemail@yahoo.com', 'id638@yandex.ru', 'simple string', 'lizzy@mail.ru', 'pumpkinpie@gmail.com')
emails[grep('@.+\\.ru', emails)]
```

### Якори
Якори используются для обозначения, что сочетание символов в паттерне обязательно должно начинать или завершать строку. Также есть якори, которые маркируют начало или конец не строки, а слова, однако само определение слова зависит от используемой локали. В R используются следующие якори:

- `^` и `$`: начало и конец строки соответственно

- `\\<` и `\\>`: начало и конец слова

- `\\b`: пустая строка или края слова

- `\\B`: не край слова

Простым примером может быть выбор и чтение только `xls`-файлов, с игнорированием `xlsx`-файлов или прочих файлов в папке. Так же при импорте файлов MS Office нередко приходится игнорировать еще и временные файлы, которые создаются при работе с файлом MS Office и обычно скрыты от пользователя (их можно отличить по символам `~$` в начале назания файла). Для этого надо указать, что в начале названия строки нет маркеров временных файлов или что название файла начинается с требуемого буквосочетания. Так же надо указать, что файл заканчивается строго на `xls`. Символы в названии, которые находятся между символами, используемыми в начале и конце строки, можно задать с помощью подстановочного знака и квантификатора (`.*`):
```{r 05-handling-with-strings-26 }
files <- c('report_2018.xlsx', 'report2017.xlsx', '~$report2016.xls', 'report2016.xls', 'report2015.xls', 'report2015.doc')

# пробуем извлечь xls-файлы c указанием якорей:
files[grep('^report.*xls$', files)]
files[grep('^[^~$].*xls$', files)]
```

### Группы
Квантификаторы обычно работают относительно предыдущего указанного символа. Однако нередко возникают ситуации, когда требуется провести какую-то операцию над определенной группой символов. В таких случаях используют знаки группировки - `(` и `)`. Набор символов и/или выражение, заключенные в скобки, будут восприниматься как неразрывная последовательность символов, и обрабатываться соответствующим образом. 
Например, если мы хотим удалить из строки строго двукратное повторение группы символов:
```{r 05-handling-with-strings-27 }
my_string <- c('abRababL')

# пробуем удалить пару символов без указания группы
gsub('ab', '_DELETED_', my_string)

# группируем символы с помощью ()
gsub('(ab){2}', '_DELETED_', my_string)
```


При необходимости всю обрабатываемую строку можно, с помощью символьных классов, групп и прочих инструментов регулярных выражений, представить в паттерне. При подобном представлении группы нумеруются и может быть обработана конкретная группа символов, вызванная по номеру. Номера групп обозначаются как `\\1`-`\\9`.

Например, в строке есть как текст, так и номер телефона, и мы хотим извлечь все, кроме текста и кода страны. Для этого мы пишем паттерн, который описывает всю строку, и необходимые нам части строки представляем в виде групп. Далее с помощью `gsub()` мы изменяем исходную строку так, что в ней остаются только требуемые нам группы из кодирующих телефонный номер:
```{r 05-handling-with-strings-28 }
phone_number <- 'my phone number: +7-929-138-58-96'
phone_number <- 'my phone number: +7-929-1385896'

phone_pattern <- '.+(\\+[0-9]*)-?([0-9]{3})-?([0-9]{3})-?([0-9]{2})-?([0-9]{2})'
gsub(phone_pattern, '\\2-\\3-\\4\\5', phone_number)
```

В примере выше конструкция `.+` обозначает все возможные символы до группы `(\\+[0-9]*)`, которая, в свою очередь, обозначает численный код страны. Код страны может сстоять как из одной цифры, так и из нескольких. Конструкция `-?` нужна для того, чтобы учесть ситуации, когда номер телефона записывается с разделителями, расставленными в произвольном порядке (`+7-929-138-5896` vs `+79291385896` vs `+7-929-138-58-96` и т.д.). Группы `([0-9]{3})`, `([0-9]{2})` обозначают, собственно, сколько раз должны повторяться цифры в этой группе символов.

В результате в паттерне оказывается представлена вся строка, а элементы номера телефона представлены в виде пяти групп. Функция `sub()` находит в строке совпадение с паттерном и замещает строку на набор групп, `\\2-\\3-\\4\\5`, притом, четвертая и пятая группы сознательно не разделены знаком `-`, чтобы в результате последние четыре цифры номера были целостным блоком. Так как паттерн кодирует всю строку, то, в результате мы получаем только те части строки, которые описываются группами. В нашем случае это номер телефона без указания кода страны.

### Perl-синтаксис


