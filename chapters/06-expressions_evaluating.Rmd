---
title: "Выполнение выражений"
author: "Ph.A.Upravitelev"
date: '`r Sys.Date()`'
editor_options: 
  chunk_output_type: console
output: 
  html_document:
    toc: true  
---
# Выполнение выражений
## Структура и парсинг выражений

### Выражения

Выражение, в самом общем виде - символьная запись действия, которое должно быть выполнено. Термин `выражение` может несколько сбивать с толку, так как в R есть выражения как запись кода, а есть отдельный тип объектов, `expression`. В английском языке первому значению также может соответствовать еще и термин `statement`. 

Следует различать выражение и результат его выполнения. Так, в примере ниже `x <- 5` и `x ^ 2` - это выражения, а `25` - результат выполнения этих двух выражений, выведенный на печать с помощью функции `print()`:
```{r 06-expressions-evaluating-1}
x <- 5
print(x ^ 2)
```

В R выражения представлены в виде четырех форм: 

- имена (names). При создании объекта, например, `x <- 5` происходит связывание значения `5` и имени `x`. Соответственно, далее можно обращаться в объекту со значением `5` по имени `x`, поэтому имена могут быть интерпретированы как выполняемые выражения. Например, если сделать `print(x)`, то на печать будет выведен результат выполнения обращения к объекту по его имени:
```{r 06-expressions-evaluating-2}
print(x)
```

- константы. В R все единичные значения являются векторами длиной 1, соответственно, константы - это векторы, которые не имеют имени. При выполнении выражения-константы возвращают себя же (`print()` выводит на печать результат выполнения выражения):
```{r 06-expressions-evaluating-3}
print('this is constant value')
```

- вызовы функций (call). Этот форма выражения отражает процедуру вызова функции - ее название и аргументы. Этот невыполненный вызов функции можно получить с помощью функции `call()`, а также при парсинге R-скриптов. 
```{r 06-expressions-evaluating-4}
# создаем выражение округления значения
e_call <- call('round', 10.5)

# выражение не выполняется, есть только запись
print(e_call)
```

Также результат выполнения многих функций может содержать отдельным элементом запись вызова функции. Это можно увидеть на примере результата функции `lm()`:
```{r 06-expressions-evaluating-5}
# создаем lm-модель
x <- rnorm(100)
y <- 5 * x
lm_fit <- lm(y ~ x)

# смотрим вызов в подсписках
lm_fit$call
```

- списки аргументов функций (pairlists). `pairlists` - старая форма списков, унаследованная от S. В R эта форма встречается только в аргументах функций, во всех остальных местах замещены обычными списками, `lists`. Списки аргументов, `pairlists`, имеют вид `имя_аргумента = значение`. 

### Захват выражений: quote() и substitute()

Для захвата выражения можно использовать несколько близких функций - `quote()`, `bquote()` и `substitute()`. Первая, `quote()` очень простая, фактически, позволяет переданное в аргумент выражение выделить в отдельный объект. 

```{r 06-expressions-evaluating-6}
x_q <- quote(hp > 250)
print(x_q)
```

Функция `bquote()` немного дополняет `quote()` и позволяет в выражении использовать другие объекты, а также указывать окружение:
```{r 06-expressions-evaluating-7}
y <- 250
x_bq <- bquote(hp > .(y))
print(x_bq)
```

Как правило, рекомендуется использовать функцию подстановки `substitute()`. В зависимости от того, в каком окружении она вызывается, может быть разный результат. Так, при вызове в глобальном окружении результат `substitute()` идентичен `quote()`:

```{r 06-expressions-evaluating-8}
x_sbst <- substitute(hp > 250) 
identical(x_q, x_sbst)
```

Обычно `substitute()` используется в различных функциях, например для создания названий переменных или осей в функциях `data.frame()` или `plot()`. При вызове в функции `substitute()` возвращает результат парсинга переданного выражения, с подстановкой всех связанных переменных. Проще всего это увидеть вот в такой функции:

```{r 06-expressions-evaluating-9}
my_f <- function(x_arg) {
  mult <- 5
  list(
    quote = quote(x_arg * mult), 
    substitute = substitute(x_arg * mult), 
    origin = x_arg * mult)
}
    
new_x <- 100
my_f(x_arg = new_x)
```

Как мы видим, `quote()` возвращает ровно то, что было передано в аргументы, выражение `x_arg * mult`. Аналогично ожидаем результат `x_arg * mult` - переданное в аргумент `x_arg` умножается на константу `mult`. При этом функция `substitute()` возвращает результат парсинга заданного выражения и подстановки тех значений переменных, само же выражение не выполняется.

При желании, можно выполнить результат `substitute()` и сравнить с простым вычислением:
```{r 06-expressions-evaluating-10}
my_f <- function(x_arg) {
  mult <- 5
  identical(
    x_arg * mult,
    eval(substitute(x_arg * mult))
  )
}
    
new_x <- 100
my_f(x_arg = new_x)
```


### Абстрактное семантическое дерево
Код на R, который пользователь пишет в любой IDE или командной строке - это, так или иначе, символьная запись выражений. Для того, чтобы выполнить выражения, интерпретатор должен сначала их распарсить, т.е. разобрать на иерархию взаимосвязей действий и объектов. Подобная иерархия называется абстрактным синтаксическим деревом (АСД, AST), хотя корректнее, конечно же, было бы переводить этот термин как дерево абстрактного синтаксиса. В R построить AST выражения можно с помощью функции `ast()` пакета `pryr` - подобное представление бывает полезно для иллюстрации логики действия некоторых сложных выражений или конструкций языка. 

Например, вычисление среднего по выборке десяти случайных значений из ряда от 1 до 100. Значения, которые начинаются с "\`" - это имена (names) объектов.
```{r 06-expressions-evaluating-11, message=FALSE}
pryr::ast(mean(sample(100, 10)))
```

Такое дерево само по себе демонстрирует некоторые особенности языка R - узлами выступают скобки `()` (выражения вызова функции), а переменные и функции - листями. Это достаточно важный нюанс, так как иллюстрирует унаследованную от Lisp концепцию кода как данных, когда элементы языка являются такими же объектами, как и, например, таблицы. Наиболее важно это для нестандартного выполнения выражений, о котором пойдет речь ниже. Меж тем, родство с Lisp можно проследить и просто в представлении дерева: `(mean (sample 100 10))`.

Вот так в синтаксическом дереве выглядят почти все типы выражений, которые существуют в R, за исключением вызовов функций. С константами и именами все прозрачно, а вот `[]` представляет интерес - это как раз `pairlists`:
```{r 06-expressions-evaluating-12}
pryr::ast(function(x = 3, y = x * 2) x + y)
```

Более понятную, но чуть менее иллюстрирующую особенности языка визуализацию дерева выражения можно получить с помощью функции `lobstr::ast()`

```{r 06-expressions-evaluating-13}
lobstr::ast(mean(sample(100, 10)))
```


### Парсинг выражений из строки: parse()

В R различают три основные модели парсинга строковых записей выражений: 

- read-eval-print loop (REPL): работа в интерфейсе командной строки, когда вся работа построена в виде последовательности действий "ввод команды - выполнение - результат". В этой модели выражение пользователь пишет в командной строке, это выражение парсится интерпретатором и выполняется. Результат выполнения пользователь видит сразу же в консоли.
 
- парсинг текстовых файлов (файлов скриптов): чтение и выполнение файлов скриптов. Обычно для этого используется комбинация `eval(parse(file = 'script.R'))` или ее более привычная и усложненная форма, `source()`.

- парсинг строковой записи выражения: превращение записи вида `'x <- 5'` в объект с классом `expression()`. Для этого также используется функция `parse()`, только символьная (строковая) запись передается в аргумент `text`. Например, `parse(text = 'x <- 5')`.

Если файл содержит несколько выражений, то функция `parse()` вернет их в виде списка выражений, аналогично с парсингом строкового представления:
```{r 06-expressions-evaluating-14}
expr_parsed <- parse(text = 'x <- 5; y <- 3')
length(expr_parsed)
expr_parsed[[1]]
```

В некоторых случаях (как правило, в NSE) необходимо выражение превратить в строковую запись. Для этого используется функция `deparse()`:

```{r 06-expressions-evaluating-15}
# парсим строковую запись
z_parsed <- parse(text = 'x <- 5')
class(z_parsed)
```

```{r 06-expressions-evaluating-16}
# обратная операция
z_deparsed <- deparse(z_parsed)
class(z_deparsed)
```

### Выполнение захваченных выражений

Выражения, которые были звахвачены с помощью функций `quote()` / `substitute()` или распарсены из строки, можно выполнить с помощью функции `eval()`:

```{r 06-expressions-evaluating-17}
# создаем объект с выражением
e_q <- quote(new_val <- 5)

# проверяем, что объекта нет в рабочем окружении
'new_val' %in% ls()

# выполняем
eval(e_q)

# смотрим результат
print(new_val)
```

Аналогично с результатом функции `parse()`:
```{r 06-expressions-evaluating-18}
# создаем объект с выражением
e_p <- parse(text = 'new_val2 <- 19')

# проверяем, что объекта нет в рабочем окружении
'new_val2' %in% ls()

# выполняем
eval(e_p)

# смотрим результат
print(new_val2)
```

Очень часто при использовании функции `eval()` используется дополнительный аргумент, задающий окружение. Это позволяет выражения, созданные в каком-то одном окружении, выполнять в другом. Как правило это используется при написании функций или при нестандартном выполнении выражений.
```{r 06-expressions-evaluating-19}
# создаем окружение и объект выражения в нем
my_env <- new.env()
my_env$exp_in_env <- quote(new_val_env <- 'expr from new eval')

# проверяем, что нет выражения в окружениях
'new_val_env' %in% ls(envir = .GlobalEnv)
'new_val_env' %in% ls(envir = my_env)

# выполняем выражение в глобальном окружении
eval(my_env$exp_in_env, envir = .GlobalEnv)

# смотрим результат
new_val_env
```


## Выполнение функций
### Promises, обещания
Выполнение функций в R ощутимым образом отличается от подобного процесса в других языках программирования. Утрированным примером будет следующая конструкция:
```{r 06-expressions-evaluating-20 }
my_fun <- function(x, y, z = x * 2) {
  z ^ 2
}

my_fun(2 + 3, stop('stop message'))
```

Тут можно увидеть сразу несколько характерных аспектов `my_fun()`:

- при объявлении функции указывается три аргумента, однако функция выполняется, даже если передано только два аргумента

- в аргумент `z` передается не какой-то объект из глобального окружения, но результат операции над аргументом `x`

- вычисление аргумента `x` происходит, однако выражение `stop('stop message')` не выполняется


Подобное поведение возможно за счет того, что в R называется `promises`, обещания. Это достаточно неудачный термин, так как обещания в R при выполнении функций никаким образом не связаны с асинхронными или отложенными вычислениями. В определенной мере это можно объяснить тем, что в R они появились намного раньше чем асинхронные вычисления, но, тем не менее, в настоящий момент это порождает путаницу. 

Обещание в R - это выражение с собственным связанным окружением, которое создается из аргумента функции при ее вызове, для каждого аргумента свое обещание. Как правило, этот процесс скрыт и пользователи R не имеют прямого доступа к обещаниям. Тем не менее, можно воспользоваться функцией `promise_info()` пакета `pryr` и посмотреть структуру обещания:
```{r 06-expressions-evaluating-21 }
val <- 4
my_fun <- function(x)
  str(pryr::promise_info(x))
my_fun(val + 3)
```

Как мы видим, обещание состоит из нескольких элементов: 

- `code`, текст переданного в аргумент `x` выражения (`val + 3`)

- `env`, указатель окружения, в котором вызывается функция (`<environment: R_GlobalEnv>`), 

- `evaled`, метка, выполнено ли какое-нибудь действие с аргументом `x` (`FALSE`)

- `value`, результ действия с аргументом (`NULL`)

До тех пор, пока с аргументом нет никаких операций, аргумент присутствует только в виде выражения, как "обещание" вызова связанного с ним значения. Как только происходит вызов аргумента, элементы обещания меняются - уже нет необходимости хранить указатель окружения, в котором выполняется выражение аргумента, появляется результат выполнения выражения и значение аргумента, метка `evaled` меняется на `TRUE`:

```{r 06-expressions-evaluating-22 }
my_fun <- function(x) {
  cat("До действия с аргументом:\n")
  str(pryr::promise_info(x))
  
  # Вычисление в функции
  res <- x * 2
  
  cat("\nПосле действия с аргументом:\n")
  str(pryr::promise_info(x))
  
  cat("\nРезультат функции:\n")
  res
}
my_fun(val + 3)
```

При вызове функции сначала для аргумента функции создается обещание. Потом, когда необходимо сделать какое-то действие с аргументом (вычисление `res`), выполняется выражение, переданное в качестве аргумента (`code`). То есть, обещание выполняется и аргумент получает значение, в нашем случае это `val + 3 = 7`. В качестве результата функция возвращает вычисленное на основе значения аргумента `x` значение `res`. В целом, подобное выполнение выражений, когда объект вычисляется только в тот момент, когда он вызывается, относят к ленивым выполнениям выражений, lazy evaluations.

Если возвращаться к примеру, с которого мы начали рассмотрение обещаний, то при вызове функции `my_func()` происходит создание трех обещаний, для каждого из аргументов `x`, `y`, и `z`:

```{r 06-expressions-evaluating-23 }
my_fun <- function(x, y, z = x * 2) {
  cat('Окружение функции: \n')
  print(environment())
  cat('Обещание аргумента x, до выполнения: \n')
  str(pryr::promise_info(x))
  cat('Обещание аргумента y, до выполнения: \n')
  str(pryr::promise_info(y))
  cat('Обещание аргумента z, до выполнения: \n')
  str(pryr::promise_info(z))
  
  res <- z ^ 2
  
  cat('Обещание аргумента x, после выполнения: \n')
  str(pryr::promise_info(x))
  cat('Обещание аргумента z, после выполнения: \n')  
  str(pryr::promise_info(z))

  cat('Результат функции: \n')  
  res
}

my_fun(2 + 3, stop('stop message'))
```

Тут важно отметить, что обещание аргумента `z` выполняется в рабочем окружении функции. То есть, когда происходит выполнение выражения `z ^ 2`, сначала выполняется обещание аргумента `x`, так как `z` вычисляется из `x`. Соответственно, `z` получает значение и вычисляется уже результат действия с `z`, объект `res`. При этом аргумент `y` нигде не используется и не вызывается, поэтому выражение `stop('stop message')` так и остается в виде обещания и не выполняется.

### Рекурсии

В R можно использовать рекурсивное выполнение функций - когда в теле функции вызывается эта же функция. Традиционно рекурсии иллюстрируют рядом Фибоначчи, когда каждый последующий член ряда является суммой двух предыдущих или же вычислением факториала числа. 

Рекурсивная функция вычисления факториала (в общем виде `n! = n * (n - 1)!`) выглядит следующим образом:
```{r 06-expressions-evaluating-24}
# объявляем функцию
factorial_rec <- function(x) {
  if (x <= 1) {
    return(1)
  } else {
    return(x * factorial_rec(x - 1))
  }
}

# считаем 5!
factorial_rec(5)
```

Рекурсии ограничены доступной памятью и, в какой-то мере, количеством итераций, так как при увеличении вложенности растет и объем занимаемой памяти. Это можно увидеть, если попробовать посчитать факториал, например, 1000:
```{r 06-expressions-evaluating-25, eval = FALSE}
factorial_rec(1000)
```

```{r 06-expressions-evaluating-26, engine="Rscript", echo=FALSE, error=TRUE}
factorial_rec <- function(x) {
  if (x <= 1) {
    return(1)
  } else {
    return(x * factorial_rec(x - 1))
  }
}
factorial_rec(1000)
```


Переписать рекурсивную функцию с функцию с использованием хвостовой рекурсии (tail recursion) в R можно, однако базовый R не предполагает ее оптимизацию:
```{r 06-expressions-evaluating-27, error=TRUE, engine="Rscript"}
factorial_rec_tail <- function(n, acc = 1) {
    if (n <= 1) acc
    else factorial_rec_tail(n - 1, acc * n)
}
factorial_rec_tail(1000)
```

Поэтому самый простов способ оптимизировать рекурсивную функцию - это переписать ее в виде цикла (`Inf` для n = 1000 возникает из-за того, что слишком большое для отображения число, принципиальных проблем для вычисления нет):
```{r 06-expressions-evaluating-28}
factorial_loop <- function(n) {
    res <- 1
    while (n > 1) {
        res <- n * res
        n <- n - 1
    }
    res
}
factorial_loop(5)
factorial_loop(1000)
```

<!-- Более хитрым (и, должен сказать, никогда не встречавшимся мне в практике) методоми решения рекурсий является механизм трамплина (trampoline). -->

<!-- ```{r} -->
<!-- trampoline <- function(f, ...) { -->
<!--   function(...) { -->
<!--     ret <- f(...) -->
<!--     while (inherits(ret, "recursion")) { -->
<!--       ret <- eval(as.call(c(f, unclass(ret)))) -->
<!--     } -->
<!--     ret -->
<!--   } -->
<!-- } -->
<!-- recur <- function(...) { -->
<!--   structure(list(...), class = "recursion") -->
<!-- } -->
<!-- factorial_tr <- trampoline(function(n, prod = 1) { -->
<!--   if (n == 0) prod else recur(n-1, n*prod) -->
<!-- }) -->
<!-- factorial_tr(5) -->
<!-- factorial_tr(1000) -->
<!-- ``` -->




### Частичное выполнение

Частичное выполнение функций - один из вариантов применения замыканий. При частичном выполнении функции часть аргументов используется, а часть может быть передана позже, в другом выражении. Это необходимо в тех ситуациях, когда хочется, например, сократить количество используемых аргументов. 
Пример частичного выполнения функции:

```{r 06-expressions-evaluating-29}
# создаем функцию, которая частично выполняет указанную функцию
partial <- function(f, ...) {
  arglist <- list(...)
  function(...) {
    do.call(f, c(arglist, list(...)))
  }
}

# создаем функцию, к которой хотим применить частичное выполнение.
my_fun <- function(x, y, z) x + y + z

# создаем функцию, которая является частичным выполнением заданной
my_fun_pt <- partial(my_fun, x = 1, y = 2)
class(my_fun_pt)

# применяем функцию, в которой часть аргументов уже выполнена
my_fun_pt(z = 3)
```


### Каррирование
Каррирование - преобразование функций нескольких аргументов в последовательность функций с одним аргументом, например, `f(x, y)` в `f(x)(y)`. Каррирование использует механизм замыканий и, по сути, является расширением идеи частичного выполнения функции. Частичное выполнение предполагает возможность использования нескольких аргументов и создание функций с меньшим числом аргументов, в то время как каррирование - цепочка вызовов функций одного аргумента


```{r 06-expressions-evaluating-30}
# классическая функция
my_fun <- function(x, y, z) x + y + z

# каррируем функцию
my_fun_cr <- function(x) function(y) function(z) x + y + z

# применяем каррированную функцию
my_fun_cr(1)(2)(3)
```

Если каррированную функцию выполнить лишь с частью аргументов, то в результате получится функция меньшего количества аргументов. То есть, получится частичное выполнение. В примере ниже аргумент `z` не задан, в результате выполнения `my_fun_cr()` будет также функция. Здесь, что очевидно, важен порядок обработки аргументов в каррированной функции:
```{r 06-expressions-evaluating-31}
# выполняем только часть аргументов
my_fun_pt2 <- my_fun_cr(1)(2)
class(my_fun_pt2)

# выполняем
my_fun_pt2(z = 3)
```


## Области видимости и окружения
Область видимости и окружение  - очень близкие сущности, которые в ряде случаев легко легко спутать. Окружение - множество соотнесений (отображений, mapping) имен объектов и их значений. Например, если в глобальном окружении выполнить выражение `x <- 5`, то `x` будет именем объекта, а `5` - значением. Функция `pryr::where()` возвращает название окружения, в котором создан объект с именем `x` и значением `5`:
```{r 06-expressions-evaluating-32 }
x <- 5
pryr::where('x')
```

Аналогично, если создать новое окружение и в нем создать объект с именем `x` и значением `5` (другими словами, объект `new_x` со значением `5`):
```{r 06-expressions-evaluating-33 }
myenv <- new.env()
myenv$new_x <- 5
ls(myenv)
pryr::where('new_x', env = myenv)
```

Область видимости - соотнесение названия объекта и какого-то конкретного объекта, вызываемого в определенной части кода (как правило, в функции). Лучше всего это можно увидеть в следующем примере:
```{r 06-expressions-evaluating-34 }
x <- 1:5
myfunc <- function(x)  {
  y <- sum(x)
  sqrt(y)
}
myfunc(x = x * 2)
```

Здесь мы видим `x` как объект в глобальном окружении и `x` как название аргумента функции `myfunc()`. Область видимости функции `myfunc()` - тело функции (выражения, заключенные в `{}`, вычисление суммы и квадратного корня). В этих выражениях `x` соотносится не с объектом `x` в глобальном окружении, а с переданным значением в аргумент `x` функции `myfunc()`. Объекты, созданные в локальной области видимости, недоступны в родительских окружениях, поэтому объект `y` отсутствует в глобальном окружении:
```{r 06-expressions-evaluating-35 }
exists('x')
exists('y')
```

Для объекта `x` область видимости и окружение совпадают.

### Лексическая область видимости
Использование локальных объектов, т.е. имеющих ограниченную область видимости и существующих лишь внутри определенной функции, помогает избежать конфликта имен между двумя объектами с одинаковыми именами. В R используется лексическая область видимости, когда имя объекта определяется и имеет значение внутри тела функции, видимость задается исключительно кодом.

<!-- Functions, like all objects, are housed inside environments. However, functions themselves have a property which is a pointer to the environment in which they should run. When you create a function, that property is automatically set to the environment in which the function was created. So the environment that houses a function and the environment that the function will run in is one and the same. -->

Для лексической области видимости характерно правило поиска объекта в родительских окружениях, по восходящей. Например, в функции `my_func()` используется объект `x`, который создается и существует в родительском окружении:
```{r 06-expressions-evaluating-36 }
x <- 9
myfunc <- function() sqrt(x)
myfunc()
```

```{r 06-expressions-evaluating-37, echo=FALSE}
rm(x, myfunc)
```

В момент выполнения `myfunc()` интерпретатор не находит объект `x` в локальной области видимости функции, и обращается к родительскому окружению (в данном случае к глобальному). Можно усложнить пример и увеличить уровень вложенности:
```{r 06-expressions-evaluating-38 }
x <- 5
y <- 2

myfunc1 <- function(x) {
  cat('in myfunc1_l x = ', x, '\n')
  x <- x + 5
  myfunc2 <- function(y) {
    cat('in myfunc2_l x = ', x, '\n')
    y <- y + 2
    x + y
  }
  res <- myfunc2(y)
  cat('result of myfunc1 = ', res, '\n')
}

myfunc1(x)
```

```{r 06-expressions-evaluating-39, echo=FALSE}
rm(x, y, myfunc1)
```


При этом важно обращать внимание, на то, где и как объявляется и вызывается функция, так как это прямо влияет на лексические области видимости. Так, в примере выше функция `myfunc2()` объявляется внутри функции `myfunc1()`, соответственно, и поиск объекта `x` происходит сначала в родительском окружении для этой функции (окружении функции `myfunc1()`). Если же функцию `myfunc2()` объявить отдельно в глобальном окружении, то объект `x` будет взят именно из глобального окружения, несмотря на то, что при выполнении функции `myfunc1()` он изменяется:

```{r 06-expressions-evaluating-40 }
x <- 5
y <- 2

myfunc2 <- function(y) {
  cat('x in myfunc2 = ', x, '\n')
  y <- y + 2
  x + y
}

myfunc1 <- function(x) {
  x <- x + 5
  cat('x in myfunc1 = ', x, '\n')
  res <- myfunc2(y)
  cat('resut of myfunc1 = ', res, '\n')
}

myfunc1(x)
```

```{r 06-expressions-evaluating-41, echo=FALSE}
rm(x, y, myfunc1, myfunc2)
```

Можно сделать еще нагляднее, выведя на печать названия использованных окружений:

```{r 06-expressions-evaluating-42 }
x <- 5
y <- 2

myfunc1 <- function(x) {
  print(parent.frame())
  print(environment())
  x <- x + 5
  cat('x in myfunc1 = ', x, '\n')
  print(environment(myfunc2))
  myfunc2(y)
}

myfunc2 <- function(y) {
  print(parent.frame())
  print(environment())
  cat('x in myfunc2 = ', x, '\n')
  y <- y + 2
  x + y
}
myfunc1(x)
```

```{r 06-expressions-evaluating-43, echo=FALSE}
rm(x, y, myfunc1, myfunc2)
```


### Динамическая область видимости
Наряду с лексическим связыванием в R можно встретить и реализацию динамического связывания. При динамическом связывании учитывается окружение, в котором вызывается функция. В принципе, любой вызов функции в глобальном окружении одновременно является примером как лексического, так и динамического связывания имени объекта и собственно объекта. С некоторой натяжкой можно назвать примером динамического связывания ситуацию, когда произвольно указывается, из какого окружения берется объект. Так, в примере ниже, если не указывается никакое окружение, используется лексическое связывание и объект `y` берется из родительского (в данном случае глобального) окружения. В противном же случае объект `y` используется из созданного отдельного окружения `new_env`:

```{r 06-expressions-evaluating-44 }
x <- 5
y <- 2
new_env <- new.env()
new_env$y <- 7

myfunc <- function(env = NULL) {
  if (!is.null(env)) 
    y <- get("y", envir = env)
  x + y
}
  
myfunc()
myfunc(env = new_env)
```

```{r 06-expressions-evaluating-45, echo=FALSE}
rm(x, y, myfunc, new_env)
```

### Окружения функций

В окружениях, в которых создаются или вызываются функции, достаточно легко можно запутаться. Контролировать, что это за окружения и как они взаимосвязаны, полезно для общего понимания процесса поиска объектов при выполнении кода - где интерпретатор ищет упомянутый в коде объект в первую очередь, и где потом. В целом, можно выделить четыре типа окружений функций:

 - связанное окружение (binding environment): окружение, в котором была объявлена функция (в котором есть объект с таким именем). Определить связанное окружение можно с помощью функции `find()`:
```{r 06-expressions-evaluating-46}
# создаем функцию с именем f_genv в глобальном окружении
f_genv <- function() print('binding in global env')
f_genv()

# смотрим, в каком окружении находится имя f_genv
find('f_genv')
```
 
 - родительское окружение (enclosing environment): окружение, в котором была объявлена функция. В большинстве случаев совпадает с связанным окружением, но необязательно. Для пользовательских функций родительское окружение можно изменить, однако для функций, которые находятся в пакетах, неизменяемым родительским окружением будут пространства имен пакетов. Родительское окружение функции можно определить с помощью `environment()`.
 
```{r 06-expressions-evaluating-47}
# создаем под названием my_sd копию функуции sd пакета stats
my_sd <- sd
find('my_sd')

# смотрим, в каком окружении определена функция sd, которую мы используем под названием my_sd
environment(my_sd)


my_env <- new.env(parent = .GlobalEnv)
f_env <- function() print('function in my_env')
environment(f_env) <- my_env

find('f_env')
environment(f_env)

f_env_global <- f_env
find('f_env_global')
environment(f_env_global)
```
 
 - локальное окружение (local environment), оно же локальная область видимости функции: окружение, в котором выполняются выражения функции. 
```{r 06-expressions-evaluating-48}
# создаем простую функцию с парой выражений
f_local <- function() {
  x <- sample(10, 1)
  y <- x  * 5
  
  # выводим на печать объекты из локальной области видимости функции
  print(ls())
}

f_local()
```

 - окружение вызова (parent frame): окружение, в котором вызывается функция. Окружение вызова можно определить или указать с помощью функции `parent.frame()`.
```{r 06-expressions-evaluating-49}
f_nested <- function() function() print(parent.frame())
f_nested()
```

### Окружения пакетов и пространство имен

R представляет собой конгломерат пакетов, сами пакеты представляют собой все те же коллекции объектов, то есть, окружения. Если быть точным, то каждый пакет - это несколько окружений, которые по определенной логике загружаются при загрузке пакета. Окружения пакетов можно разделить на несколько видов:

- package environment: окружение пакета - те функции и объекты, которые автор пакета сделал видимыми для пользователя. Их можно найти в документации по пакету. Просмотреть все объекты этого окружения можно с помощью стандартной функции `ls()`, указав пакет, например, `ls('package:readxl')`. Объекты пакета становятся доступны в глобальном окружении либо при загрузке пакета, либо с помощью оператора `::`, например, `readxl::read_excel()`, где `readxl` - название пакета.

- package namespace: пространство имен пакета - все функции и объекты, которые входят в пакет. Это окружение отличается от предыдущего тем, что в нем есть объекты, скрытые от пользователя. Эти объекты необходимы для работы других (в том числе и видимых пользователю) функций, то есть, это "технические" объекты. Например, функции `read_xls()`, `read_xlsx()` и `read_excel()` пакета `readxl` используют одну и ту же функцию внутреннюю `read_excel_()`. Напрямую обратиться к этим объектам можно только через оператор `:::`, например, `readxl:::read_excel_()`. Получить полный список объектов из пространства имен пакета можно с помощью конструкции вида `ls(getNamespace('readxl), all.names = TRUE)`. Однако наилучший способ, по рекомендации Дирка Эдельбюттеля - посмотреть исходный код пакета.

- package imports: те объекты, которые пакет импортирует и использует из других пакетов. Посмотреть, какие пакеты необходимы для работы, например, пакета `readxl`, можно таким образом: `packageDescription('readxl')$Imports`.

Справедливости ради, окружение пакета и пространство имен пакета - это не два разных набора одних и тех же функций, а два разных набора указателей на одну и ту же функцию (или другой объект пакета). Это возможно в тех ситуациях, когда разные окружения используют одну и ту же функцию и полезно при контроле, каким образом вызывается функция и к каким другим объектам она имеет доступ по правилам связывания.


### Иерархия окружений

При старте сессии последовательно загружаются базовые окружения и окружения пакетов, тем самым образуя иерархию окружений. Самым первым загружается пустое окружение (empty environment, R_EmptyEnv), далее - окружения пакета `base` и прочие. Всю цепочку загруженных окружений можно увидеть с помощью `search()`, однако информативнее иерархию окружений объекта строить помощью функции `parent.env()` и ее вызова в цикле (набор подключенных пакетов может отличаться, в зависимости от сессии и настроек):

```{r 06-expressions-evaluating-50, echo = FALSE}
# выгружаем все пакеты
pkgs <- sessionInfo()$otherPkgs
if (length(pkgs) > 0)
  invisible(
    lapply(
      paste('package:', names(pkgs), sep = ''),
      detach,
      character.only = TRUE,
      unload = TRUE
    )
  )
```

```{r 06-expressions-evaluating-51}
mf <- function(x)
  repeat {
    x_name <- environmentName(x)
    cat(x_name, '\n')
    if (identical(x, emptyenv())) 
      break
    x <- parent.env(x)
  }
mf(.GlobalEnv)
```


### Поиск объектов в окружениях
Поиск объектов при вызове функций - наверное, одна из самых сложных вещей в конструкции R. В изолированных случаях проблем особых нет - в подавляющем большинстве используется лексическое связывание. То есть, если в области видимости функции используется объект, который не был там создан и не является аргументом, то объект ищется в родительском окружении и далее по уровням вложенности. Это простая схема усложняется, когда вызываются не пользовательские функции, а функции пакетов - пакеты мало того, что могут подключаться в разном порядке, так еще и некоторые пакеты имеют совпадающие по именам функции (например, `lubridate::month()` и `data.table::month()`). Дополнительные сложности возникают в ситуации, когда функция использует функцию другого пакета, который не был явно подключен пользователем.

Для того, чтобы контролировать иерархию и взаимосвязи окружений, используется следующая логика. При подключении пакета последовательно подключаются окружение пакета, пространство имен пакета, окружение импортированных из других пакетов объектов. И, самый важный момент, обновляется окружение `environment: namespace:base`.

Окружение `namespace: base` - то, где функция подключенного пакета считается как объявленная, то есть, где функция ищет объекты, которые упоминаются в области видимости функции. Таким образом обеспечивается лексическое связывание для функций, которые объявляются в пакетах. В противном случае могла бы возникнуть путаница при одноименных функциях из разных пакетов.
  
Если попробовать посмотреть родительские окружения какой-нибудь из функций, например, `sd()`, доступных после старта сессии, то мы как раз увидим это усложнение иерархии окружений - помимо `R_GlobalEnv` до него будут еще дополнительные окружения (в частности, `environment: namespace:stats` и `environment: namespace:base`):

Функция `sd` находится в пакете stats, выше по иерархии - окружение функций пространство всех имен пакета stats и окружение импортированных объектов из других пакетов, еще выше - `namespace:base`. При этом родительским окружением для `namespace:base` будет глобальное окружение. Таким образом при вызове функции `sd` она обращается к функциям пакета `stats` (всего пространства имен), например, к функции `var`. А пространство имен `environment: namespace:base` - это окружение, в котором функция `sd` считается объявленной.

```{r 06-expressions-evaluating-52}
# повторяем функцию вывода родительских окружений,
# только помимо имен выводим еще и полные адрес окружения в памяти
mf <- function(x)
  repeat {
    attr(x, 'path') <- NULL
    print(x)
    if (identical(x, emptyenv())) 
      break
    x <- parent.env(x)
  }
mf(environment(sd))
```


## Циклы
Наряду с условными операторами, циклы в R аналогичны циклам в других языках программирования. Три основных вида - `for`, `while` и `repeat`. Циклы задаются с помощью оператора цикла, последовательности или условия, ограничивающих работу цикла и, собственно, выполняемого выражения. Если это одна строка, то выражение можно не заключать в фигурные скобки, во всех прочих случаях фигурные скобки необходимы.

Классические циклы традиционно редко используются в R, в немалой части это вызвано спецификой использования памяти во время выполнения выражений в цикле. Если быть точнее, то не очень эффективным кодом циклов, который обычно пишут начинающие изучать язык. Для классических циклов существуют альтернативы - векторизованные вычисления и неявные циклы, а так же, собственно оптимизация кода путем преаллокации памяти или параллелизации.

### for
Цикл `for`, который встречается чаще прочих, использует заданную последовательность, по которой и итерируется. Последовательностью может быть как численный ряд, так и строковый вектор, например, вектор названий файлов при импорте и обработке большого количества файлов в одном цикле. После выполнения цикла используемый итератор имеет значение последнего элемента цикла. В том же случае, если последовательность нулевой длины, то цикл не отрабатывает. 

```{r 06-expressions-evaluating-53 }
for (i in letters[1:3]) {
  cat('letter', i, '\n')
}
cat('i =', i)
```

### while
Циклы `while` и `repeat` используются намного реже. Если в цикле `for` количество циклов определяется длиной заданной последовательности, то в `while` количество циклов может быть бесконечным, до тех пор, пока поставленное условие будет верным. 

Для цикла надо задать начальное значение счетчика циклов, задать условие для этого счетчика и не забыть дополнить тело цикла увеличением счетчика при каждой итерации. Либо же добавить любое другое изменение значения счетчика, которое может привести срабатыванию условия. Второй вариант цикла `while` - это сначала создать объект с логическим значением `TRUE` и его поставить у условие, а потом прописать в теле цикла, что при определенных условиях значение сменится на `FALSE`, что и приведет к остановке цикла.

Выведем первые три элемента вектора `letters` с помощью цикла `while`.
```{r 06-expressions-evaluating-54 }
i <- 1
while (i < 4) {
  my_l <- letters[i]
  cat('letter', my_l, '\n')
  i <- i + 1
}
cat('i =', i)
```

Как правило, `while` нужен тогда, когда надо подсчитать количество попыток до какого-то результата, либо же неизвестно, сколько попыток модет потребоваться. Самый показательный пример - сбор данных с POST-запросом, когда сервер может не отвечать, соединение может рваться, и так далее.

### repeat
Цикл `repeat` схож с циклом `while`, только он выполняется до тех пор, пока при выполнении выражения не будет достигнут желаемый результат и не будет вызвана команда прерывания цикла. На том же примере с буквами:
```{r 06-expressions-evaluating-55 }
i <- 1
repeat {
    my_l <- letters[i]
    if (i == 4) {
      break()
    } else {
      cat('letter', my_l, '\n')
      i <- i + 1
    }
}
cat('i =', i)
```

### Прерывание циклов
В какие-то моменты возникает необходимость прервать цикл или же пропустить последующеи действия и начать новую итерацию цикла. Для этих целей используют функции `break()` и `next()`. Выше в цикле `repeat` мы уже использовали `break()`, вот еще один пример цикла с прерыванием:
```{r 06-expressions-evaluating-56 }
for (i in letters[1:10]) {
  cat(i, '\n')
  if (i == 'c')
    break()
}
```

Эффективнее всего функции прерывания в вложенных циклах - если прервать выполнение вложенного цикла, то родительский цикл не будет прерван и продолжит итерироваться. 

### Неявные циклы, семейство *pply

Циклами, в их привычном большинству программистов виде, в R пользуются не очень часто. Как правило, это ситуации, когда неизвестно количество возможных циклов, или, наоборот, их ничтожное количество (несколько названий файлов). В большинстве же случае пользуются так называемыми неявными циклами - функциями семейства *pply.

Самая распространенная и покрывающая большинство задач функция семейства, это `lapply()`. Первый аргумент функции - набор элементов, над которыми должно быть произведено какое-то действие. Буква `l` в названии маркирует, что функция обычно применяется к спискам (`l` = `list`) однако на практике используются и векторы, и списки и т.д. Фактически, первый аргумент в функции `lapply()` схож с итератором в цикле `for`. Второй аргумент - это собственно функция, которая должна быть применена к элементам вектора/списка из первого аргумента.
В качестве результата работы функция `lapply()` возвращает список, где каждый элемент - результат применения указанной во втором аргументе функции к каждому элементу первого аргумента. В этом заключается одно из отличий от классических циклов, в которых тело цикла всего лишь повторяется определенное количество раз. То есть, в классических циклах, в отличие от `lapply()`, нет возможности создать объект с результами цикла и надо изменять созданный за пределами цикла объект.

```{r 06-expressions-evaluating-57 }
res <- lapply(1:5, sqrt)
str(res)
unlist(res)
```

Если же у функции, используемой в `lapply()` есть дополнительные аргументы, то они идут последующими аргументами, так как в списке аргументов `lapply()` заданы `...`, дополнительные аргументы.

```{r 06-expressions-evaluating-58 }
# создадим список из векторов
my_list <- list(el1 = c(1, 2, 3, 4), 
                el2 = c(1, 2, NA, 4))

# вычислим среднее и укажем, что NA надо пропускать
lapply(my_list, mean, na.rm = TRUE)
```

Несмотря на определенную гибкость и возможность указывать аргументы функции, чаще всего в `lapply()` используются анонимные функции, в которые в качестве аргумента при выполнении передается значения объекта, переданного в первый аргумент (по которому осуществляется итерирование).

```{r 06-expressions-evaluating-59 }
res <- lapply(1:5, function(x) {
  z <- x * 2
  z <- sqrt(z)
  z
})
str(res)
unlist(res)
```

Семейство *pply-функций достаточно велико, вот наиболее часто используемые функции (тут я ориентируюсь на список А.Мастицкого):

- `lapply()`: `l` в названии означает `list`, список. Используется в случаях, когда необходимо применить какую-либо функцию к каждому элементу списка и получить результат также в виде списка. На деле обычно служит более удобным аналогом цикла `for`

- `sapply()`: `s` в названии означает `simplify`, упрощение. Работает как `lapply()`, только в результате отдает именованный вектор.

- `apply()`: используется в случаях, когда необходимо применить какую-либо функцию ко всем строкам или столбцам матрицы (или массивов большей размерности).

- `vapply()`: `v` в названии означает `velocity`, скорость. Аналогична `lapply()` и `sapply()`, однако в качестве еще одного аргумента требует указать тип данных, которые должны быть получены в результате. Это несколько ускоряет работу функции, что и привело к такому названию.

- `mapply()`: `m` в названии означает `multivariate`, многомерный. Используется в случаях, когда необходимо поэлементно применить какую-либо функцию одновременно к нескольким объектам (например, получить сумму первых элементов векторов, затему сумму вторых элементов векторов, и т.д.).

- `rapply()`: `r` в названии означает `recursively`, рекурсивно. Используется в случаях, когда необходимо применить какую-либо функцию к компонентам вложенного списка.

Некоторые пакеты имеют свои реализации неявных циклов, например, `parallel::mcmapply()`, которая часто используется для параллелизации кода.


### Векторизация
Векторизация - наверное, одна из самых примечательных и самых важных особенностей R как языка программирования и инструмента работы с данными. Фраза `векторизованная функция` означает, что операции производятся сразу над каждым элементом вектора. То есть, где в других языках программирования необходимо писать цикл или ламбда-функцию, в R можно просто передать вектор в агументы функции. Нередко те, кто только начинает писать на R, не знают или забывают про векторизацию, что порождает странные и неоптимальные решения типа цикла по вектору или по строкам датасета, чтобы изменить значения в колонке.

Например, функция `round()`, если в качестве аргумента использовать вектор значений, округлит до нужного знака каждый элемент вектора:
```{r 06-expressions-evaluating-60 }
x <- rnorm(5, 0, 1)
x
round(x, 3)
```

Выше, при описании `lapply())`, мы использовали как пример выражение `lapply(1:5, sqrt)`. Это, в определенной мере ошибочное использование `lapply()`, так как функция `sqrt()` векторизована, как и большинство базовых функций в R.

Аналогично можно применять векторизованные операции к колонкам, чтобы изменить всю колонку сразу:
```{r 06-expressions-evaluating-61 }
# создаем датасет
df <- data.frame(var1 = rnorm(5, 0, 1))
df

# создаем колонку с округленными значениями
df$var1_round <- round(df$var1, 3)
df
```

Большинство базовых операций в R векторизовано, то есть, применяется сразу к каждому элементу вектора. Это сильно упрощает вычисления и ощутимо повышает простоту и прозрачность кода. Точно так же векторизованной будет функция, в теле которой вызываются векторизованные функции:

```{r 06-expressions-evaluating-62 }
my_fun <- function(x) {
  x <- sqrt(x) - log10(x)
  x
}
my_fun(c(1, 100, 10000))
```

Тем не менее, надо учитывать, все сложные собственные функции, а так же ряд базовых функций не векторизованы. В таких случаях можно попробовать векторизовать функцию с помощью `Vectorize()`:
```{r 06-expressions-evaluating-63 }
my_fun <- function(x, y) {
  if (x <= y) {
    -1
  } else {
    1
  }
}
my_fun <- Vectorize(my_fun)
my_fun(1:6, 1:3)
```

Функция `Vectorize()` воспринимает и поэлементно обрабатывает каждый вектор, переданный в аргументы функции. В некоторых ситуациях это приводит к некорректным ситуациям, и в таких случаях надо явно указать, какой из аргументов необходимо векторизовать. Например, когда в функции производится нормировка элементов первого аргумента на агрегатный параметр второго вектора:
```{r 06-expressions-evaluating-64 }
my_fun <- function(x, y) {
  x - mean(y)
}
my_fun(1:5, 1:3)

# наивная векторизация
my_fun_vec <- Vectorize(my_fun)
my_fun_vec(1:5, 1:3)

# векторизуем с указанием аргумента
my_fun_vec <- Vectorize(my_fun, vectorize.args = 'x')
my_fun_vec(1:5, 1:3)
```

Это избыточный пример, так как `my_fun()` в данном случае использует векторизованную функцию вычитания, и необходимости в векторизации нет. Впрочем, стоит отметить, что использование `Vectorize()` само по себе встречается редко и, скорее, используется либо профессиональными разработчиками, либо, наоборот, неопытными пользователями. Во-вторых, если посмотреть на код функции `Vectorize()`, то видно, что эта функция является, по сути, сложной оберткой над функцией `mapply()`, которую можно использовать и самостоятельно.


## Условные операторы
### if...else
Поведение условных операторов `if` и `else` в R аналогично другим языкам - если (`if`) условие верно, то выполняется первое выражение, если же неверно (`else`), то второе. Условие `else` является необязательным, также в коде вполне может встретиться несколько конструкций с `if `, без последующего `else`.

Условие ветвления может быть задано как выражением, в результате которого возвращается единичное логическое TRUE/FALSE, либо же объектом с логическим значение (результат проведенной отдельно проверки). Если в условие передан численный объект, то он будет преобразован в логическое значение (0 в FALSE, все остальное в TRUE). При комбинации нескольких логических проверок, их объединяют через бинарные логические операторы `&&` или `||`.

Выражения, которые выполняются для if ... else желательно заключать в фигурные скобки, даже если это однострочное выражение (и обязательно, если это несколько выражений). Также следует помнить, что оператор `else` должен быть на той же строчке, на которой закрывается фигурная скобка оператора `if`. В противном случае эти два оператора будут проинтерпретированы как независимые, и R вернет ошибку.

```{r 06-expressions-evaluating-65 }
alarm <- 2 + 2 == 5
print(alarm)

if (alarm) {
  message('well, there are no problems')
} else {
  warning('Your math is broken!!!111')
}
```

### ifelse
Конструкция `if...else` обладает одним ограничением - она не векторизована. То есть, для того, чтобы проверить, допустим, каждый элемент вектора, необходимо использовать циклы. Либо же обратиться к конструкции `ifelse()`:
```{r 06-expressions-evaluating-66 }
x <- 1:5
ifelse(x %% 2 == 0, 'even', 'odd')
```

В примере мы создаем вектор от 1 до 5, и потом, с помощью `ifelse()`, проверяем каждый элемент, если элемент делится на 2 без остатка, то возвращаем `even`, иначе же - `odd`. Как правило `ifelse()` используется для модификации значений в колонках датасетов и любых других местах, когда надо не просто по условию выполнить какое-то выражение из пары альтернатив, а быстро модифицировать вектор значений.

### switch
Функция `switch()` - очень удобный вариант ветвления в ситуациях нескольких альтернатив. Согласно документации первым аргументом функции выступает строковое или численное значение. Стоит учитывать, что в зависимости от типа (строка или число) несколько меняется поведение функции. Так, если в первым аргументом передается численное значение, то функция возвращает альтернативу под таким номером, из указанного вторым и следующими аргументами списка альтернатив. Если значение первого аргумента превышает количество альтернатив, то функция ничего не вернет (точнее, вернет NULL):

```{r 06-expressions-evaluating-67 }
switch(3,
       "Amber",
       "Westeros",
       "Westworld",
       "Cadia")
```

```{r 06-expressions-evaluating-68 }
print(switch(3,
             "Amber",
             "Westeros"))
```

Если в функцию передается строковое значение (и это наиболее частое применение), то второй и следующие аргументы - это также список альтернатив, но альтернатив именованных. Это необходимо, так как строковое значение не не может быть использовано как номер альтернативы в списке. Список альтернатив должен быть именован в соответствии с допустимыми (или желаемыми) вариантами значений первого аргумента. Также можно указать одну альтернативу без имени, которая будет взвращаться по умолчанию, то есть, когда в первом аргументе будет значение, не совпадающее с названиями именованных альтернатив.
Функция `switch()` чаще всего используется при создании функций. В примере ниже функция `poles_of_existence` возвращает вектор имен ключевых элементов вселенной "Хроник Амбера" Роджера Желязны.
```{r 06-expressions-evaluating-69 }
# объявляем функцию
poles_of_existence <- function(pole) {
  switch(
    pole,
    Chaos = c('Serpent', 'The Logrus', 'Suhuy', 'Courts of Chaos'),
    Order = c('Unicorn', 'The Pattern', 'Dworkin Barimen', 'Amber'),
    'unknown'
  )
}

# вызываем имена и объекты Хаоса
poles_of_existence('Chaos')

# пробуем другой аргумент, которого нет в списке имен альтернатив
poles_of_existence('Westeros')
```

В редких случаях в функцию передается элемент сортированного вектора (фактора). В таком случае происходит конвертация типа значения в `character` и функция работает как со строковым значениям, несмотря на уровни фактора. Одновременно пользователю, при интерактивной работе, возвращается предупреждение. Впрочем, это достаточно редкий и вырожденный случай, который следует избегать.


## Non-standard evaluation
Non-standard evaluation можно перевести буквально как `нестандартное выполнение выражений`, однако аббревиатура NSE привычнее и чаще встречается даже в русскоязычных материалах, чем перевод. Поэтому далее будем использовать аббревиатуру NSE. NSE базируется на идущей от Lisp логики представления кода как данных, когда исполняемые выражения являются такими же объектами, как и, например, таблицы. Собственно, ключевая идея NSE заключается в разделении процессов создания выражения и выполнения этого выражения, что позволяет пользователю модифицировать выражение до того, как оно будет выполнено. 


### labelling 
Хэдли Викхем к виньетке по пакету `lazyeval` описывает три основные формы применения NSE. Первая из них, labelling (присваивание названия, аннотирование), встречается в некоторых базовых конструкциях R, например, в функции создания таблицы `data.frame()`. Несмотря на то, что `data.frame` это, по сути список, присвоение названий колонкам в создаваемой таблице отличается от создания списка. Так, если не указывать названия колонок при названии датафрейма и при создании использовать уже существующие объекты, то имена этих объектов и будут присвоены в качестве названий колонок таблицы:

```{r 06-expressions-evaluating-70 }
col1 <- 5
col2 <- 'abc'
my_df <- data.frame(col1, col2)
str(my_df)
```

Точно также названия и текстовые значения выражений при построении простейшего графика используются в качестве названий осей - название вектора с данными используется как название оси OX, а выражение, создающее значения по оси OY - как название оси OY:

```{r 06-expressions-evaluating-71, fig.height=4}
sin_values <- seq(0, 2 * pi, length = 100)
plot(sin_values, sin(sin_values), type = 'l', main = 'simple plot()')
```

Если посмотреть, то в функции `plot.default()` для создания меток из названий использованных объектов есть соответствующие строчки, используеющие комбинацию `deparse()` и `substitute()`. То есть, сначала захватываются выражения, переданное в аргументы. Потом, так как объекты класса `expression` нельзя использовать для названий осей на графике, они конвертируются в строки с помощью `deparse()`. В какой-то мере это поведение можно смоделировать в более короткой функции:

```{r 06-expressions-evaluating-72, fig.height=4}
myplot <- function(x, y)
  plot(x,
       y,
       xlab = deparse(substitute(x)),
       ylab = deparse(substitute(y)), 
       type = "l",
       main = 'deparse() + substitute()')

myplot(x = sin_values, y = sin(sin_values))
```




### non standard scoping
Вторая форма NSE - это выполнение выражения в контексте объектов, а не окружений, на английском языке формулируется как `non standard scoping`. В каноничном примере из `Advanced R` это поведение демонстрируется на примере функции `subset()`. Сама функция `subset()` принадлежит базовому пакету и предназначена для выделение частей из векторов, матриц и таблиц. В функции `subset.data.frame()`, которая применяется к датафреймам, аргумент `x` используется для задания датафрейма, аргумент `subset` - для логического выражения, по которому будет фильтроваться указанный датасет:

```{r 06-expressions-evaluating-73 }
args(subset.data.frame)
```

Так работает функция `subset.data.frame()`, таблицы `df` по условию на колонки выделяется таблица:
```{r 06-expressions-evaluating-74 }
df <- data.frame(col1 = c(2, 5, 1, 3, 2), 
                 col2 = c(5, 3, 1, 4, 1))
```

В такой форме поиск объектов `col1` и `col2` происходит сначала в заданном объекте `df`, и только если там они не будут найдены, поиск обратится к родительскому окружению. Это и есть проявление NSE. Если посмотреть в код функции `subset.data.frame`, то можно увидеть такие строчки:
```{r 06-expressions-evaluating-75, eval=FALSE}
e <- substitute(subset)
r <- eval(e, x, parent.frame())
```

Функция `substitute()` захватывает текст логического выражения, парсит, осуществляет необходимые подстановки и возвращает в виде выражения. Далее, с помощью функции `eval()` выполняется полученное выражение в окружении `x` (указанный в аргументах датафрейм). `parent.frame()` в качестве значения аргумента `enclos` указывает, в каком лексическом контексте необходимо выполнять это выражение.

Смешанный пример, где в условии `subset()` используется сравнение значений колонки с значением отдельного объекта из глобального окружения. Значения `z` нет в таблице `df`, поэтому при выполнении выражения используется `z` из родительского (в данном случае глобального) окружения:
```{r 06-expressions-evaluating-76 }
z <- 3
subset(df, col1 >= z)
```

Такая организация работы функций с использованием NSE существенно экономит время на написание кода и, в целом, делает функции более простым в использовании конечными пользователями, хоть и более сложным в отладке. 


### metaprogramming
Третья форма NSE - все, что не может быть отнесено к первым двум вариантам, однако работает в аналогичном формате. По большей части это различные функции, которые относятся либо собственно к выполнению выражений (`bquote()`), либо к организации рабочего окружения (`library()`, `help()`, `ls()`) и прочим.

Самым наглядным примером тут будет функция `library()`. Как правило, у многих начинающих пользователей R возникает вопрос, почему функция `library()` может принимать название пакета как в кавычках (`library('ggplot2')`), так и без них (`library(ggplot2)`). Аргументы функции, которые помогают разобраться с этой ситуацией и увидеть, как в даном случае реализовано NSE - `package` и `character.only`. Аргумент `character.only` по умолчанию имеет значение `FALSE`, то есть, на месте `package` ожидается не строка, а объект.
```{r 06-expressions-evaluating-77 }
args(library)
```

Если посмотреть код функции, то можно где-то в середине функции (на ~169 строке из 388) увидеть блок, который отвечает за обработку аргументов `package` и `character.only`:
```{r 06-expressions-evaluating-78, eval=FALSE}
if (!missing(package)) {
  if (is.null(lib.loc)) 
    lib.loc <- .libPaths()
  lib.loc <- lib.loc[dir.exists(lib.loc)]
  if (!character.only) 
    package <- as.character(substitute(package))
  if (length(package) != 1L) 
    stop("'package' must be of length 1")
  if (is.na(package) || (package == "")) 
    stop("invalid package name")
}
```

Нам интересна вот эта строчка, которая указывает, что если в аргумент `package` передана не строка (по умолчанию `character.only == FALSE`, а `!FALSE == TRUE`), то необходимо извлечь это выражение с помощью `substitute()` и превратить в строку.
```{r 06-expressions-evaluating-79, eval=FALSE}
if (!character.only) 
  package <- as.character(substitute(package))
```

Таким образом пользователь, когда хочет подгрузить какой-либо пакет, может указать как просто его название без кавычек, и оно будет принято как выражение и сконвертировано в строку, либо как объект, содержащий название пакета. При значении аргумента `character.only == FALSE` оба эти варианта будут идентичны. 

Если поменять значение `character.only` на `TRUE`, то значение, переданное в `package` будет выполнено, и именно результат выражения будет принят как название подгружаемого пакета. Выражением же может быть как единичный строковый вектор (например, `plotly`), так и объект, содержащий название пакета. Это позволяет провернуть следующий трюк (который категорически не рекомендуется использовать в реальной разработке!), когда под названием одного пакета подгружается совсем другой пакет:

```{r 06-expressions-evaluating-80, error=TRUE, echo=FALSE, warning=FALSE, message=FALSE}
detach("package:plotly", unload = TRUE)
detach("package:lme4", unload = TRUE)
```


```{r 06-expressions-evaluating-81, message=FALSE, warning=FALSE}
# создаем объект lme4 со значением plotly
lme4 <- 'plotly'

# проверяем, подгружены ли пакеты MASS или plotly
c('lme4', 'plotly') %in% loadedNamespaces()

# подгружаем пакет через использование объекта с названием пакета
library(lme4, character.only = TRUE)

# проверяем, подгрузился ли пакет lme4
c('lme4', 'plotly') %in% loadedNamespaces()
```
