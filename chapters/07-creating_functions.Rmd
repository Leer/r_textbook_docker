# Функции и создание функций {#functions}

В R огромное количество готовых функций, написанных разработчиками ядра или пакетов. Однако нередко бывает необходимо написать собственную функцию. Причин их написания может быть много - не устраивают существующие, хочется убрать повторяющиеся куски из кода, много операций, которые выполняются итеративно и неоднократно и т.д. В таких случаях проще и лучше написать собственную функцию. Есть вполне очевидная рекомендация - если какая-то часть кода будет использоваться больше одного раза, возможно, ее следует обернуть в функцию.

Как уже говорилось ранее в разделах #syntax_fun и #type_function, все функции в R состоят из трех частей имеют следующий общий вид:
```{r 07-creating-functions-1 }
my_fun <- function(arg1, arg2) {
  # тело функции, операции, перемножаем переданные значения
  tmp <- arg1 * arg2
  
  # возвращаем результат
  return(tmp)
}
```

В этом примере создания функции:

- Выражение `my_fun <- function(arg1, arg2)` - это создание объекта-функции под названием `my_fun`
- `arg1` и `arg2` - два аргумента функции (функция может принять два разных значения и произвести над ними какие-то операции)
- код в фигурных скобках - собственно тело функции, набор операций, которые должны совершаться над переданными значениями.
- аргументы `arg1` и `arg2`, объект `tmp` составляют рабочее окружение функции, оператор `*` и функция `return()` не входят в это окружение и используются как принадлежащие родительскому глобальному окружению. Подробнее про окружения см. #type_envir.
- `return(tmp)` - результат выполнения функции, который будет передан в глобальное окружение.

Создание функции, следовательно, заключается в использовании `function()` и указании, какие должны быть аргументы функции, что должна делать функция с полученными объектами и что должна возвращать в результате своей работы. В том случае, если функция пишется для использования в широком спектре ситуаций и, возможно, другими пользователями, в функции следует добавлять еще проверки на класс аргументов и обработчики событий (ошибки, предупреждений, действия при выходе и т.д.)

## Создание функции из списка {#fun-from-list}
Так как функции, также как и большинство объектов в R, могут быть представлены в виде списка, где первые элементы - аргументы функции, последний - тело функции или, в случае примитивных функций, выражение `UseMethod('primitive_name')`. Подобный список можно преобразовать в функцию с помощью `as.function()`, в первом элементе списка задать название аргумента (с классом `symbol`), вторым элементом - тело функции (в виде распарсенного, но не выполненного выражения):
```{r 07-creating-functions-2 }
# представляем объявленную ранее функцию в виде списка
as.list(my_fun)

# примитивная функция в виде списка
as.list(mean)

# задаем функцию в виде списка
my_fun_list <- list(
  # первый элемент - назание аргумента с классом symbol
   x = as.symbol('x'),
   # второй аргумент - распарсенное выражение
   quote(x ^ 2)
)
class(my_fun_list)
# перобразовываем в функцию и вызываем
my_fun_list <- as.function(my_fun_list)
class(my_fun_list)
my_fun_list(3)

```


## Аргументы функции {#fun-agrs}
Аргументы функции указываются в круглых скобках при определении функции. В теле функции имена аргументов служат своего рода абстрактными названиями для любых объектов, которые переданы в аргументы при вызове функции. Собственно, "передать какое-то значение в аргумент функции" означает, что при выполнении функции над этим объектом будут проведены те операции, которые в коде (теле) функции проводятся над этим аргументом. В принципе, выражения "передать значение в аргумент" тождественно "использовать значение в качестве аргумента" тождественны, второе, возможно, даже более корректно.

Простейший пример функции с одним аргументом. Функция вычисляет квадратный корень и округляет результат до второго знака:
```{r 07-creating-functions-3 }
# создаем функцию
my_fun <- function(x) {
  z <- sqrt(x)
  z <- round(z, 2)
  z
}

# используем функцию
my_fun(5)
```

Так как функция определяется в одном окружении, а тело функции принадлежит другому окружению, дочернему, допустимо использование одного и того же обозначения и для аргумента (и объектов родительского окружения), и для объектов окружения функции. Тем не менее, следует избегать подобных ситуаций, так как они существенно усложняют код и затрудняют отладку функции в случае ошибок. Ниже дан экстремальный пример, когда и объект глобального окружения, и аргумент функции, и объект в теле функции имеют одно и то же обозначение. Это хороший пример того, что пространство имен окружений иерархично, но относительно практики создания функций это пример того, как не надо делать:
```{r 07-creating-functions-4 }
# создаем объект в глобальном окружении
x <- 7

# создаем функцию с аргументом х
my_fun <- function(x) {
  # в теле функции создаем объект x из начения, переданного в аргумент функции
  x <- sqrt(x)
  x <- round(x, 2)
  x
}

# используем функцию, где используем объект x в качестве аргумента
my_fun(x)
```

Несмотря на то, что, как правило, все функции имеют свой набор аргументов, в редких случаях возможно создание функций вообще без аргументов. В таких случаях функции либо вычисляют и возвращают какое-то определенное значение, либо производят какие-то операции с объектами родительского окружения. Оба эти варианта, следует уточнить, крайне не рекомендуются к использованию, так как либо бессмысленны и усложняют код, либо просто вредны и некорректны с точки зрения R. Редкими примерами осмысленного использования функций без аргументов могут послужить функции `getwd()`, `Sys.time()` и им подобные.

Ниже пример функции, которая вычисляет квадратный корень из числа 5 и округляет его до второго знака:
```{r 07-creating-functions-5 }
# создаем функцию
my_fun <- function() {
  x <- sqrt(5)
  x <- round(x, 2)
  x
}

# используем функцию
my_fun()
```

### Значения аргументов по умолчанию {#fun-default}
Нередко в практике встречаются ситуации, когда один из аргументов функции принимает какое-то определенное значение (или значение из определенного вектора значений) намного чаще, чем все прочие возможные значения. В таких случаях разумно задать значение этому аргументу по умолчанию - то есть, если не указано обратное, то будет использоваться заданное значение. Например, функция `sort()` имеет значение аргумента `decreasing` по умолчанию равное `FALSE`. Соответственно, если не задавать этот аргумент, то функция сортирует вектор по возрастанию. И наоборот, если нужна сортировка по убыванию, следует прямо задать значение аргумента `decreasing = TRUE`:
```{r 07-creating-functions-6 }
sort(1:5)
sort(1:5, decreasing = TRUE)
```
Если посмотреть в справке описание аргументов функции `sort()`, то видно, что аргументу `x` никакое значение не передается, а аргументу `decreasing` - передается значение `FALSE`.
```{r 07-creating-functions-7 }
args(sort)
```

Собственно, таким образом и задаются значения по умолчанию - при объявлении функции аргументу уже передается какое-то значение. Например, функция ниже умножает значение, переданное в качестве первого аргумента, на 2, если значение второго аргумента не указано

```{r 07-creating-functions-8 }
# объявляем функцию my_fun, которая перемножает два переданных объекта
# если второй аргумент не указан, то считаем, что он равен 2
my_fun_def <- function(arg1, arg2 = 2) {
  tmp <- arg1 * arg2
  return(tmp)
}
```

Используем созданную функцию, и в аргумент, у которого есть значение по умолчанию, ничего не передаем (игнорируем его):
```{r 07-creating-functions-9 }
# не указываем аргумент
x <- 9
my_fun_def(x)
```

Точно также функции можно ограничить набор возможных значений, которые могут быть использованы в качестве какого-то аргумента. Как правило, это касается ситуаций, когда такой аргумент определяет метод вычисления, и в теле функции организовано ветвление в зависимости от того, какое значение будет указано для этого аргумента. Например, ниже в примере для аргумента `st` мы задаем всего два значения, которые указывают, возвести значение аргумента `x` в степень `y` или вычислить корень соответствующей степени (возвести в `1/y` степень). Если в качестве аргумента `st` используется другое значение, то функция вернет предупреждение:
```{r 07-creating-functions-10 }
# создаем функцию с тремя аргументами
my_fun <- function(x, y, st = c('pow', 'root')) {
  if (st == 'pow') 
    return(x ^ y)
  if (st == 'root') 
    return(x ^ 1/y)
  message('unknown value for st')
}

# проверяем работу функции
my_fun(4, 2, st = 'pow')
my_fun(4, 2, st = 'root')
my_fun(4, 2, st = 'rt')
```

### Точки (...) {#fun_args_dots}
Строгий набор аргументов, даже со значениями по умолчанию, образуют достаточно жесткую конструкци. В то же время в некоторых ситуациях необходимо оставить возможность использовать в функции дополнительные необязательные аргументы. В таких случаях используют специальный аргумент, который называют `три точки`, `dot-dot-dot`. Самый простой пример - функция, в которой единственный аргумент - это три точки, и функция возвращает класс переданных объектов:

```{r 07-creating-functions-11 }
# функция, которая выводит класс всех переданных аргументов
my_fun_dot <- function(...) sapply(list(...), class)
my_fun_dot('a', 5, TRUE)

```

В примере выше для того, чтобы предусмотреть ситуацию, что может быть передан не один аргумент, мы в теле функции собрали все переданные аргументы в список и уже к списку поэлементно применили функцию `class()`. Другим примером функций с подобным использованием трех точек служат функции `rbind()` и `cbind()` - три точки на месте первого аргумента позволяет склеивать с помощью этих функций построчно или поклоночно любое количество объектов:
```{r 07-creating-functions-12 }
args(rbind)
args(cbind)
```

Использование трех точек в аргументах функций накладывает определенные условия использования аргументов. То, что в аргументах функции объявляется до трех точек, называется обязательными аргументами, после трех точек - необязательными аргументами. Значения в обязательные аргументы можно передавать просто в порядке представления аргументов в функции, для необязательных аргументов наоборот, всегда требуется указывать, какому именно аргументу передано значение. Другое отличие - в обязательные аргументы должно быть передано какое-то значение, в то время как необязательные аргументы можно просто опустить. На основе предыдущей функции напишем функцию, которая возвращает список, где первый элемент - результат перемножения первых двух аргументов, второй элемент - вектор названий классов а третий элемент - возведение во вторую степень необязательного аргумента `pwr`:
```{r 07-creating-functions-13 }
# объявляем функцию
my_fun_dot <- function(x, y, ..., pwr) {
  z1 <- x * y
  z2 <- sapply(list(...), class)
  z3 <- pwr ^ 2
  list(z1, z2, z3)
}

# вызываем функцию с переданными аргументами
my_fun_dot(3, 7, 'a', TRUE, 3, pwr = 3)
```

В примере выше все аргументы - обязательные, необязательные и точки используются в результате вывода. Следовательно, если какой-то из аргументов не передать, то и вызов функции вернет ошибку (правда, если не передать аргументы вместо точек, то вторым элементом в списке-результате будет пустой лист).  Приведем простой пример ситуации, когда аргументы, переданные вместо точек, никак не используются в выводе:
```{r 07-creating-functions-14 }
my_fun_dot <- function(x, ...) sqrt(x)
my_fun_dot(9, 19)
```


### Последовательность использования аргументов {#fun-args-seq}
В R реализовано ленивое использование аргументов - значения аргументов используются ровно в тот момент, когда они нужны. Это позволяет делать несколько эзотерические трюки, когда значение какого-нибудь аргумента вычисляется в процессе работы функции:
```{r 07-creating-functions-15 }
# создаем функцию
lazy_args <- function(arg1, arg2) {
  # в которой второй аргумент вычисляется по значению первого
  arg2 <- arg1 ^ 2
  # суммируем оба аргумента
  z <- arg1 + arg2
  return(z)
}
```

Вот так выглядит использование функции, в которой один из аргументов не определен на момент вызова функции, и вычисляется в процессе выполнения:
```{r 07-creating-functions-16 }
lazy_args(arg1 = 3)
```



## Тело и результат функции {#fun-body}
Тело функции - это код на языке R, который описывает действия, которые необходимо совершить над объектами. Сответственно, когда функция вызывается, этот набор действий применяется к тем объектам, которые были переданы в аргументы функции. Как правило, код (тело) функции заключается в фигурные скобки. Однако если тело состоит из одного выражения, то фигурные скобки можно опустить:
```{r 07-creating-functions-17 }
# объявляем функции
my_fun1 <- function(x) {x ^ 5}
my_fun2 <- function(x) x ^ 5

# вызываем функции
my_fun1(5)
my_fun2(5)
```

Код функции, как минимум, описывает обязательные действия над объектами. Тем не менее, для повышения устойчивости и абстрактности функции рекомендуется использовать различные дополнительные инструменты - например, проверку аргументов, обработку ошибок, а так же проверку типов переданых объектов, информирование пользователя о каких-то процессах и так далее.

### Неполное указание значений аргументов {#fun-args-part}
Выше мы уже упоминали, что в функцию в качестве значений аргумента по умолчанию задается вектор определенных значений. Хорошим примером здесь будет функция вычисления расстояний `dist()`, в которой аргумент `method`  может принимать одно из возможных значений ("euclidean", "maximum", "manhattan", "canberra", "binary" или "minkowski"). Каждое из этих значений можно указать как полным названием, так и первыми буквами названия, обеспечивающими уникальное толкование и выбор единственного значения. Например, выражение `method = 'euc'` также работает, как и `method = 'euclidean'`:
```{r 07-creating-functions-18 }
# задаем две точки с координатами (1, 1) и (2, 2)
x <- matrix(c(1, 2, 1, 2), ncol = 2, nrow = 2)

# вычиляем расстояние между точками
dist(x, method = 'euc')
dist(x, method = 'euclidean')
```

Подобное поведение реализовано за счет использования функции `match.arg()` в теле вызываемой функции. В функцию `match.agr()` передается значение какого-то аргумента функции, вторым аргументом - вектор его возможных значений (если его нет, берется тот, который указан в значениях аргумента по умолчанию). Ниже пример из справки по функции `match.arg()`, где создается функция оценки центральной тенденции и предполагается три разных метода - среднее, медиана и усеченное среднее:
```{r 07-creating-functions-19 }
center <- function(x, type = c("mean", "median", "trimmed")) {
  # верифицируем аргумент в случае неполной записи
  type <- match.arg(type)
  
  # в зависимости от значения type вызываем разную оценку центральной тенденции
  switch(type,
         mean = mean(x),
         median = median(x),
         trimmed = mean(x, trim = .1))
}

# применяем функцию с точным и неполным значением аргумента type
x <- rnorm(100)
center(x, type = 'trimmed')
center(x, type = 'tri')
```

Функция `match.arg()` также позволяет задавать ситуации, когда аргумент может быть передано одновременно больше чем одно значение из вектора возможных значений. Однако это осмысленно только в том случае, когда код функции сам по себе предполагает возможность двух или более значений аргумента. Например:
```{r 07-creating-functions-20 }
center_names <- function(x, type = c("mean", "median", "trimmed")) {
  # верифицируем аргумент в случае неполной записи, допускаем несколько вариантов
  type <- match.arg(type, several.ok = TRUE)
  
  # пробегаем по вектору переданных значений типа центр.тенденции, вычисляем
  res <- sapply(type, function(z) {
    res <- ifelse(z == 'trimmed', mean(x, trim = .1), do.call(z, list(x)))
  })
  
  # возвращаем результат
  res
}

# вычисляем среднее и усеченное среднее
my_data <- rnorm(100)
center_names(my_data, type = c('mea', 'tr'))
center_names(my_data, type = c('mean', 'trimmed'))
```


### Проверка классов используемых значений {#fun-args-class}
Достаточно часто встречаются ситуации, когда в качестве аргументов функций используются объекты иных классов, чем предполагается в коде функции. Например, это может быть ошибка импорта данных, когда числа импортируются как строковые значения или даты в источнике данных представлены не в ISO-формате (как правило, такое случается при импорте из `xlsx` с настройками по умолчанию). Точно так же случаются ситуации, когда на каком-то их предыдущих этапов процессинга была получена ошибка, и один из используемых в функции объектов является NULL-объектом. Все эти случаи требуют включения в тело функции проверки существования и класса используемых значений. В примере ниже делается проверка, что переданный объект - численный. В рамках базового R подобные проверки можно делать с помощью конструкций `if...else`, или же использовать специализированные пакеты (про `return()` и `invisible()` ниже).
```{r 07-creating-functions-21 }
# объявляем функцию, которая делает дополнительно проверку типа
my_fun <- function(x) {
  if(!is.numeric(x)) {
    message('Alarm! Not a real number!')
    return(invisible(NULL))
  }
  sqrt(x)
}
```

```{r 07-creating-functions-22, eval = TRUE}
# проверяем, как работает
my_fun(5)
my_fun('char')
```

### Возвращаемый результат функции {#fun-result}
Большинство функций в результате своей работы возвращает один объект. Объектом может быть вектор значений, список, таблица, другая функция и так далее. Для того, чтобы указать, какой именно объект должна вернуть функция, используется `return()` и, что важно, использовать эту функцию можно в любом месте тела функции. Впрочем, возможен и более лаконичный вариант, когда самой последней строчкой тела функции указывается название возвращаемого объекта. Следует учитывать, что это должно быть именно имя объекта или какое-то выражение, создающее новый объект (`*pply`-функции, `function()`, `data.frame()` и так далее), за исключением операции присвоения:
```{r 07-creating-functions-23 }
# используем return(x) в середине кода
my_fun1 <- function(x) {
  x <- x ^ 3
  return(x)
  x <- x * 2
}

# возвращаем x просто последней строчкой
my_fun2 <- function(x) {
  x <- x ^ 3
  x
}

# проверяем
my_fun1(2)
my_fun2(2)
```

Также можно скрыть результат работы функции - то есть, функция есть, функция работает корректно, однако при вызове функции результат не выводится. Например, в функции ниже переданный объект возводится в квадрат, но при вызове функции результате не возвращается. Чтобы получить результат такой функции, выражение ее вызова следует обернуть в скобки.
```{r 07-creating-functions-24 }
# подавляем вывод результата
my_fun <- function(x) {
  x <- x ^ 2
  invisible(x)
}

# вызываем функцию
my_fun(3)

# вызываем функцию с форсированным выводом результата
(my_fun(3))

# сравниваем скрытый результат функции с реальным значением
my_fun(3) == 3 ^ 2
```

### Замыкания {#fun-closures}
Функции, как правило, возвращают какой-то объект. Обычно это вектор, таблица или список. Однако точно также функции могут возвращать и функции (которые точно такой же объект в R, как и списки). Единственное отличие - возвращенные функции "помнят" определенные элементы окружений, в которых они были созданы. Например, создадим функцию, которая принимает один аргумент, и возвращает самостоятельную функцию, принимающую другой аргумент на вход и в теле которой происходит сложение этих двух аргументов. Тогда при вызове первой функции (`my_func()`) будет создана еще одна функция (здесь `new_func()`), которая "помнит" значение переданного аргумента `x` и складывает его с уже своим аргументом:
```{r 07-creating-functions-25 }
# объявим функцию
my_fun <- function(x) {
  function(y)
    x + y
}

# вызовем с аргументом x = 2 (создадим новую функцию)
new_fun <- my_fun(x = 2)

# проверим класс и тело функции new_func()
class(new_fun)
body(new_fun)

# применим функцию new_func()
new_fun(3)
```


Такая структура, когда функция возвращает функцию, называется замыканием. Структурно функции с замыканием ничем не отличаются от обычных функций и создаются аналогично. Ниже приведен более приближенный к практике пример, когда функция с замыканием используется как генератор функций, отрисовывающих `ggplot2`-график с той или иной темой. Сначала содается функция-генератор, которая в качестве аргумента принимает название цветовой схемы (темы) графика, и возвращает замыкание, которое отрисовывает график по заданным ранее параметрам и указанной темой. 
```{r 07-creating-functions-26 }
# подключаем пакет
library(ggplot2)

# создаем функцию-генератор с замыканием
ggplot_generator <- function(my_theme_name) {
  my_ggplot <- function(data = NULL, mapping = aes(), ..., environment = parent.frame()) {
    ggplot(data = data, mapping = mapping, ..., environment = environment) + 
      my_theme_name()
  }
  return(my_ggplot)
}
```

Так как в теле функции используется аргумент `...` и указывается родительское окружение как рабочее, то в полученную функцию можно передавать дополнительные аргументы - датасет, оси и проч. 
```{r 07-creating-functions-27 }
# генерируем функцию, отрисовывающую график в белой схеме
gg_dark <- ggplot_generator(my_theme_name = theme_minimal)

# применяем полученную функцию
gg_dark(iris, aes(x = Sepal.Width, y = Sepal.Length, colour = Species)) + 
  geom_point()
```


```{r 07-creating-functions-28, echo=FALSE}
rm(ggplot_generator, gg_dark, new_fun, my_fun)
```


В целом, применение замыканий - это синтаксический сахар, который призван либо упростить визуально конечный код, либо создать генератор функций для использования в незначительно различающихся ситуациях. Также замыкания используются для того, чтобы дополнить функцию, которую нельзя изменять (подобно декораторам в Python).

Нередко использование замыканий является лишь альтернативным путем решения уже предусмотренной разработчиками проблемы - как выше, с указанием тем. Несмотря на то, что функции с замыканиями ничем не отличаются от прочих префиксных функций, их использование может несколько ухудшить понятность кода.


### Функции высших порядков {#fun-high-order-fun}
Функции высших порядков - функции, в аргументы которых можно передавать другие функции. Классическим примером подобных функций в R являются функции *pply-семейства, например, `sapply()`:
```{r 07-creating-functions-29 }
sapply(1:5, sqrt)
```

Создание подобных функций ничем не отличается от простых функций, и весь процесс основан на идее, что в R названия функции - это такие же пары название объекта + его значение. Это позволяет прямо передавать название функции в качестве аргумента. Например, создадим аналог функции `sapply()`, которая возвращает вектор значений вектора `x`, после того, как к ним была применена функция, переданная в аргумент `new_f`:
```{r 07-creating-functions-30 }
myapply <- function(x, new_f) {
  result <- x
  for (i in seq_along(x)) 
    result[i] <- new_f(x[i])
  result
}

myapply(1:5, sqrt)
myapply(1:5, function(x) x^2)
```

```{r 07-creating-functions-31, echo=FALSE}
rm(myapply)
```



### Кастомные действия при завершении функции {#fun-custom-in-result}
Функция `on.exit()` указывает, какое выражение должно быть выполнено при завершении работы функции. Как правило, это полезно в тех случаях, когда в процессе выполнения функции изменяются какие-то глобальные настройки - параметры сессии, адрес рабочей директории, графические настройки и так далее. Второе применение функции `on.exit()` - завершение работы функции, даже если в процессе выполнения функции произошла ошибка (недоступна база данных, ошибка в выражении, нет данных в датасете и проч.). Например, функция, которая меняет рабочую директорию, возводит переданное значение в квадрат, а на выходе - возвращает исходное значение рабочей директории:
```{r 07-creating-functions-32 }
my_fun_exit <- function(x) {
  # сохраняем и и печатаем адрес текущей рабочей директории
  old_dir <- getwd()
  print(old_dir)
  
  # создаем папку и устанавливаем новую директорию - домашнюю папку
  dir.create('./new_dir', showWarnings = FALSE)
  setwd('./new_dir')
  
  # проверяем, что рабочая директория поменялась
  print(getwd())
  
  # задаем, что на выходе надо вернуться к старой рабочей директории
  on.exit({
    setwd(old_dir)
    
    # удаляем новую директорию
    unlink('new_dir', recursive = TRUE)
  })
  
  
  # возводим переданный аргумент в квадрат и возвращаем его
  z <- x ^ 2
  z
}
  
# применяем функцию и смотрим текущую рабочую директорию
my_fun_exit(5)
getwd()

```


### Обработка ошибок и предупреждений {#fun-exeptions}
Нередко функции пишутся для промышленного использования или просто предназначены для широкого круга пользователей, как в пакетах. К сожалению, мир не идеален и данные крайне редко бывают свободны от различных ошибок и пропусков, также они могут иметь иные типы, отличное от ожидаемого количество измерений и структуру и так далее. Поэтому существует практика  закладывать в функции массового использования обработчики ошибок или предупреждения, которые позволят пользователям быстро определить, в чем проблема. 

Основной обработчик ошибок - функция `tryCatch()`. Функция `tryCatch()` имеет три группы аргументов: 

- собственно тестируемое выражение (аргмент `expr`)
- обработчики событий (`...`, вместо которых можно использовать `error`, `warning`, `message`)
- выражение, результат которого будет возвращен в результате работы функции (`finally`). 

Общая логика работы фукции выглядит следующим образом - если в результате выполнения тестируемого выражения будет получена ошибка или предупреждение (сообщение тоже, но это намного более редкая ситуация), то для них можно будет задать отдельные действия. Соответственно, при вызове функция вернет результат выполнения выражения (если выражение выполняется корректно) или те действия, которые заданы для ситуаций появления ошибок или предупреждений во время выполнения выражения. Если также задан аргумент `finally`, то в в результат выполнения функции добавляется еще и результат выполнения выражения из `finally`:

```{r 07-creating-functions-33 }
# задаем функцию с tryCatch
my_fun <- function(x) {
  tryCatch(
    # задаем выражение
    expr = {
      sqrt(x)
      library(noname_package)
    },
    # указываем, что делать, если появится ошибка
    error = function(e) print(paste('получили ошибку:', e)),
    # указываем, что делать, если появится предупреждение
    warning = function(w) print(paste('получили предупреждение:', w)),
    # указываем, что делать, если появится сообщение
    message = function(m) print(paste('получили сообщение:', m)),
    # указываем, что делать при завершении функции
    finally = print('finally: this is the end, my friend')
  )
}
# используем такое значение аргумента, чтобы получить предупреждение
my_fun(-5)

# используем такое значение аргумента, чтобы получить ошибку
my_fun(5)
```
Такое поведение возможно за счет того, что при выполнении выражения возможные ошибки или прочие события пишутся в соединение `stderr()` каким-то из простых классов ряда `simpleWarning`, `simpleError` или  `simpleMessage`. Соответственно, выражение вида `error = function(e) print(paste('получили ошибку:', e))` как раз отслеживает появление ошибки во время выполнения выражения и возвращает определенное действие, в нашем случае создание и печать текстовой строки из `'получили ошибку:'` и текста ошибки. Аргумент `e` является лишь указателем на ошибку, и может быть назван как угодно, в пределах разрешенных слов. 

Следует учитывать, что в данном случае порядок имеет значение, и `tryCatch()` вернет то действие, которое встретится первым. В примере выше предупреждение при выполнении выражения `sqrt(-5)` получено раньше однозначно ошибочного выражения `library(noname_package)`. Поэтому в результате выполнения `tryCatch()` мы получили результат выражения, которое задано для предупреждний и результат выражения в `finally`. При этом выражение, заданное для ошибок (`function(e) print(paste('получили ошибку:', e))`), проигнорировано и не выполнено.

## Инфиксные функции (операторы) {#fun-infix}
Объявленные функции, которые присутствуют в окружении в виде самостоятельных объектов, можно разделить на префиксные, инфиксные функции и модифицирующие функции. При использовании префиксных функций название функции предваряет список аргументов, например, `my_fun(x, y)`, это основная форма использования функций в R.  Инфиксные функции вызываются между двумя объектами, над которыми происходит действие. Фактически, все используемые операторы в R - это инфиксные функции. При желании инфиксные функции можно вызвать в виде префиксных, в таких случаях название функции выделяется обратными апострофами:
```{r 07-creating-functions-34 }
# обычный инфиксный вид оператора сложения
3 + 4

# представление в постфиксной записи
`+`(3, 4)
```
Как правило, инфиксные функции носят вид `%fun_name%` - то есть, название функции заключено в знаки процента (`%`). Исключение составляют только функции, переопределяющие операторы из зарезервированного набора бинарных операторов (`+`, `-` и проч.). Ниже пример оператора пересечений множеств - только три значения множества 1:5 входят в множество изначений 2:4:
```{r 07-creating-functions-35 }
1:5 %in% 2:4
```

Так как операторы - это такие же функции, то можно создать свой оператор или даже переназначить уже существующий. Стоит учитывать, что изменение поведения привычных операторов крайне не приветствуется, поэтому лучше создавать свои собственные операторы, на основе сочетаний букв. Для этого формируется название оператора (название функции и знаки процента слева и справа от него). Далее эта запись заключается в обратные апострофы, из-за нестандартного для R именования объектов, и полученный результат используется как название создаваемой функции. В примере ниже создается функция, обратная `%in%` - поиск значений одного множества, не входящих во второе множество. В данном случае, для идентичности с функцией `%in%` выводится логический вектор, несмотря на то, что корректнее было бы написать `x[!(x %in% y)]`:
```{r 07-creating-functions-36 }
`%nin%` <- function(x, y) !(x %in% y)
1:5 %nin% 2:4
```

## Функции модификации {#fun-modifyers}
Третий вид функций, наряду с префиксными и инфиксными функциями - функции замещения. Такие функции используются, когда необходимо изменить объект или элемент объекта. Например, выражение `names(my_df) <- c('col1', 'col2')` как раз представляет собой использование функции `names<-`, так как одновременно вызываются названия таблицы `my_df` и им присваиваются новые значения. Выражение `x[2] <- 2` также представляет собой применение функции замещения `[<-`. 

По форме эти функции аналогичны префиксным функциям, однако в названии, как видно из примера, содержат знак `<-`. При объявлении этих функций первым аргументом обычно указывают объект, над которым производится действие (`x`), вторым аргументом - номер замещаемого элемента, `position` (если релевантно), третьим аргументом - новое значение (`value`). В данном случае закрепленные и обязательные аргументы только `x` и `value`, элемент `position` может быть назван как угодно, к тому же подобных дополнительных аргументов может быть несколько. Так как название должно содержать `<-`, то оно заключается в обратные апострофы:
```{r 07-creating-functions-37 }
`my_fun_replacement<-` <- function(x, position, position2, value) {
  x[position] <- value
  x[position2] <- 'additonal value'
  x
}
```

Такого рода функции можно вызывать двумя способами - в стандартном для префиксных функций виде и в специальном виде, когда новое значение присваивается через явное использование оператора присваивания. В первом случае возвращается результат работы функции, но сам объект не изменяется. Во втором случае происходит изменение объекта:
```{r 07-creating-functions-38 }
# создаем вектор значений
my_vec <- c('a', 'b', 'c')

# используем стандартную форму, создаем четвертый элемент
`my_fun_replacement<-`(x = my_vec, position = 4, position2 = 2, value = 'forth element')
my_vec

# используем оператор присваивания
my_fun_replacement(my_vec, 4, 2) <- 'forth element'
my_vec
```

## Анонимные функции {#fun-anonimous}
Помимо объявленных функций, существующих в виде самостоятельных объектов, в R можно использовать так называемые анонимные функции. Анонимные функции не требуют создания объекта функции и представляют собой просто набор операций, выполняемых с переданными в определенный момент в аргументы функции значениями. Наиболее часто анонимные функции используются вместе с `*pply`-функциями:
```{r 07-creating-functions-39 }
sapply(letters[1:5], function(x) paste("letter", x))
```
В примере выше выражение `function(x) paste("letter", x)` и есть анонимная функция c одним аргументом. Результат выполнения этой функции - склейка строки `'letter'` и значения переданного аргумента. Аргументы в анонимную функцию передаются из первого аргумента функции `sapply()`, в данном случае это вектор из первых пяти букв латинского алфавита.

Другой пример использования анонимой функции - при трансформации таблицы из длинного формата в широкий, с собственной функцией обработки значений в ячейках.

```{r 07-creating-functions-40 }
# создаем датасет и выводим его на печать
tmp <- data.frame(v1 = 'A', v2 = c('p1', 'p1', 'p2', 'p2'), v3 = 3:6)
print(tmp)

# переводим таблицу из длинного формата в широкий, с вычислением среднего по комбинации v1 ~ v2
reshape2::dcast(tmp, v1 ~ v2, value.var = 'v3', fun.aggregate = mean)

# переводим таблицу из длинного формата в широкий, с вычислением квадрата среднего по комбинации v1 ~ v2
reshape2::dcast(tmp, v1 ~ v2, value.var = 'v3', fun.aggregate = function(x) mean(x) ^ 2)
```

## Рекурсивный вызов функции {#fun-recurcive-call}
Функции могут вызываться рекурсивно - то есть, когда в теле функции вызывается эта же функция. Например, рекурсивная функция вычисления факториала:
```{r 07-creating-functions-41 }
recursive_factorial <- function(x) {
  if (x == 0) 
    return (1)
  else {
    print(x)
    return (x * recursive_factorial(x - 1))
  }
}
```

Факториал числа 3 может быть представлен в виде `3! = 3 * 2 * 1`, или, в общем виде, `n! = n * (n - 1)!`. Следовательно, наша рекурсивая функция, при вычислении факториала последовательно вызывает себя, но уже с новым значением аргумента, пока `x - 1` не станет нулем.
```{r 07-creating-functions-42 }
factorial <- recursive_factorial(3)
print(factorial)
```


## Документирование функций {fun-documentation}
