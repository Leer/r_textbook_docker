# Ввод и вывод данных
## Типы соединений
## Чтение ввода пользователя
При интерактивной работе в консоли R временами возникает необходимость прочитать вводимые пользователем значения. В какой-то мере это одна из классических учебных и иллюстративных задач, так как в реальной практике такие задачи встречаются только при реализации интерактивного взаимодействия с пользователем (например, обучающий пакет `swirl`).
Чтение ввода пользователя осуществляется с помощью функции `readline()` (ниже скопирована последовательность ввода в консоли):

```{r 08-io-1, eval=FALSE}
> user_input <- readline()
a b_c
> print(user_input)
[1] "a b_c"
```

Второй, еще более редкий вариант интерактивного ввода данных пользователем - функцию `menu()`, в которой можно дать пользователю возможность выбрать вариант из списка. При использовании аргумента `graphics = TRUE` поднимается интерактивное окно. Простейший пример использования `menu()` (также скопирована копия последовательности ввода в консоли):

```{r 08-io-2, eval=FALSE}
> menu(choices = c("List letters", "List LETTERS"))

1: List letters
2: List LETTERS

Selection: 1
[1] 1
```

```{r 08-io-3, include=FALSE}
rm(list = ls())
```

## Вывод сообщений
### Вывод на печать
#### print()
Для вывода на печать обычно используют функцию `print()` и, в некоторых случаях, `cat()`. Функция `print()`, пожалуй, одна из самых часто используемых функций, даже простейшую отладку делают с ее помощью. `print()`- это обобщающая функция, для очень большого числа классов определяется свой метод `print()`. Например, методы для линейных моделей и обобщенных линейных моделей:

```{r 08-io-4 }
methods("print")[grep('lm', methods("print"))]
```

Так как `print()` для каждого класса может иметь свои параметры, рассмотрим функцию `print.default()`, которая применяется для вывода на печать векторов. Как правило, для `print()` не используют дополнительные аргументы, в большом количестве случаев вообще даже саму функцию не пишут - и IDE, и консоль R интерпретируют вызов объекта в консоли как вывод на печать:

```{r 08-io-5 }
x <- 1:5
print(x)
x
```

Основные аргументы - `quote` и `digits`. При `quote = TRUE` при печати сроки скрываются окружающие кавычки:

```{r 08-io-6 }
print('This is a string')
print('This is a string', quote = FALSE)
```

Аргумент `digits` менее очевиден - с его помощью задается количество значимых знаков, которое должно быть отображено (а не количество знаков после запятой, как в одноименном аргументе функции `round()`). При этом по умолчанию считается, что значимых знаков семь. Также стоит учитывать, что если целая часть больше 22 знаков, то результат будет представлен в академическом (scinetific) формате, в виде числа с плавающей точкой (если не выставлено `options(scipen = 999)`):

```{r 08-io-7 }
# двузначное число с дробной частью, всего пять знаков
x <- 85.547
print(x)
print(x, digits = 3)

# число длиной в девять знаков
x <- 198789.547
print(x)
print(x, digits = 10)

# число длиной 30 знаков
x <- 38955015567677251979744654351
print(x)
```

Такая логика характерна не только для базового `print()`, но и для некоторых других функций и классов (например, `View()` или некоторые функции в tidyverse). Вызвано это стремлением упростить пользователю жизнь и не перегружать лишней информацией - предполагается, что если дробная часть числа существенно меньше целой, то ее наличие или отсутствие мало повлияет на решение пользователя, при этом все число восприниматься будет проще. Важно понимать, что результат `print()` - это именно отображение данных пользователю, а не реальное округление, и используется только для численных векторов:

```{r 08-io-8 }
x <- 38901556.7677251
print(x)
print(as.character(x))
```

Другой нюанс функции `print()` - она не только выводит на печать значение, но и возвращает его. То есть, с точки зрения кода вполне легальна следующая ситуация. Правда, с точки зрения читабельности и адекватности подобные решения лучше не использовать, особенно когда `print()` используется в функции для промежуточного контроля:

```{r 08-io-9 }
x <- print(sample(5))
print(x)
```

#### cat()
Функция `cat()` во многом повторяет функционал `print.default()`, в том числе и подход к отображению длинных чисел. Однако `cat()` намного удобнее исползовать в ситуации, когда необходимо из нескольких переменных собрать одну текстовую строку и ее вывести на печать (так как `cat` идет от `concatenate`). Это заменяет связку функций `paste()` + `print()`.

```{r 08-io-10 }
x <- 5
cat(x, 'random numbers =', sample(x))
```

Так как `cat()` склеивает переданные объекты, то и вывод в консоли идет на одной строке, в том числе на этой же строке оказывается и следующее выражение. Для переноса строки необходимо указать разделитель `sep = '\n'`:

```{r 08-io-11 }
# без разделителя
cat(1:3)
x <- 'new object'

# с разделителем
cat(1:3, sep = '\n')
x <- 'new object'
```

```{r 08-io-12, include=FALSE}
rm(list = ls())
```


### Информационные сообщения: message, warning, stop
В функциях нередко используют информационные сообщения - `message()`, `warning()` и `stop()`. Первая функция используется, когда необходимо что-то сообщить об операциях во время выполнения функции. Например, если в функции необходимо сделать дополнительную конвертацию строкового значения в числовое:

```{r 08-io-13 }
# объявляем функцию, которая умножает значение на 5
my_fun <- function(x) {
  if (is.character(x)) {
    x <- as.numeric(x)
    message('Converted char x into numeric')
  }
  x * 5
}

# передаем в x строковое значение
my_fun('3')
```

Функция `warning()` используется в том случае, есть есть какая-то особенность при выполнении функции, которая может влиять на результат. Например, умножении двух векторов разных размеров происходит повторное использование элементов более короткого вектора, до достижения равной длины. В целом, использование функции вызывает ряд вопросов, так как допускает ситуацию, когда пользователь может проигнорировать предупреждение и получить некорректный результат. К тому же в большинстве случаев, и правда, ситуации, классифицируемые как требующие внимания, стоит называть ошибками.

```{r 08-io-14 }
# короткий вектор будет повторяться до вида 3, 2, 3, 2, 3
c(1, 2, 3, 4, 5) * c(3, 2)
```

`stop()` используется в схожих случаях, как и `warning()`, однако не дожидается окончания выполнения функции, а завершает выполнение и извещает пользователю об ошибке. Например:

```{r 08-io-15, eval=FALSE}
# объявляем функцию, которая умножает значение на 5
my_fun <- function(x, y) {
  if (length(x) != length(y))
    stop('Alarm! length(x) != length(y)')
  x * y
}

# передаем в x строковое значение
my_fun(x = 1:5, y = 3:2)
```

В целом в качестве функций информационных сообщений можно использовать и `print()` / `cat()`. Однако эти группы функций различаются тем, что вывод `print()` / `cat()` направляется в поток стандартного вывода (stdout), а вывод информационных функций - в поток ошибок (stderr). Использование потока stderr выделяет визуально эти сообщения, а, во-вторых, их вывод может использоваться в `tryCatch()`. Еще один нюанс, который стоит иногда принимать во внимание - некоторые пользователи используют `suppressMessages()`, `suppressWarnings()`, которые скрывают вывод `message()` и `warnings()`.

```{r 08-io-16, include=FALSE}
rm(list = ls())
```

## Чтение и запись текстовых файлов
В работе аналитики чаще всего сталкиваются с даными, которые хранятся в простом текстовом формате (txt, разделители строк `\n`, `\r` или `\n\r` ) и основанном на них табличных форматах csv (с разделителями `,` или `;`) или tsv (`\t`). 

### Построчное чтение
При работе с текстами проще всего читать файлы построчно - весь текст импортируется как вектор строковых значений, а элменты этого вектора - блоки текста, ограниченные переносами строк. Это удобно при импорте текстов, в которых есть смысловые блоки, как в художественных и поэтических текстах. Точно также построчное чтение может быть использовано для импорта файлов с ошибками или даже, в особо экзотических слчаях, для чтения скриптов. 

Для построчного чтения обычно используется функция `readLines()` базового пакета или анлогичные ей. С помощью аргументов функции можно указать, сколько необходимо прочитать строк, задать кодировку и что делать, если в файле меньше строк, чем было задано.

Прочитаем первые несколько строк текста песни:

```{r 08-io-17 }
txt_lines <- readLines('./data/oxxy_gorgorod.txt', n = 5)
txt_lines
```

### Чтение текстовых файлов: read.table()
Для чтения текстовых файлов, которые содержат в табличном формате, в базовом R есть функция `read.table()` и функции-обертки, которые обращаются к ней, но с другими значениями аргументов по умолчанию (`read.csv()`, `read.csv2`, `read.delim()`, `read.delim2()`). Табличный формат предполагает наличие строк и колонок в файле, выделенные разделителями строк и полей соответственно, при этом формат файла может быть как txt, так и csv.

Несмотря на всю видимую простоту, при импорте табличных форматов можно столкнуться с очень большим количеством нетривиальных проблем. В немалой части это можно назвать следствием их широкой распространенности - практически все современые текстовые процессоры умеют работать с csv-файлами, экспорт из баз данных также нередко делается в csv. Ко всему прочему, текстовые форматы хорошо сжимаются при архивации. 

К наиболее частым сложностям, которые возникают при импорте текстовых файлов можно отнести следующие:

- неожиданные разделители (например, экспорт из MS Excel в csv создает фай с разделителем `;`)
- лишние или пропущенные разделители строк или колонок (`\t\t` вместо `\t`), что создает разное количество колонок в таблице
- несоответствие файла расширению или вообще отсутствие расширения
- нестандартные кодировки, в том числе проблемы их импорта при работе в Windows
- наличие embedded nuls (`\0`) или метки порядка байтов (bite order marks, BOM)
- наличие символов `""""`, `////` и прочих технических символов
- мета-данные (запись о дате и источнике данных) в первых строках файла

Большинство этих наюнсов решается при настройке параметров импорта с помощью аргументов функций импорта (т.е., настройки по умолчанию не справляются). В частности, в функциях чтения таблиц можно задать разделители полей и десятичные разделители (`sep` и `dec`), кодировку файла и отображения, обработку пустых строк и т.д. Некоторые проблемы, например, импорт данных с embedded nuls постепенно решаются в новых версиях функций и пакетов. Помимо этих аргументов также очень полезны аргументы, которые позволяют прямо указать, сколько строк импортировать (или пропустить от начала), какие типы данных в колонках и какие колонки стоит пропустить, а также - надо ли конвертировать в факторы строковые значения.

Рассмотрим сложный пример, когда в txt-файле находятся табличные данные, при этом кодировка файла отличается от распространенных (`UTF-16`), а также в качестве десятичного разделителя используется `,`. Вот так выглядит файл при печати в терминале:

```{bash 08-io-18, eval=FALSE}
cat ./data/txt_example.txt
```

```
## ��▒>4>4@        ▒>4><   08<5=>20=85     @>872>48B5;L    #?0:    5AOF
## 69500044        008560521       &▒  . 10        ! <1% - 2AB@8O  4       5
## 69500044        745621  &▒  . 10        ! <1% - 2AB@8O  4       5
## 69500300        69506432458     ▒! " 100 N20    (@5O 9D !05=A87 2B. 4   1       5
## 69500346        695089466518    &▒ ▒▒ " 25 N50 ▒!▒      =65@>-!C465=A:89 %$,    3       5
## 69500268        69504851543     $▒"! !  #!▒▒"+ !2 $/ 2 N20 ▒ ! !▒       ▒ ! !▒▒! -      1       5
## 69500009        69506584554      ▒ !.  ▒. /!▒'-▒ !"&+ ! ',▒ % ▒-#, @.6  "#! - -"        1       5
## 69500058        86600383        ".. N10 $ !" "  $ !" "  10      5
## 69500147        41200521        &▒  . 10        ! <1% - 2AB@8O  4       5
## 69500147        05860521        &▒  . 10        ! <1% - 2AB@8O  4       5
## 69500268        00000927        ▒"".. 20 N28    545>=  8EB5@    2       5

```

При желании можно распознать заголовки и разделители колонок (табуляция). Тем не менее, файл в таком виде не годится для работы. После некоторого перебора типов кодировок выяснилось, что файл представлен в кодировке `UTF-16`. Зададим все аргументы для корректного импорта:

```{r 08-io-19 }
path <- './data/txt_example.txt'
txt_data <- read.table(path, header = TRUE, fileEncoding = 'UTF-16', sep = '\t', dec = ',')
```

Посмотрим на файл и структуру данных. Как мы видим, весь файл импортирован как таблица, а текстовые данные были сконвертированы в факторы, так как у `read.table()` аргумент stringsAsFactors берет значения из настроек сессии (по умолчанию TRUE):

```{r 08-io-20 }
txt_data
str(txt_data)
```

К наиболее трудным проблемам до недавнего времени можно было отнести наличие embedded nuls в тексте, так как это требовало предобработки в bash. Другая проблема - наличие сдвоенных разделителей полей (например, `\t\t`) в файлах с большим количеством пропусков. В таких файлах нельзя заменить сдвоенный разделитель на одинарный, так как неизвестно, чем является этот разделитель - ошибкой файла, или же эти два разделителя ограничивают пустую ячейку, которая будет заполнена `NA` при импорте. К сожалению, эта проблема вряд ли может быть решена простым путем.

Из других не очень очевидных нюансов стоит отметить, что функция `read.table()` удобна, так как обладает большим набором аргументов, а также устойчива к некоторым ошибкам в данных. Однако импорт данных с ее помощью весьма нетороплив, что ощутимо сказывается при импорте больших таблиц. Поэтому лучше использовать аналогичные функции других пакетов, в частности, `data.table::fread()`.

```{r 08-io-21, eval=FALSE}
path <- './data/csv_example.csv'
# x <- read_excel("./obl1/extr'version.xls", sheet = 1L)
# setDT(x)

x <- read.table(path, header = TRUE, sep = ',', dec = '.')

tmp <- tempfile()
fwrite(x, tmp, sep = "\t", dec = ",", eol = "\n", quote = FALSE)
x <- readLines(tmp, encoding = 'UTF-8')
x <- paste(x, collapse = "\n")
x <- gsub("\t+\n", "\n", x)
x <- fread(input = x, sep = "\t", dec = ",", encoding = 'UTF-8')
x
```


### Запись данных в текстовые файлы: cat, writeLines, write.table
Запись даных в текстовые форматы также может вестись как построчно, так и сразу всей таблицей. Для записи построчно обычно используется функция `writeLines()`, в редких случаях - `cat()` (при указании имени файла происходит перенаправление вывода с консоли в файл).

Запишем построчно прочитанные ранее строки и посмотрим в терминале, что получилось:

```{r 08-io-22 }
writeLines(txt_lines, con = './data/lines.txt')
```

```{bash 08-io-23}
cat ./data/lines.txt
```


Запись таблиц происходит аналогичным образом, с помощью функции `write.table()` или ее аналогом в других пакетах (в частности, более быстрый вариант `data.table::fwrite()`). С помощью аргументов можно задать как типы разделитей (строк, полей и десятичные разделители), так и кодировку. Обычно рекомендуется выставлять аргумент `row.names = FALSE`, чтобы в файл не были записаны отдельной колонкой названия (номера) строк.

```{r 08-io-24 }
write.table(txt_data, './data/txt_example2.txt', row.names = FALSE)
```

Смотрим результат. Как мы видим, в отличие от первоначального формата, таблица уже в более читабельной кодировке:
```{bash 08-io-25}
cat ./data/txt_example2.txt
```

```{r 08-io-26, include=FALSE}
rm(list = ls())
```

## Чтение и запись файлов MS Excel
В отличие от простых форматов типа .csv, файлы, созданные в MS Excel импортировать не так просто. Ситуация также осложняется тем, что форматы .xls и .xlsx сильно различаются по внутренней структуре. Часть пакетов, которые обеспечивают взаимодействие с Excel-файлами, требуют установки языка Java (java development kit) в систему и соответствующих R-пакетов (rJava, в частности) - самые часто используемые пакеты тут `XLconnect` и `xlsx`. Тем не менее, в большинстве случаев необходим только прочитать файл, и тут могут быть полезны пакеты пакеты `openxlsx` и `readxl`, не требующие установки jdk. Пакет `openxlsx` к тому же умеет еще и записывать файлы в .xlsx, как `XLconnect`, в том числе и с условным форматированием ячеек.

### чтение файлов
Пакет `readxl`, по наблюдениям, чуть быстрее читает файлы, чем `openxlsx` или пакеты, требующие Java, поэтому рассмотрим здесь его. В целом, функционал пакетов достаточно схож и то, что может `readxl`, практически всегда можно реализовать и в других пакетах, и наоброт.

Основные функции пакета - `read_xls()` для чтения файлов MS Excel, созданных в версиях до MS Excel 2007,  `read_xlsx()` - для чтения файлов, созданных в более современных версиях, также есть обобщающая функция `read_excel()`, которая по расширению файла определяет, какую из этих функций надо использовать. Пакет `readxl` принадлежит к экосистеме `tideverse`, поэтому импортированные таблицы имеют класс `tibble` и `data.frame`. Соответственно, если работать в `data.table`, необходимо их отдельно сконвертировать.

Вот так выглядит исходный файл в MS Excel:
<img src="/home/konhis/Documents/Rprojects/r_textbook/pics/io_xlsx_1.PNG" style="width=80%">
<!-- <img src="C:\Users\Leer\Documents\pRojects\r_textbook\pics\io_xlsx_1.PNG" style="position:absolute;left:10%;"> -->

Импортируем файл:

```{r 08-io-27 }
library(readxl)
# читаем файл
path <- './data/xls_example.xlsx'
xlsx_data <- read_xlsx(path)

str(xlsx_data)
xlsx_data
```

При импорте можно указать тип колонок. Делается это с помощью аргумента `col_types`, в который необходимо передать вектор такой же длины, сколько колонок, состоящий из значений `logical`, `numeric`, `date`, `text` или `list`. К сожалению, в отличие от схожего аргумента `colClasses` в функциях импорта csv/xlsx-файлов (`read.table()`, `read.csv()`, `data.table::fread()`, `openxlsx::read.xlsx` и проч.), в `readxl` названия типов не соответствуют названиям атомарных типов данных в R.

Если для `col_types` указать `NULL` или `guess`, то тип будет выбран на основе анализа минимум 1000 строк (или всех строк, если датасет меньше 1000 строк). Также можно указать вектор типов длиной не по количеству колонок, а только из одного значения, то все колонки будут импортированы в этом типе. Значение `skip` указывает, что эту колонку не надо импортировать.

```{r 08-io-28 }
# читаем файл с указанием типа text для всех колонок
xlsx_data <- read_xlsx(path, col_types = 'text')
xlsx_data
```

Как мы видим, `readxl` обладает рядом особенностей - во-первых, в колонке `price`, если ее импортироватьк ак численную, показаны только целые значения, это сделано сознательно, так как дробные части существенно меньше целых (подробнее см.раздел про `print()`). Но это именно формат отображения таблички, а не реальное округление при импорте. А во-вторых, что важнее, в колонке `item_code` все значения в исходном файле начинаются с двух или трех нулей. И на данный момент, несмотря на то, что эта проблема известна, `readxl` не умеет импортировать строковые значения, которые начинаются с одного или нескольких нулей, типа `0020000559`, он импортирует `20000559` даже при `col_types = 'text'`. Вообще, как оказалось, только функции пакета `XLconnect` способны импортировать данные в таком виде корректно, прочие часто используемые пакеты (`readxl`, `openxlsx`, `xlsx`) ошибаются.

```{r 08-io-29, eval=FALSE, include=FALSE}
# костыль с sprintf()
xlsx_data <- read_xlsx(path)
sapply(xlsx_data[, 'item_code'], function(x) sprintf("%010d", x))

# импорт с помощью openxlsx
openxlsx::read.xlsx(path)

# импорт с помощью XLConnect
XLConnect::readWorksheetFromFile(path, "Sheet1", colTypes = c(rep('character', 2), rep('numeric', 3)))
```

В очень редких случаях случается так, что файл имеет формат `xlsx`, а расширение - `xls`. В таком случае функции импорта `readxl` выдадут ошибку, так как они при чтении файла делают проверку на его расширение. Тут может помочь проверка первых символов каждого файла - у xlsx-файлов первые четыре символа это `PK\003\004` и последующая смена расширения файла:
```{r 08-io-30 }
readChar(path, nchars = 4L, useBytes = TRUE)
```

### частичное чтение файла
Большинство xlsx-файлов содержит несколько непустых листов. По умолчанию функции импорта читают только первый лист, остальные же игнорируются. Пакеты типа `XLConnect` могут читать весь файл в отдельный объект. Для чтения названий листов xlsx-файла можно воспльзоваться функцией `readxl::excel_sheets()` и полученный вектор потом циклом или через `lapply()` передать в функцию импорта:

```{r 08-io-31 }
# читаем список листов файла
sheets <- readxl::excel_sheets(path)
sheets

# читаем все листы в список и смотрим структуру
file_str <- lapply(sheets, function(x) read_xlsx(path, sheet = x))
str(file_str)
```

В некоторых случаях требуется импортировать только определенный диапазон ячеек со всего листа - например, когда на созданном вручную листе есть и таблица с данными, и графики, и дополнительные материалы. Для чтения определенной ячейки или диапазона ячеек используют аргумент `range`, в котором в строковом виде указывают диапазон ячеек в Excel-координатах (буквы для колонок и цифры для строк). К сожалению, на данный момент нельзя указать сразу несколько диапазонов. Во-вторых, в прочитанном диапазоне, если не указать обратное, первая строка будет по умолчанию интерпретироваться как строка заголовка. В результате приходится либо прямо задавать названия колонок, либо указывать, что заголовка нет:

```{r 08-io-32 }
read_xlsx(path, range = 'A5:B6', col_names = c('company', 'item_code'))
```

### Сохранение excel-файлов
С помощью пакета `readxl` нельзя сохранять файлы, для этого приходится обращаться к пакетам `openxlsx` или `XLconnect`. `openxlsx`, на наш взгляд, предпочтительнее, так как не требует установки Java, а так же имеет возможность сохранения excel-файлов с условным форматированием таблиц.

При импорте файла с помощью пакета `openxlsx` можно импортировать все листы сразу, в один объект класса `Workbook`.

```{r 08-io-33 }
library(openxlsx)
xlsx_data <- loadWorkbook(path)
class(xlsx_data)
```


Функция `conditionalFormatting` задает правила, условия и стили условного форматирования ячеек в файле. В отличие от большинства других функций в R, она реализована так, что изменение происходит через изменение объекта, нет необходимости перезаписывать импортированный `Workbook`. В аргументах функции указывается область, к которой должно быть применено условное форматирование (`sheet`, `cols`, `rows`), а так же правила и цветовые схемы (`type` и `style`).

```{r 08-io-34, warning=FALSE}
# задаем правило условного форматирования - градиент от 'lightskyblue2' до 'steelblue3' по значениям в колонке 'price' на первом листе.
conditionalFormatting(xlsx_data, sheet = 1, cols = 5, rows = 2:8, type = 'colorScale', style = c('lightskyblue2', 'steelblue3'))
```

Помимо условного форматирования в excel-файл также можно добавлять свои таблицы и записывать их на отдельные листы и даже на отдельные ячейки в уже существующих листах. Добавим первые шесть строк таблицы `iris` на первый лист, ниже уже существующей таблицы. После применения правил условного форматирования и добавления таблицы на лист сохраняем модифицированный объект в файл.

```{r 08-io-35 }
# добавляем таблицу на 10 и следующие строки первого листа
writeDataTable(xlsx_data, sheet = 1, x = head(iris), startRow = 10, tableStyle = 'none', withFilter = FALSE)

# сохраняем
saveWorkbook(xlsx_data, file = './data/xls_example2.xlsx', overwrite = TRUE)
```

Вот так выглядит файл после сохранения:
<img src="/home/konhis/Documents/Rprojects/r_textbook/pics/io_xlsx_2.PNG" style="width=80%">

```{r 08-io-36, include=FALSE}
rm(list = ls())
```


## Чтение и запись файлов SPSS
В России в академической среде очень распространен SPSS, пакет для анализа данных в социальных науках. Особенно активно им пользуются психологи и социологи, для которых это до сих пор практически стандарт для хранения данных, а так же инструмент первого выбора при анализе. Впрочем, ряд ограничений (высокая стоимость, ограниченный набор методов, своеобразный синтаксис) приводят к тому, что исследователи постепенно переходят на R и/или Python.

### Чтение файлов SPSS
Для импорта файлов SPSS (.sav) обычно используют функции какого-либо из двух пакетов - `foreign::read.spss()`, который идет в базовом наборе пакетов R, а так же `haven::read_spss()`, авторства Хэдли Викхэма.

Исходный файл имеет такую структуру (скриншот из SPSS Output):
<img src="/home/konhis/Documents/Rprojects/r_textbook/pics/io_spss_1.PNG" style="width=80%">

### foreign::read.spss()
Читаем файл, сразу с указанием необходимости перекодировки в кодировку локали (аргумент `reencode`) и выводим на печать.

```{r 08-io-37 }
library(foreign)
path <- './data/spss_example.sav'
spss_data <- read.spss(file = path, reencode = TRUE)
```

Первое, на что надо обратить внимание - то, что в колонке `var3` есть значение `4`, для которого нет заданной метки. Вторая важная деталь - для метки `отказ от ответа` есть два разных численных кода, что также указывается в предупреждении.

В результате такого импорта мы получаем список с достаточно сложной структурой и большим количеством атрибутов. Если посмотреть на содержание, то видно, что для `var3` метки значений импортированы как факторы. При этом вторая метка `999 = отказ от ответа` импортирована по правилу  `paste0(label, duplicated.value.labels.infix, level)`, где `duplicated.value.labels.infix = '_duplicated_'` по умолчанию. В атрибутах хранятся именованные векторы для меток значений и метки переменных (`label.table` и `variable.labels`), а также тип указания пропущенных значений (одно, несколько, диапазон) и сама метка пропущенного значения (`missings`).

```{r 08-io-38 }
spss_data
```

Для того, чтобы прочитать файл в привычный табличный вид, а так же учесть выданные предупрежедения, необходимо воспользоваться рядом дополнительных аргументов. Во-первых, аргумент `to.data.frame = TRUE` позволяет нам получить данные в виде `data.frame` без каких-либо дополнительных конверсий, к тому же при импорте будут применены правила для указания пользовательских пропусков (`9999` для `NA`-значений, как и задано в файле). Второй полезный аргумент `use.value.labels = FALSE` указывает, что в результате импорта надо указывать не метки значений, а сами значения. Таким образом данные из колонки `var3` будут импортированы как числа, соответственно, метка `отказ от ответа`для значений `99` и `999` не будет вызывать конфликта при формировании уровней фактора.

```{r 08-io-39 }
spss_data <- read.spss(
  file = path,
  to.data.frame = TRUE,
  use.value.labels = FALSE,
  reencode = TRUE
)
spss_data
```

Несмотря на то, что импорт данных в табличном виде удобен, таким образом теряется ощутимое количество информации. Тем не менее, наиболее часто используемые метки переменных все же сохранены:
```{r 08-io-40 }
attributes(spss_data)
```

### haven::read_sav()
Функции `read_sav()` и `read_spss()` пакета `haven` обладают схожим функционалом при меньшем количестве настроек. При этом эти функции несколько быстрее `foreign::read.spss()`, а так же не имеют проблем с длинными строками. В результате импорта получается tibble-таблица (так как `haven` принадлежит экосистеме `tidyverse`).
```{r 08-io-41 }
library(haven)
spss_data <- read_sav(path)
spss_data
```

Функция не имеет настроек, как импортировать значения, для которых заданы метки, и в таблице представлены численные значения. При необходимости получить значения метки переменных или значений необходимо идти в атрибуты колонок таблицы:
```{r 08-io-42 }
str(spss_data)
```

### Запись файлов SPSS
Для сохранения данных в SPSS-формате используется функция `write_sav()` пакета `haven`. Помимо собственно значений, можно так же указать текстовую метку создаваемой переменной, а так же формат хранения (количество знаков для целой и десятичной частей числа).
Создадим две переменных, численную и строковую:

```{r 08-io-43 }
# создаем численную переменную
spss_data$var4 <- sample(nrow(spss_data))
attr(spss_data$var4, 'label') <- 'новая численная переменная'
attr(spss_data$var4, 'format.spss') <- 'F8.2'

# создаем строковую переменную
spss_data$var5 <- month.abb[1:nrow(spss_data)]
attr(spss_data$var5, 'label') <- 'новая строковая переменная'
attr(spss_data$var5, 'format.spss') <- 'A8'
```

Для создания переменуй, в которой используются метки значений (в том числе и пользовательские метки для пропущенных значений) необходимо использовать функцию `labelled_spss()`. Создадим переменную из нулей и единиц, с метками `Нет` и `Да` соответственно. Так же укажем, что `9999` используется для обозначения пропущенных значений (за это отвечают аргументы `na_values` и `na_range`).

```{r 08-io-44 }
# создаем вектор
spss_data$var6 <- sample(c(0, 1), nrow(spss_data), replace = TRUE)

# задаем формат числа
attr(spss_data$var6, 'format.spss') <- 'F1.0'

# задаем метки с помощью именованного вектора в labels
spss_data$var6 <- labelled_spss(
  spss_data$var6,
  na_values = 9999,
  labels = c('Нет' = 0, 'Да' = 1),
  label = 'новая переменная с метками'
)
```

Из-за того, что при импорте колонки `var3` пользовательская метка пропуска была заменена на `NA`, надо также ее указать, заодно зададим новую метку для значения 4:

```{r 08-io-45 }
# корректируем метки значений в var3
var3_labels <- c(attr(spss_data$var3, 'labels'), 'новая метка' = 4)
var3_labels <- sort(var3_labels)

spss_data$var3 <- labelled_spss(
  spss_data$var3,
  na_values = 9999,
  labels = var3_labels,
  label = 'Образование'
)

# сохраняем все в файл
write_sav(spss_data, './data/spss_example2.sav')
```

Структура обновленного файла:

```{r 08-io-46, include=FALSE}
rm(list = ls())
```

## Чтение и запись JSON
Json-файлы можно парсить как простые файлы с строками, однако эффективнее использовать пакет `jsonlite`, в котором присутствуют функции как чтения, так и записи объектов в json-виде. 

Для чтения обычно используют функцию `fromJSON()`, а некоторых редких случаях - `stream_in()`, которая на вход принимает файлы, соединения или ссылки на файл в njson-формате. Вот так выглядит json-файл примера (для простоты чтения здесь он представлен в pretty-формате, в реальности это, конечно же, должна быть одна строка):

```{bash 08-io-47}
cat ./data/json_example.json
```

Функция `fromJSON()` по умолчанию старается привести результат к табличному виду. В большинстве случаев это, к сожалению, невозможно. В частности, тогда, когда присутствует несколько вложенных массивов разной длины. Ключ для вложенного массива используется как префикс в названии колонки, полученной из массива:

```{r 08-io-48 }
library(jsonlite)
path <- './data/json_example.json'
json_parsed <- fromJSON(path)
json_parsed
```

Запись объектов в json-формате осуществляется с помощью `toJSON()` или с помощью `stream_out()`. При этом надо учитывать, что при прямой записи с помощью `toJSON()` требуется указать значения большого количества аргументов, поэтому можно прибегнуть к простому трюку - сначала создать из таблицы json-объектс помощью `toJSON()`, а результат записать в файл построчно функцией `writeLines()`:

```{r 08-io-49 }
json_parsed$spouse <- c('Sif', 'Sigyn')

writeLines(toJSON(json_parsed), con = './data/json_example2.json')
```

Смотрим результат, он должен быть одной строкой:
```{bash 08-io-50}
cat ./data/json_example2.json
```

```{r 08-io-51, include=FALSE}
rm(list = ls())
```

## Чтение и запись XML/HTML
Для парсинга данных в XML формате обычно используют один из двух пакетов, `XML` и `xml2` - они в целом схожи по функционалу, несмотря на то, что `xml2` появился чуть ли не на 15 лет позже и во многом вдохновлен пакетом `XML`. Оба пакета регулярно обновляются и, в целом, взаимозаменяемы. Здесь мы рассматриваем `xml2`, в немалой части из-за того, что в пакете `xml2` для навигации по нодам дерева разметки и для извлечения элементов и атрибутов используется язык `XPath` (в `XML` обращаться к нодам можно через оператор `[[`). Так как XML и html схожи по организации, то логика парсинга xml-данных может быть легко перенесена на html-разметку и, соответственно, скрапинг web-страниц. Собственно, пакет `rvest`, который используется для скрапинга, также авторства Хэдли Викхема, как и `xml2`, и, по сути, является оберткой над `xml2`.

Рассмотрим сложный кейс - xml-файл, в котором есть вложенные массивы и пропущенные значения. Вот так выглядит импортируемый файл:

```{bash 08-io-52}
cat ./data/xml_example.xml
```

Для обхода нод и выделения необходимых элементов можно воспользоваться функцией `xml_find_all()`, однако у нее есть большой минус - в случае пропущенных данных пропущенные значения будут заполнены последними не-NA значениями. Поэтому, для того, чтобы учесть наличие вложенных элементов и пропусков, необходимо перебирать одинаковые по структуре блоки данных и указывать необходимые элементы с помощью XPath-путей. Для того, чтобы в пути указать номер блока, мы использовали функцию `glue::glue()`, более удобный аналог `paste()`.

При таком процессе обработки функция `xml_find_first()` отдает первую встреченную ноду по указанному пути, которую дополнительно надо сконвертировать в текст с помощью функции `xml_text()`. Для численных значений, если бы они были, пришлось бы использовать `xml_double()` или `xml_integer()`.

```{r 08-io-53 }
# подключаем библиотеку и импортируем файл
library(xml2)
library(glue)
path <- './data/xml_example.xml'
xml_data <- read_xml(path)

# считаем количество блоков по персонажам Эдды
n_chars <- xml_length(xml_data)

# итерируемся по блокам, номер блока указываем в XPath-пути
xml_data_parsed <- lapply(seq_len(n_chars), function(x) {
  data.frame(
    character = xml_text(xml_find_first(xml_data, glue('//character[{x}]/name'))),
    father = xml_text(xml_find_first(xml_data, glue('//character[{x}]/*/father/name'))),
    father_weapon = xml_text(xml_find_first(xml_data, glue('//character[{x}]/*/father/weapon'))),
    mother = xml_text(xml_find_first(xml_data, glue('//character[{x}]/*/mother/name'))),
    weapon = xml_text(xml_find_first(xml_data, glue('//character[{x}]/weapon')))
  )
})

# собираем список таблиц в одну общую таблицу
xml_data_parsed <- do.call(rbind, xml_data_parsed)
xml_data_parsed
```

Для сравнения, какой получается результат при прямолинейном использовании `xml_find_all()` или `XML::xmlToDataFrame()` - в первом случае некорректно обрабатываются пропуски, во втором - значения вложенных элементов оказываются слиты в одну строку и также не очень корректно обрабатываются пропуски:

```{r 08-io-54 }
# при использовании xml_find_all() вместо обхода по блокам и xml_find_first()
data.frame(
    character = xml_text(xml_find_all(xml_data, '//character/name')),
    father = xml_text(xml_find_all(xml_data, '//character/parents/father/name')),
    father_weapon = xml_text(xml_find_all(xml_data, '//character/parents/father/weapon')),
    mother = xml_text(xml_find_all(xml_data, '//character/parents/mother/name')),
    weapon = xml_text(xml_find_all(xml_data, '//character/weapon'))
)

# при использовании xmlToDataFrame() пакета xml
XML::xmlToDataFrame(XML::xmlParse(path))
```

```{r 08-io-55, eval=FALSE, include=FALSE}
library(XML)
xml_data_parsed <- getNodeSet(
  doc = xmlParse(path),
  path = "/edda/character",
  fun = function(node) {
  data.frame(
    character = xmlValue(node[["name"]]),
    father = xmlValue(node[["parents"]][["father"]][["name"]]),
    father_weapon = xmlValue(node[["parents"]][["father"]][["weapon"]]),
    mother = xmlValue(node[["parents"]][["mother"]][["name"]]),
    weapon = xmlValue(node[["weapon"]])
  )
})
xml_data_parsed <- do.call(rbind, xml_data_parsed)
xml_data_parsed

```

```{r 08-io-56, include=FALSE}
rm(list = ls())
```

## Запись и чтение R-объектов: RData, RDS
В том случае, когда необходимо сохранить на диск какой-нибудь R-объект, например, регрессионную модель, проще всего воспользоваться один из нативных форматов, .Rds или .RData (Rda). Оба формата создаются через обращение к функции сериализации `serialize()`.

Для сохранения в формат .Rds используется функция `saveRDS()`. Этот формат используется для сохранения единичных R-объектов, притом, можно указать алгоритм сжатия (по умолчанию `gzip`, а также `bzip2``xz`):

```{r 08-io-57 }
# создаем объект и смотрим его размер в байтах
x <- rnorm(1e6)
object.size(x)

# сохраняем в rds
saveRDS(x, file = './data/rds_example.rds')
```

Смотрим размер результата в терминале:
```{bash 08-io-58}
wc -c ./data/rds_example.rds
```

Для сохранения нескольких объектов можно использовать функцию `save()`, и сохранять объекты в файл с расширением .RData или .Rda. При сохранении данные также будут архивированы с помощью выбранного алгоритма. Функция `save.image()` - аналог функции `save()`, в которой в список объектов передан список объектов глобального окружения с их именами (`ls(all.names = TRUE)`). 
Основное отличие .RData от .Rds - с помощью первого можно сохранить несколько объектов, а с помощью .Rds только один. 

Создадим и проверим, что у нас в рабочем окружении два объекта. Сохраним:
```{r 08-io-59 }
# создаем x и y, смотрим объекты глобального окружения
x <- rnorm(100)
y <- runif(100)
ls()

# сохраняем
save(list = c('x', 'y'), file = './data/rda_example.RData')
```


Импорт данных из форматов .Rds и .RData осуществляется двумя функциями - `readRDS()` и `load()` соответственно. Тем не менее, есть одно существенное различие - функция `readRDS()` по использованию похожа на все остальные функции импорта, т.е., результат ее выполнения может быть записан как новый объект (связан с новым именем). Загрузка данных из .RData с помощью `load()` фактически восстанавливает в рабочем окружении сохраненные объекты (либо в специально указанном окружении). И если результат `load()` записывать в новый объект, то в этом объекте будут только названия объектов, сохраненных в .RData:

```{r 08-io-60 }
# очистим окружение для наглядности
rm(list = ls())

# прочитаем данные из .RData и .RDS
load('./data/rda_example.RData')
rda_data <- load('./data/rda_example.RData')
rds_data <- readRDS('./data/rds_example.rds')

# смотрим объекты окружения и их классы
ls()
sapply(ls(), function(x) class(get(x)))

# отдельно смотрим структуру объекта rda_data
str(rda_data)
```


```{r 08-io-61, include=FALSE}
rm(list = ls())
```
