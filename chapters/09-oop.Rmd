---
title: "OOP"
author: "Ph.A.Upravitelev"
date: '`r Sys.Date()`'
output: 
  html_document:
    toc: true
---

# Объектно-ориентированное программирование

<!-- ЗДЕСЬ НАДО НАПИСАТЬ, ЧТО ТАКОЕ ООП В ФУНКЦИОНАЛЬНОМ ЯЗЫКЕ -->
<!-- ООП и ФП решают одну и ту же задачу - задать таблицу "типы/функции" разными способами: по строкам или по столбцам.  -->
<!-- ООП упрощает добавление типа: просто определяешь один новый класс и полагаешься на полиморфизм. А чтобы добавить функцию, придется менять все классы. -->
<!-- ФП, напротив, упрощает добавление функции, но если появляется новый тип, с которым функции должны работать - изволь поправить все функции. -->

## Системы ООП в R

R - в первую очередь функциональный язык, однако представление функций как объектов первого класса и присущая этому подходу гибкость позволяют производить объектно-ориентированное программирование и разными путями связывать функции и объекты (создавать методы классов).

Как следствие, в R в разное время было реализовано несколько разных моделей ООП. Если считать все экспериментальные (`R5`, `mutatr`), дублирующиеся по идеологии (`ReferenceClasses`) или просто заброшенные системы (`OOP`, `proto`, `R.oo`), то можно насчитать порядка девяти штук минимум. Из этих девяти хоть сколько-нибудь активно используются три, еще одна, `proto`, в свое время повлияла на конструкцию пакета `ggplot2`. 

Модели ООП, которые чаще всего можно встретить в настоящее время:

- S3: самая широко используемая модель в R, в том числе и в base R. Впервые была имплементирована в третьей версии языка S в 1988 году (потому и S3). Весьма минималистична и, прямо говоря, мало похожа на то, что обычно понимают под ООП.

- S4: также, как и S3, пришла из языка S, только уже четвертой версии, в 1998 году. Во многом очень похожа на S3, однако уже более требовательна к разработчику - включает в себя формальные определения классов, проверку типов, наследование и инкапсуляцию, множественную диспетчеризацию (мультиметоды). Еще одна из особенностей этой модели ООП - одни и те же S4-классы могут использоваться в разных пакетах, что активно применяется в экосистеме Bioconductor, в то время как S3-классы обычно характерлы либо для base R, либо для одного конкретного пакета. Как и S3, поддерживается в base R. 

- R6: повторяет и развивает модель `ReferenceClasses`, которую на заре появления иногда называли `R5` (хотя сейчас это разные системы). Для использования `R6` необходимо установить одноименный пакет, так как в base R эта модель не используется (в отличие от `ReferenceClasses`). В целом, `R6` больше всего похожа на классическое ООП, как, например, в Java или Python - есть методы объектов, публичные и приватные методы, мутабельность объектов.

## Базовые типы

Система объектов в R иерархична - в основе лежат так называемые базовые типы данных (fundamental data types), из которых создаются S3 и S4 классы. Модель R6, в свою очередь, является расширением и творческим переосмыслением S3-классов. 

Так как R является выскоуровневой надстройкой над языком С, то все базовые типы данных R на уровне C могут быть соотнесены с определенным подтипом SEXPTYPE общего типа SEXP (symbolic expression). Впрочем, если говорить точнее, то все значения R объектов являются C-структурами (нодами), где заголовок содержит описание типа и флаги для сборщика мусора и дебага, указатели на атрибуты ноды и на соседние ноды, а также собственно значения (указатели на блоки в памяти).

Полный список типов SEXPTYPE можно посмотреть в коде R, в файле `Rinternals.h`. Всего возможно до 32 типов (так как кодируются пятью битами в заголовке), при этом их порядок фиксирован и типы под номерами 12 и 13 были исключены еще на ранних этапах становления R. Пользователи в работе сталкиваются только с некоторыми из базовых типов, прочие либо скрыты, либо вообще не доступны напрямую. 

Как можно увидеть из таблицы, все базовые типы условно можно разделить на несколько групп - векторы и списки, функции, окружения, тип для S4-классов, лексические объекты, некоторые технические типы для работы с сборщиком мусора. Еще несколько типов, несмотря на то, что присутствуют в списке, весьма редки в практике (WEAKREFSXP, EXTPTRSXP и проч.).

|  SEXPTYPE  | enum | комментарий | интерпретация |
|------------|------|-------------|---------------|
| NILSXP	   |  0	  | nil = NULL  |NULL, объект без данных |
| SYMSXP	   |  1	  | symbols | символьная запись, которая связана с каким-то значением, в общем виде - название объекта | 
| LISTSXP	   |  2	  | lists of dotted pairs | список типа pairlist |
| CLOSXP	   |  3	  | closures | функции |
| ENVSXP	   |  4	  | environments | окружения |
| PROMSXP	   |  5	  | promises: [un]evaluated closure arguments | promises, обещания - окружение аргументов функции |
| LANGSXP	   |  6	  | language constructs (special lists) | calls, вызовы функции |
| SPECIALSXP |  7	  | special forms | внутренние функции, .Internal |
| BUILTINSXP |  8	  | builtin non-special forms | функции-примитивы, .Primitive |
| CHARSXP	   |  9	  | "scalar" string type (internal only)| указатели на уникальные строковые записи, которые могут использоваться в разных строковых векторах (STRSXP) | 
| LGLSXP	   | 10	  | logical vectors | логические значения |
| INTSXP	   | 13	  | integer vectors | целые числа |
| REALSXP	   | 14	  | real variables | действительные числа  |
| CPLXSXP	   | 15	  | complex variables | комплексные числа |
| STRSXP	   | 16	  | string vectors | строковые значения, набор указателей на CHARSXP |
| DOTSXP	   | 17	  | dot-dot-dot object | объект `...` |
| ANYSXP	   | 18	  | make "any" args work | используется на уровне С, когда нужна проверка, что тип объекта корректен | 
| VECSXP	   | 19	  | generic vectors | списки, list() |
| EXPRSXP	   | 20	  | expressions vectors | expressions, выражения |
| BCODESXP   | 21   | byte code | используется на уровне С, для объектов в байт-коде, полученных в результате работы компилятора |
| EXTPTRSXP  | 22   | external pointer | используется на уровне С, указатель на внешний объект, наличие которого защищает от сборщика мусора |
| WEAKREFSXP | 23   | weak reference | используется на уровне С, особый список (VECSXP) из четырех элементов - ключ, значение, финализатор и указатель на следующий объект |
| RAWSXP     | 24   | raw bytes | значения в побайтовой записи  |
| S4SXP      | 25   | S4, non-vector | тип для S4-классов, которые не отнаследованы от векторов и других базовых типов |
| NEWSXP     | 30   | fresh node created in new page | используется на уровне С для выявления ошибок с памятью и сборщиком мусора, 
| FREESXP    | 31   | node released by GC | используется на уровне С для выявления ошибок с памятью и сборщиком мусора |
| FUNSXP     | 99   | Closure or Builtin or Special | используется на уровне С для выявления ошибок с памятью и сборщиком мусора|

Базовые типы не могут быть названы моделью ООП, с ее характеристиками в виде полиморфизма, наследования и проч. Причиной этого является организация работы с разными типами в C-функциях, где для обработки разных типов реализованы логические ветвления (switch). Создание новых типов или изменение существующего набора тоже вызывает сложности, потому что необходимо актуализировать всю систему обработки разных типов. Правами и ресурсами на это обладают представители R Core Team, однако это весьма редкое событие - из-за высокой трудоемкости и спорной необходимости изменений, и, в какой-то мере, по причине определенного консерватизма команды.

При работе в R объекты базовых типов можно определить по нескольким признакам. Во-первых, это объекты, у которых нет атрибута класса, но есть тип. Функция `class()` в данном случае будет неточна, так как сама по себе является функцией-дженериком и предназначена для работы с S3/S4-классами. Другая особенность - для внутренних типов функция `is.object()` будет возвращать `FALSE`:

```{r 09-oop-1}
x <- c('a', 'b', 'c')
class(x)
attributes(x)
typeof(x)
is.object(x)
```

При желании, можно воспользоваться функциями пакета `pryr`, которые несколько более информативны. Например, `sexp_type()` возвращает соответствующий SEXPTYPE объекта, а `otype()`  - какой системе ООП принадлежит объект (базовый тип или S3/S4/refClass).

```{r 09-oop-2}
x <- rnorm(5)
pryr::sexp_type(x)
pryr::otype(x)
```


## S3

### Обобщенные функции
S3 сложно назвать моделью объектно-ориентированного программирования в привычном многим разработчикам смысле. По сути, основная задача S3, как и S4 - обеспечить параметрический полиморфизм функций. Достигается это путем создания обобщенных (generic) функций, которые при использовании с разными объектами возвращают разный результат. Классический пример здесь - функции `summary()`, `print()` и `plot()`. 

Например, при использовании функции `summary()` с численным вектором мы получим параметры распределения - размах и квартили.
```{r 09-oop-3}
# вектор целых чисел
x <- sample(10, 15, replace = TRUE)
summary(x)
```

А для фактора, для которого размах и квартили неприменимы, функция `summary()` вернет частоту встречаемости значений по уровням:
```{r 09-oop-4}
x_fac <- factor(x)
summary(x_fac)
```

Для таблицы результат будет третьим - статистики по колонкам, в зависимости от того, какого класса колонки в таблице.
```{r 09-oop-5}
x_df <- data.frame(x, x_fac)
summary(x_df)
```

Такое поведение возможно, так как функция `summary()` - обобщающая функция всего множества функций `summary()`, определенных для конкретных классов объектов. Другими словами, это обобщенный метод для большого набора классов, для каждого из которых метод может быть имплементирован по-своему. Диспетчеризация методов происходит по атрибуту класса объекта, метод класса обозначается как `function_name.class_name()`. Особенностью обобщенных функций в S3 является наличие дефолтного метода для случаев, когда метод этого класса не найден, такие функции имеют вид `function_name.default()`.

Список реализаций функции `summary()` для разных классов можно посмотреть с помощью `methods()`:
```{r 09-oop-6}
methods(summary)
```

### Классы объектов
Вся модель объектно-ориентированного программирования S3 стоит на двух ключевых операциях - определение класса и объявление методов (функции) этого класса. Ввиду своей древности и соответствующих периоду разработки требований к пользователям, S3 достаточно слабо регулирует действия пользователя и никак не защищает его от возможной ошибки. В частности, это проявляется в работе с классами - нет формальных методов объявления класса, создать объект нового класса или изменить класс объекта можно простым изменением атрибута `class`. Следует учитывать, что при изменении атрибута класса такде происходит создание нового объекта - меняется его адрес в памяти. При этом при изменении класса объекта формат его хранения и презентации в C-типах останется все так же одним из базовых типов.

```{r 09-oop-7}
x <- 1:7

# смотрим класс и тип объекта x
class(x)
typeof(x)
pryr::otype(x)

# меняем класс объекта x
class(x) <- 'my_class'

# опять смотрим класс и тип объекта
class(x)
typeof(x)
pryr::otype(x)
```


Другой метод, который наиболее явно отражает процесс присвоения класса - явно изменить атрибут объекта `class`. Стоит сказать, что с точки зрения языка R, формулировки "создание экземпляра класса", "присвоение класса" и "изменение атрибута класса" - идентичны по смыслу и взаимозаменяемы.
```{r 09-oop-8}
attr(x, 'class') <- 'my_class_attr'
class(x)
typeof(x)
pryr::otype(x)
```

Несмотря на простоту способа создания экземпляра нового класса через изменение атрибута, чаще используют функцию `structure()`. Эта функция возвращает объект с заданным набором атрибутов, в том числе и атрибутом класса. Как правило, `structure()` используется в различных функциях-конструкторах, возвращающих объекты нового класса. Например, в функции `as.data.frame.integer()` (создание таблицы `data.frame` из вектора целых чисел) есть такая строчка:
```{r 09-oop-9, eval=FALSE}
structure(value, row.names = row.names, class = "data.frame")
```

Создадим экземпляр класса `my_integer` и проверим его класс и тип:
```{r 09-oop-10}
x <- structure(x, class = 'my_integer')
class(x)
typeof(x)
```

При присвоении класса меняется атрибут, но не структура объекта - это, как раз, одно из проявлений вольности S3. Как следствие, если для этого класса определены какие-то функции, то R попробует применить их к этому объекту. Однако если структура объкта иная, то выполнение функции отдаст непредсказуемый результат или вообще завершится ошибкой. Например, если попытаться представить список векторов в виде таблицы (даже если соблюсти требование, чтобы векторы были одной длины), то выбор первой строки таблице возвращает странный результат:
```{r 09-oop-11}
# создадим список
my_list <- list(v1 = 1:3, v2 = letters[1:3])

# присвоим класс data.frame и попробуем выбрать первую строчку
class(my_list) <- 'data.frame'
my_list[1, ]
```

Все это служит иллюстрацией того, создавать настоящий объект нового класса необходимо с использованием соответствующих функций-конструкторов классов. Для `data.frame` это функция-дженерик `as.data.frame()`.

### Мультиклассы

При желании, можно вместо одного значения класса передать вектор значений, в результате объект будет двух и более классов. Например, вектор `с('my_integer', 'my_numeric')`. В результате получим два класса объекта:
```{r 09-oop-12}
x <- sample(10, 15, replace = TRUE)
x <- structure(x, class = c('my_integer', 'my_numeric'))
class(x)
typeof(x)
```

Использование нескольких классов объектов - несколько нетривиальное решение для обычных пользователей R и при недостаточной опытности вполне может приводить к неожиданным результатам. Однако возможность создавать объекты нескольких классов также дает и большую гибкость. В частности, это проявляется в применении обобщенных функций - если для какого-то класса отсутствует определенный метод, возможно, он определен для следующего в списке классов объекта. При этом если у объекта вообще нет класса (что возможно сделать), то будет применен метод класса `default`. 

Классический пример объектов двух классов - таблица класса `data.table`, которая одновременно является объектом класса `data.frame`:
```{r 09-oop-13, message=FALSE}
library(data.table)
my_dt <- as.data.table(mtcars)
class(my_dt)
```

Класс  `data.frame` идет в списке вторым, что дает возможность применять к объектам `data.table` функции, которые были написаны для `data.frame`. Например, выбор всех строк из my_dt (копия `mtcars`), в которых `hp > 250`, будет выглядеть по-разному для `data.table` и для `data.frame`, но даст идентичный результат. И наоборот, использовать методы, определенные для `data.table`, с объектами `data.frame` можно было бы только в случае, если бы последовательность классов объекта была `c('data.frame', 'data.table')`:

```{r 09-oop-14}
# решение методами, определенными для таблиц data.table
my_dt[hp > 250]

# решение методами, определенными для таблиц data.frame
my_dt[my_dt$hp > 250, ]
```

Несмотря на то, что S3 формально не предполагает какую-либо иерархию методов, вполне осмысленно предполагать такую иерархию при перечислении классов при создании мультикласс-объектов. Это позволит более-менее явно конструировать систему методов классов и их взаимодействие. Те же классы `data.table` и `data.frame` вполне удобно рассматривать с точки зрения иерархии, когда `data.frame` - родительский класс, и, как следствие, все, что применимо к `data.frame`, применимо к `data.table`. Но не наоборот.


### Создание обобщенных функций и методов
#### UseMethod()
Допустим, мы хотим создать собственную функцию `my_summary()` для работы с численными векторами. Функция должна будет возвращать те же статистики, что и `summary()`, а также еще и количество наблюдений, стандартное отклонение.

Для создания новых обобщенных функций используется функция `UseMethod()`, в которую первым аргументом передается название обобщенной функции, а вторым, при необходимости - объект, класс которого определит, какую именно функцию надо применить. Впрочем, второй аргумент опционален и его можно пропустить, и тогда необходимая функция будет определена из класса объекта, который будет передан в обобщенную функцию первым аргументом. Если в частных функцию предполагается использовать дополнительные аргументы (например, для округления результатов), то при объявлении обобщающей функции разумно добавить аргумент `...`.
```{r 09-oop-15}
# создаем обобщенную функцию
my_summary <- function(object, ...) {
  UseMethod('my_summary')
}
```

При вызове `UseMethod()` создается новое окружение, в которое копируется текущее окружение, в котором была вызвана функция. Это приводит к нескольким эффектам. Во-первых, нет необходимости передавать все аргументы из списка аргументов обобщенной функции, они будут переданы в функцию класса автоматически. Во-вторых, в функцию класса будут переданы все объекты, которые были созданы или преобразованы до вызова `UseMethod()` в теле функции-дженерика. И в третьих, результаты выражений после вызова `UseMethod()` будут потеряны.

При создании нового окружения в него создаются и/или копируются следующие объекты:

 - значения, переданные в аргументы фунции-дженерика (объект и возможные доп.аргументы)
 - `.Class` - скрытый объект, содержит список классов объекта, создается при вызове функции-дженерика (отсутствует в глобальном окружении)
 - `.Generic` - скрытый объект, содержит название функции-дженерика. Для пользователей может быть полезно при написании групповых дженериков.
 - `.Method` - скрытый объект, содержит название метода класса, который вызывается при вызове функции-дженерика
 - `.GenericCallEnv` и `.GenericDefEnv` - окружения, в которых вызываются функция-дженерика и метод соответственно
 


### Методы пользовательских классов

После того, как функция-дженерик создана, можно создать функции (методы) классов. Для этого небходимо создать обычную функцию, в теле которой будут представлены все необходимые операции. Однако назвать эту функцию необходимо по маске `generic_function_name.class_name()`. Тогда при вызове функции-дженерика c объектом указанного класса будет выполнена именно эта функция. Точка как разделитель названий обобщенной функции и класса зашита в языке. В частности, это одна из причин, почему не следует использовать точки в названиях пользовательских объектов, особенно функций.

```{r 09-oop-16}
# создаем функцию, которая будет применяться к объектам класса my_numeric
my_summary.my_numeric <- function(object, round_digits = 1) {
  stats <- c(
      'Min' = min(object),
      quantile(object),
      'Max' = max(object),
      'NA' = sum(is.na(object)),
      'N_obs' = length(object),
      'sd' = sd(object)
  )
  stats <- round(stats, digits = round_digits)
  stats
}
```

Проверим, как работает созданная пара функции-дженерика и функции для обработки класса `my_numeric`:
```{r 09-oop-17}
# создаем вектор целых чисел
x <- sample(10, 15, replace = TRUE)
summary(x)

# меняем класс объекта на 'my_numeric'
x <- structure(x, class = 'my_numeric')

# вызываем нашу функцию-дженерик
my_summary(x, round_digits = 1)
```


#### Метод для default-класса

Также для пользовательских дженерик-функций можно создавать методы по умолчанию. Эти методы используются для обработки ситуаций, когда для объекта нового класса метод не определен. Логика совершенно идентичная, единственное, в качестве названия класса указывается `default`. Фактически, создается виртуальный класс, к которому обращается обобщающая функция в ситуация, когда не находит метода класса переданного объекта. Сделаем так, чтобы эта функция возвращала параметр, который есть у всех объектов - длину:
```{r 09-oop-18}
# метод по умолчанию
my_summary.default <- function(object) {
  stats <- length(object)
  stats
}
```

Попробуем применить дженерик-функцию `my_summary()` к новому классу, для которого еще не созданы частные методы:
```{r 09-oop-19}
# создаем объект класса my_list
x <- list(e1 = rnorm(5), e2 = letters[1:5], e3 = mean)
x <- structure(x, class = c('my_list'))
str(x)

# смотрим, какие методы обобщены функцией my_summary
methods(my_summary)

# применяем my_summary к объекту класса my_list
my_summary(x)
```

#### NextMethod()
Несколько сложнее ситуации, когда у объекта несколько классов. В таких случаях дженерик-функция перебирает cписок классов объекта до тех пор, пока не найдет класс, для которого объявлена соответствующая функция, обычно это все же первый класс. Например, у нас есть объект, класс которого `my_integer` и второй класс - `my_numeric`. Для класса `my_integer` нет определенных методов. Согласно правилам диспетчеризации методов, для этого объекта должен быть использован метод второго класса, `my_numeric`. Если бы этого метода не было или у объекта был бы только один класс `my_integer`, то использовался бы метод `my_summary.default()`, который мы определили выше.

```{r 09-oop-20}
# создадим класса my_integer
x <- sample(10, 15, replace = TRUE)

# применяем функцию, когда метод не определен
x <- structure(x, class = 'my_integer')
my_summary(x)

# добавляем еще один класс объекту
x <- structure(x, class = c('my_integer', 'my_numeric'))
my_summary(x)
```

Конечно, пользоваться механизмом поиска по списку классов при создании методов можно. Тем не менее, это не очень явное поведение, поэтому лучше воспользоваться функцией `NextMethod()` при определении метода класса, если для этого объекта применимы методы нескольких классов. Фактически это просто указание использовать метод следующего класса в списке:

```{r 09-oop-21}
# создаем метод с помощью NextMethod()
my_summary.my_integer <- function(object, round_digits = 1) {
  NextMethod()
}

# применяем дженерик-функцию
my_summary(x)
```

Функция `NextMethod()` схожа с `UseMethod()` по конструкции, с некоторыми исключениями. В частности, обращается к скрытому объекту `.Class`, который создается при вызове функции-дженерика и хранится в ее окружении. Это означает, что можно менять класс объекта в теле обобщающей функции, хотя такой подход крайне не рекомендуется. Во-вторых, `NextMethod()` создает окружение, в котором выполняется соответствующий метод, и возвращает результат выполнения этого метода.

<!-- #### Правила хорошего тона -->
<!-- ЗДЕСЬ НАДО РАССКАЗАТЬ ПРО ТО, КАК ПРИНЯТО - конструкторы, валидаторы, нейминг, хорошие манеры -->


### Внутренние обобщенные функции и группы
Помимо пользовательских обобщенных функций, в R присутствует определенный набор внутренних (Internal) обобщенных функций, которые могут быть применимы к разным классам объектов. Для всех этих функций-дженериков могут быть написаны самостоятельные пользовательские методы:

 - [, [[, \$, [<-, [[<-, \$<-,
 - length, length<-, dimnames, dimnames<-, dim, dim<-, names, names<-, levels<-,
 - c, unlist, cbind, rbind,
 - as.character, as.complex, as.double, as.integer, as.logical, as.raw, as.vector, is.array, is.matrix, is.na, is.nan, is.numeric, rep, seq.int (дженерик для seq(), int от `internal`), xtfrm

Простейший пример определения метода для внутренней дженерик-функции:
```{r 09-oop-22}
# создаем объект класса my_class
x <- structure(1:7, class = 'my_class')

# создаем метод
length.my_class <- function(object) {
  object * object
}

# применяем internal-дженерик length к объектам разных классов
length(letters[1:5])
length(x)
```

К внутренним обобщенным функциям относятся также так называемые групповые дженерики (groupGenerics). Отличительная особенность этих функций - надо определять всю группу методов для нового класса, в противном случае будут работать только определенные методы. Всего существует четыре группы таких функций, собственные группы добавить нельзя:

 - Math (математические функции): abs, sign, sqrt, floor, ceiling, trunc, round, signif, exp, log, expm1, log1p, cos, sin, tan, cospi, sinpi, tanpi, acos, asin, atan, cosh, sinh, tanh, acosh, asinh, atanh, lgamma, gamma, digamma, trigamma, cumsum, cumprod, cummax, cummin
 - Ops (операторы): +, -, *, /, ^, %%, %/%, &, |, !, ==, !=, <, <=, >=, >
 - Summary (описательные статистики): all, any, sum, prod, min, max, range
 - Complex (для комплексных чисел): Arg, Conj, Im, Mod, Re

Попробуем определить группу `Summary` для класса `my_class`, но только с двумя функциями из всего списка функций группы. Посмотрим, как с объектами класса `my_class` будут работать другие функции, которые не были определены для класса:
```{r 09-oop-23}
# создаем объект класса my_class
x <- structure(1:7, class = 'my_class')

# меняем дженерик-группу Summary
Summary.my_class <- function(object, ...) {
  switch(.Generic,
         min = 'min object',
         max = 'max object'
  )
}
min(x)
max(x)

# не определены для класса
sum(x)
prod(x)
```

Одна из особенностей внутренних функций-дженериков - если нет определенного метода, то они ориентируются не на атрибут класса объекта, который, а на тип объекта. В результате можно не реализовывать метод по умолчанию, им будет базовый метод, который применим для этого типа данных. Например, у нас есть вектор численных значений с классом `my_class`, для которого не определена функция сложения (`+`). Однако операция сложения все равно выполняется и результатом будет объект того же класса, что и исходный объект.
```{r 09-oop-24}
# класс объекта
class(x)

# результат сложения
x + 2
```


### Диспетчеризация методов
Выше уже говорилось об процессе определения метода в зависимости от класса объекта, однако кажется полезным проговорить это еще раз, отдельно, от простого кейса к более сложному.

Самый простой часто встречающийся случай - есть обобщающая функция `generic_function_name`, и есть какое-то количество методов для разных классов, которые обобщены этой функцией. В таком ситуации происходит поиск соответствующего метода по названию класса. Классический примеры с `summary(x)`, когда x может быть численным вектором, фактором, таблицей, lm-моделью и так далее.

Иногда для какого-то класса нет соответствующего метода. В таком случае вызывается метод по умолчанию, `generic_function_name.default()`. Если же метода по умолчанию для какого-то объекта нет, то для пользовательских функций будет возвращена ошибка. Внутренние функции в таких ситуациях ориентируются на базовый тип объекта.

Более сложный кейс - когда метод обязательно предполагает два аргумента. Фактически, это все методы группы Ops внутренних дженерик-функций. Для соблюдения однородности вывода при разном порядке аргументов необходимо определить метод для каждого аргумента и исходя из того, совпадают методы обоих аргументов, прийти к одному из исходов:

- оба объекта одного класса: применяется определенный для класса метод

- оба объекта разных классов: используется внутренний метод для каждого класса, а пользователю выводится предупреждение

- один из методов является внутренним методом: используется метод второго аргумента


<!-- ### Получение информации об S3-объектах -->
<!-- Определить класс объекта можно с помощью функции `class()`.  -->
<!-- ```{r} -->
<!-- class(mtcars) -->
<!-- ``` -->


<!-- Проверить, является ли объект объектом системы S3 (фактически, имеет ли атрибут класса) можно с помощью функции `is.object()`. Правда, тут есть некоторое легаси - в языке S, от которого унаследованы многие конструкции, часть объектов имела собственный класс, без указания этого в атрибутах. Например, `matrix`. Для того, чтобы такие классы воспринимались функцией `is.object()`, необходимо задать им атрибут `oldClass`: -->
<!-- ```{r} -->
<!-- # смотрим, есть ли класс у матрицы -->
<!-- x <- matrix(1:9, nrow = 3, ncol = 3) -->
<!-- class(x) -->
<!-- is.object(x) -->

<!-- # задаем старый класс -->
<!-- oldClass(x) <- 'new_matrix' -->
<!-- is.object(x) -->
<!-- ``` -->


<!-- Проверить, является ли объект экземпляром какого-то класса можно с помощью функции `inherits()`, однако если в список классов передать вектор названий классов, то проверка будет на любое вхождение (то есть, если объект хотя бы одного класса из списка, то функция вернет `TRUE`): -->
<!-- ```{r} -->
<!-- inherits(mtcars, 'data.frame') -->
<!-- ``` -->

<!-- Для того, чтобы увидеть все методы, которые обобщены функцией-дженериком, потребуется функция `methods()`: -->
<!-- ```{r} -->
<!-- methods('summary') -->
<!-- ``` -->

<!-- Просмотреть аргументы и тело метода можно как обычным выводом объекта функции на печать, так и более сложно, через `getS3method()` и указание аргументов: -->
<!-- ```{r} -->
<!-- getS3method(f = 'mean', class = 'default') -->
<!-- mean.default -->
<!-- ``` -->



## S4

### Определение класса

Модель ООП S4 была призвана исправить недочеты модели S3, поэтому логично, что одним из ключевых направлений работы стал процесс объявления классов и создание экземпляров классов. 

В отличие от S3, где создание объекта нового класса - это простое присвоение нового значения в атрибут класса, в S4 классы определяются явно, с помощью функции `setClass()`.

Функция `setClass()` имеет несколько аргументов, самые важные из них:

 - `Class`: название нового класса, обычно в `UpperCamelCase` написании.
 
 - `slots`: слоты (поля) класса. По сути это набор переменных, в которых хранятся данные объекта этого класса. В `setClass()` слоты задаются как именованный вектор, парами название слота и тип данных. Названия слотов 'class' / 'Class' запрещены. В том случае, если есть необходимость оставить класс слота неопределенным, можно указать `ANY`. В редких случаях также можно просто указать названия слотов, и тогда для них будет также проставлен класс `ANY`. Если новый класс отнаследован от базового типа или S3-класса, то будет создан также скрытый слот `.Data`.
 
 - `contains`: вектор родительских классов (суперклассов), от которых отнаследован создаваемый класс.
 
 - `prototype`: список значений по умолчанию для слотов. В принципе, это необязательный аргумент и вполне можно либо обойтись без него. Тем не менее, если предполагается, что классом будут пользоваться внешние пользователи (например, в пакете), то рекомендуется задавать значаения слотов по умолчанию.

Пример определения класса (объект `City` можно не создавать и просто вызвать `setClass()`):

```{r 09-oop-25}
City <- setClass(
  Class = 'city', 
  slots = c(
    name = 'character', 
    abb = 'character', 
    population = 'ANY'
  )
)
```

Посмотреть определение класса можно с помощью функций `getClass()` / `getClassDef()`:
```{r 09-oop-26}
getClass('city')
```

Удалить созданный класс можно с помощью `removeClass()`.


### Переопределение класса

При желании можно переопределить класс - то есть, объявить класс с уже существующим названием, но с другой структурой слотов. При этом необходимо помнить, что уже созданные экземпляры класса переопределяемого класса сохранят свою структуру, что может вызвать ошибки.

```{r 09-oop-27, error=TRUE}
# переопределяем класс
setClass(
  Class = 'city', 
  slots = c(extra_slot = 'ANY')
)

# вызываем ранее созданный объект класса city
msk
```

```{r 09-oop-28}
# переопределим класс city обратно
setClass(
  Class = 'city', 
  slots = c(name = 'character', abb = 'character', population = 'ANY')
)
```

### Инстанцирование классов

Создать экземпляр класса можно двумя путями. Первый, чуть более прозрачный и характерный для ООП - с помощью функции `new()`:

```{r 09-oop-29}
msk <- new(Class = 'city', name = 'Moscow', abb = 'Msk')
str(msk)
```

Второй способ использует собственно объект-определение класса, если он был создан при вызове `setClass()`:

```{r 09-oop-30}
msk <- City(name = 'Moscow', abb = 'Msk')
str(msk)
```

Опрделить, к какой модели ООП относится созданный объект, можно все также с помощью с помощью функции `pryr::otype()`:
```{r 09-oop-31}
pryr::otype(msk)
```

Определить S4-класс объекта можно также, как и S3-классы, с помощью функции `class()`. Помимо класса объекта в выводе будет также пакет или окружение, в котором был определен класс. 
```{r 09-oop-32}
class(msk)
```

Проверить, является ли объект экземпляром какого-то определенного класса можно с помощью функции `is()` или `inherits()`:
```{r 09-oop-33}
is(msk, 'city')
inherits(msk, 'city')
```

### Виртуальные классы

В S4 возможны два типа классов - обычные и виртуальные. Виртуальные классы не могут быть инстанцированы, но от них могут быть отнаследованы другие классы. В целом, вирутальные классы нужны для того, чтобы отслеживать иерархию классов и, в результате, сделать более прозрачной диспетчеризацию методов. Примером такого виртуального класса нередко называют результат функции `setClassUnion()`  - объединение двух классов. 

Более простой способ создать виртуальный класс - объявить класс без аргумента `contains`, то есть, создаваемый класс ни от какого другого класса не отнаследован. При попытке создать экземпляр виртуального класса интерпретатор должен вернуть ошибку:

```{r 09-oop-34, error=TRUE}
# определяем класс без contains
setClass('virt')

# пробуем создать экземпляр класса
virt_ex <- new('virt')
```

Проверить, является ли класс виртуальным, можно с помощью функции `isVirtualClass()`. Правда, у этой функции есть одна особенность - она предназначена только для работы с S4-классами. Прочие классы (S3, например) будут также признаны виртуальными:
```{r 09-oop-35}
# проверяем, является ли класс virt виртуальным
isVirtualClass('virt')

# пробуем s3-класс
x <- 'a'
class(x) <- 'my_s3_class'
isVirtualClass('my_s3_class')
```

### Создание S4-классов из S3-классов

В R S3 и S4 модели существуют параллельно. В результате нередки ситуации, когда в работе одновременно используются объекты S3 и S4 классов. В принципе, в механизм диспетчеризации методов заложена процедура обработки S3-классов и базовых классов, однако настоятельно рекомендуется при работе с S4-классами и методами (например, при написании собственного пакета, использующего модель S4) регистрировать S3-классы как S4-классы. 

Для подобной операции используется функция `setOldClass()` (аргумент `S4Class` опционален и указывает соответствующий S4-класс, если он определен):

```{r 09-oop-36, error=TRUE}
# смотрим, есть ли определение класса в S4-модели
getClass('my_s3_class')

# регистрируем класс как S4-класс
setOldClass('my_s3_class')

# еще раз смотрим определение
getClass('my_s3_class')
```

```{r 09-oop-37, echo=FALSE}
# удаляем my_s3_class
removeClass('my_s3_class')
```

При создании пакета `methods` некоторые часто используемые S3-классы были уже зарегистрированы как S4-классы (аналогичная процедура рекомендуется при написании собственных пакетов). Список этих классов можно посмотреть, вызвав скрытый объект `.OldClassesList`. Несколько значений обозначают наследование, от специального класса к более общему:
```{r 09-oop-38}
.OldClassesList[1:3]
```


### Наследование классов
В модели классов S4 реализовано явное наследование и иерархия классов. Если класс отнаследован от какого-то другого класса, то при определении класса с помощью `setClass()` в атрибут `contains` передается название родительского класса (вектор навзаний классов, в случае множественного наследования). Соответственно, классы-потомки наследуют все слоты родительских классов и добавляют свои.

Создадим, например, класс `District`, который будет отнаследован от `City` и который будет описывать административные округи / районы городов. Добавим еще два слота - название и аббревиатуру административного округа:

```{r 09-oop-39}
setClass(
    'district',
    contains = 'city',
    slots = c(district_name = 'character', district_abb = 'character')
  )
getClassDef('district')
```

Создадим экземпляр класса. Как мы видим, у класса в результате получилось пять слотов - два задаются при определении класса и описывают информацию о районе, а три отнаследованы от родительского класса.
```{r 09-oop-40}
vasileostrovsky <-
  new(
    Class = 'district',
    name = 'Saint-Petersburg',
    abb = 'SPb',
    district_name = 'Vasileostrovsky district'
  )
str(vasileostrovsky)
```

Узнать суперкласс какого-либо класса в S4 можно с помощью функции `selectSuperClasses()`. Также можно проверить, является ли какой-либо класс расширением другого класса с помощью функции `extends()`:

```{r 09-oop-41}
# определяем суперкласс класса `district`
selectSuperClasses('district')

# проверяем, является ли класс `city` суперклассом для `district`
extends('district', 'city')

# проверяем, является ли класс `district` суперклассом для `city`
extends('city', 'district')
```

### Преобразование классов

S4-модель предполагает два варианта преобразования классов - преобразование связанных иерархическими отношениями классов (класс-суперкласс) и преобразование в независимые классы. 

Преобразование экземпляра суперкласса в подкласс и наоборот производится с помощью функции `as()`, где в аргументах указывается объект и целевой класс. При этом лишние слоты утрачиваются, а недостающие - не заполняются или заполняются значением по умолчанию (если указано в `prototype` при определении класса).

Преобразуем объект суперкласса `city` в класс `district`. Слоты `district_name` и `district_abb` не содержат никаких данных:
```{r 09-oop-42}
getClass(msk)
as(msk, 'district')
```

Обратно, из класса `district` в суперкласс `city`. Слотов `district_name` и `district_abb` просто нет:
```{r 09-oop-43}
as(vasileostrovsky, 'city')
```

Второй способ преобразования классов - это эксплицитное преобразование, определенное с помощью функции `setAs()`. В аргументах `from` и `to` функции явно указывается, из какого класса в какой необходимо преобразовать объект, а аргументе `def` - собственно процесс преобразования. В аргумент `def` можно передать как отдельно объявленную функцию, так и анонимную. Преобразуем объект `msk` класса `city` в `data.frame`. Простым `as.data.frame()` это, естественно, сделать не получится, поэтому используем `setAs()`.

```{r 09-oop-44}
setAs(from = 'city', to = 'data.frame', def = function(from) {
  res <- list(
    from@name,
    from@abb,
    from@population
  )
  names(res) <- slotNames(from)
  for (i in seq_along(res))
    res[[i]] <- ifelse(is.null(res[[i]]), NA, res[[i]])
  as.data.frame(res, stringsAsFactors = FALSE)
})
```

Функция `setAs()` только определяет процедуру преобразования типов, само же преобразование производится все также с помощью функции `as()`:
```{r 09-oop-45}
msk_df <- as(msk, 'data.frame')
class(msk_df)
msk_df
```

### Обобщенные функции

Обобщенные функции создаются с помощью функции `setGeneric()`. Можно выделить несколько вариантов создания дженериков. Самый простой - когда у нас есть какой-то класс и мы также создали функцию, которая должна работать с этим классом. Как правило, подобное поведение используется, когда нужно перегрузить уже существующую функцию из другого пакета, чтобы она работа с созданным нами классом. В таком случае последовательность действий выглядит следующим образом - мы из уже объявленной функции с нужным нам поведением делаем дженерик (передав название функции в аргемент `name`, первый в списке аргументов). При этом исходная функция становится методом по умолчанию (аналог `default` в S3):

```{r 09-oop-46}
# создадим функцию, которую потом сделаем дженериком
dummy_fun <- function(x) print(class(x))
setGeneric('dummy_fun')

# применяем к разным классам
dummy_fun(iris)
dummy_fun(vasileostrovsky)
```

Далее можно перегрузить эту функцию для какого-нибудь конкретного класса, с помощью `setMethod()`:

```{r 09-oop-47}
setMethod('dummy_fun', 'district', function(x) print(c(x@name, x@abb)))
dummy_fun(iris)
dummy_fun(vasileostrovsky)
```

При этом, строго говоря, `setGeneric()` можно и не вызывать. Достаточно будет указать во время создания метода класса, что какая-то функция должна быть дженериком, и тогда дженерик будет сформирован автоматически. Метод при создании класса будет использоваться для этого класса, а исходная функция - как метод по умолчанию.

```{r 09-oop-48}
from_method <- function(x) class(x)
setMethod('from_method', 'district', definition = function(x) print(x@abb))
class(from_method)
from_method(iris)
from_method(vasileostrovsky)
```

Второй случай - когда у нас нет ранее объявленной или импортированной функции. Тогда можно с помощью `setGeneric()` объявить функцию с целевым поведением (которое будет методом по умолчанию). Созданная функция будет иметь класс `standardGeneric`:
```{r 09-oop-49}
# указываем, что superclass - это функция, возвращающая суперкласс объекта
setGeneric('superclass', function(x) selectSuperClasses(x))
class(superclass)
superclass('district')
```

Третий вариант создания функций-дженериков в S4 модели не предполагает какого-то поведения по умолчанию. В таком подходе в аргументе `name` функции`setGeneric()` указывается название новой функции-дженерика, а в аргументе `def` - анонимная функция, вызывающая `standardGeneric()`. Функция `standardGeneric()` не используется сама по себе (как и `UseMethod()`) и нужна для схожих целей - для диспетчеризации методов.

В примере ниже мы объявляем функцию-дженерик `dummy_fun()` и указываем, что применять ее надо при работе с определенными классами, для которых созданы соответствующие методы (нет умолчаний):

```{r 09-oop-50, error=TRUE}
# объявляем дженерик и метод для класса 'district'
setGeneric('dummy_fun2', def = function(x) standardGeneric('dummy_fun2'))
setMethod('dummy_fun2', 'district', function(x) print(c(x@name, x@abb)))
dummy_fun2(vasileostrovsky)
dummy_fun2(iris)
```

Помимо `name` и `def` в списке аргументов `setGeneric()` еще и другие аргументы, один из самых важных - `signature`. Именно с помощью этого аргумента определяется, какие аргументы функции в `name` будут использоваться для диспетчеризации методов. Это особенно полезно в тех ситуациях, когда предполагается, что не все аргументы значимы для диспетчеризации или есть аргументы со значениями по умолчанию. Если в `signature` ничего не указано, то по умолчанию для диспетчеризации используются все аргументы функции. Есть один важный нюанс - если в `setGeneric()` используется уже существующая функция, сигнатуру (как и прочие дополнительные параметры) указывать не надо.

### Группы дженериков

Дженерики также могут быть отнесены к группам (как, например, функции группы Ops в S3-модели). Группы могут быть как пользовательскими, так и уже предзаданными в базовом пакете methods. Основная цель введения групп - упростить и сделать более надежным механизм диспетчеризации методов, так как при определении метода указывается группа дженериков и пакет, которому принадлежит эта группа (в случае пользовательских групп). 

Предзаданные группы схожи с теми, что присутствуют в S3-модели, однако не тождественны. Все функции этих групп - базовые функции R, в том числе и примитивы (обертки над С-кодом). 

- Ops, включает в себя три подгруппы операторов:
   - 'Arith': '+', '-', '*', '^', '%%', '%/%', '/'
   - 'Compare': '==', '>', '<', '!=', '<=', '>='
   - 'Logic': '&', '|'

- Math: 'abs', 'sign', 'sqrt', 'ceiling', 'floor', 'trunc', 'cummax', 'cummin', 'cumprod', 'cumsum', 'log', 'log10', 'log2', 'log1p', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'exp', 'expm1', 'cos', 'cosh', 'cospi', 'sin', 'sinh', 'sinpi', 'tan', 'tanh', 'tanpi', 'gamma', 'lgamma', 'digamma', 'trigamma'

- Math2: 'round', 'signif'

- Summary: 'max', 'min', 'range', 'prod', 'sum', 'any', 'all'

- Complex: 'Arg', 'Conj', 'Im', 'Mod', 'Re'

Пользовательскую группу дженериков можно задать с помощью функции `setGroupGeneric()`, которая по поведению аналогична функции `setGeneric()`, за несколькими исключениями. Во-первых, рекомендуется указывать все функции группы в аргументе `knownMembers`. Во-вторых, как и все групповые дженерики, группа, определенная с помощью `setGroupGeneric()`, не может быть использована как самостоятельная функция, так как в определении функции (`def`) в первую очередь важен список аргументов функций-дженериков группы, а сама функция должна возвращать `NULL`. Соответственно, все функции группы должны иметь одинаковый список аргументов. Впрочем, если хочется иметь отдельный метод, одноименный названию группы, можно объявить его с помощью `setMethod()`.

```{r 09-oop-51}
# объявляем групповой дженерик
setGroupGeneric(
  name = 'group_generic',
  def = function(x, y) NULL,
  knownMembers = c('my_mult', 'my_sum')
)

# смотрим описание группы
group_generic
str(group_generic)
```

```{r 09-oop-52, echo=FALSE}
# объявляем методы, которые входят в эту группу
setGeneric('my_mult', group = 'group_generic', function(x)
  standardGeneric('my_mult'))
setGeneric('my_sum', group = 'group_generic', function(x)
  standardGeneric('my_sum'))

setClass('nc1', slots = c(x = 'numeric', y = 'numeric'))
my_nc1 <- new('nc1', x = 3, y = 5)

setMethod('my_mult', 'nc1', function(x) x@x * x@y)
setMethod('my_sum', 'nc1', function(x) x@x * x@y)
```


### Объявление методов

Методы в модели S4 объявляются в более явном виде, чем в S3, с помощью специальной функции `setMethod()`, в которую аргументами передают название метода и класс, для которого объявляется метод.

В том случае, когда перегружается уже существующая функция, то нет необходимости вызывать `setGeneric()` перед определением метода, это будет произведено автоматически. Например, в примере ниже мы перегружаем функцию `plot()` для класса `city`, чтобы функция возвращала список названий слотов объекта класса `city`:
```{r 09-oop-53}
setMethod(f = 'plot', signature = 'city', function(x) slotNames(x))
plot(msk)
```

Аргумент `f` в данном случае используется для указания названия обобщенной функции, `signature` - указания классов, для которых объявляется метод.

Отношения наследования классов также работает и с методами - метод, объявленный для суперкласса, будет работать и с отнаследованными от него методами (если для них не объявлены собственные методы):
```{r 09-oop-54}
plot(vasileostrovsky)
```

В сигнатуре метода может быть более одного класса, притом самые разные - S3/S4-классы, базовые типы данных ('numeric', 'character' и проч.), а также класс-заглушка 'ANY' (любой класс) и класс-исключение 'missing', который явно маркирует, какой аргумент не должен использоваться для диспетчеризации методов (если сигнатура метода не полностью соответствует сигнатуре дженерика).

### Методы групп дженериков

Список объявленных методов для класса можно посмотреть с помощью функции `methods()`. Точно также можно посмотреть все методы, связанные с какой-то обобщенной функцией.
```{r 09-oop-55}
# методы класса district
methods(class = 'district')

# методы функции dummy_fun2 (дженерик с одним методом)
methods(generic.function = 'dummy_fun2')
```

### Вспомогательные методы

Нередко, для большей дружелюбности пакета, основанного на S4-модели, создают вспомогательные методы для создания экземпляров классов или же доступа к слотам. Хэдли Викхем, помимо этих двух задач, предлагает также создавать с помощью `setValidity()` функцию-валидатор. Валидатор используется для контроля, что при создании экземпляра класса в слоты передаются объекты корректного класса.

Пример функции для доступа к слотам (acсessor). Подобные функции идентичны оператору `@`, который используется для доступа к слотам, однако, как предполагается, более интуитивны:

```{r 09-oop-56}
# создаем дженерик и метод для извлечения аббревиатуры
setGeneric('abbreviation', function(x) setGeneric('abbreviation'))
setMethod('abbreviation', 'city', function(x) x@abb)

# пробуем извлечь аббревиатуру
abbreviation(msk)
abbreviation(vasileostrovsky)
```


### Диспетчеризация методов
В S3-модели диспетчеризация методов устроена очень просто - метод может быть определен для одного класса. В результате для объектов, относящихся нескольким классам, диспетчеризация заключается в переборе списка указанных классов объекта по порядку, для какого первого класса будет объявлен метод, тот метод и будет применен. 

В S4 ситуация ощутимо сложнее. Это и из-за того, что есть явная иерархия классов и множественное наследование сразу от нескольких классов, и возможность использования сразу нескольких классов (в том числе и S3-классы) в сигнатуре метода. Все это приводит к достаточно нетривиальной процедуре определения метод какого класса должен быть использован в каждом соответствующем случае.

Основной для диспетчеризации методов в S4 является так называемое расстояние между классом объекта, который был передан в аргументы функции-дженерика и тем классом, для которого определен метод. Под расстоянием в данном случае считается количество поколений (родительских классов). Собственно, диспетчеризация методов - это поиск ближайшего определенного метода в иерархии классов. Притом, поиск учетом возможного множественного наследования и возможного различия классов в функциях нескольких переменных.

Объявленные или импортированные при загрузке пакета методы образуют таблицу методов, с помощью которой и происходит диспетчеризация. При этом, при загрузке дженерика из нового пакета (или при создании нового) таблица обновляется (кэшируется), и дальнейшая диспетчеризация происходит по этой закешированной таблице, до нового обновления набора дженериков и методов.

Самая тривиальная ситуация, когда класс имеет один суперкласс, который, в свою очередь, также отнаследован от еще какого-то суперкласса. То есть, существует прямая иерархия классов. Например, если бы мы создали класс `division` муниципальных округов, отнаследованный от `district`, то у нас образовалась бы цепочка классов `division` > `distict` > `city`. При такой схеме наследования диспетчеризация методов аналогична диспетчеризации в S3 - когда мы применяем дженерик к объекту класса `division`, то происходит поиск метода для него и если такой метод не найден - то вверх по иерархии до ближайшего родительского класса с определенным методом, вплоть до самого общего суперкласса. Выше мы уже приводили пример такой схемы диспетчеризации, когда объявили метод `abbreviation()` для класса `city`, и он также успешно отрабатывал на объекте отнаследованного класса `district`.

В ситуации множественного наследования, когда для использованного класса есть одновременно два суперкласса, мы сталкиваемся с так называемой амбивалентностью. Интерпретатор выдаст предупреждение, и возьмет метод того класса, который будет первым в алфавитном порядке. 

Следующий виток усложнения - когда в функции-дженерике используется не один объект, а несколько. В результате может возникнуть искушение потратить много сил и создать отдельные методы для каждой комбинации классов или суперклассов. В принципе, в этом нет особой необходимости, так как можно создать один метод для самых общих супеклассов каждого класса - все равно к ним сведется поиск метода по иерархии классов.

Гипотетически могут возникнуть ситуации, когда сочетается множественное наследование классов и использование нескольких объектов разных классов в функции. Задача диспетчеризации остается все той же - поиск метода, определенного для комбинации классов и суперклассов объектов. Фактически, это почти комбинаторная задача, перебрать комбинации и найти ближайшую по количеству поколений.

Помимо задачи на вычисление сочетаний классов и методов, есть еще несколько нюансов. Один из них - псевдо-классы `missing` и `ANY`, которые могут быть использованы при объявлении класса и метода. Метод класса `ANY`, если он объявлен, имеет меньший приоритет (считается всегда дальше, чем любой другой реальный класс, даже если формально в одном поколении) - это важно для решении амбивалентности при множественном наследовании. 
<!-- Класс `missing`, если для него объявлен метод, всегда будет использоваться, даже если аргумент пропущен - это может привести к неправильной работе операторов, которые зависят от количества аргументов, такие как бинарные и унарные операторы `+` или `-`. -->

Несмотря на то, что диспетчеризация методов в S4 позволяет использовать сложные комбинации, в реальной практике настоятельно рекомендуется не усложнять чрезмерно систему классов и методов.







## R6

### R6 и ReferenceClasses
После введения в 1998 году модели S4, через некоторое время была попытка создать на ее базе еще одну модель ООП, более похожую на ООП в других, менее функционально-ориентированных языках программирования. Эту модель назвали ReferenceClasses или, неформально, R5 (S3 и S4 как модели, пришедшие из S, а ReferenceClasses уже в R). Позднее R5 выделилась в отдельную ветку, но развития не получила и чуть ли не после первого релиза (если он вообще состоялся) была заброшена. Модель R6 идет в той же логике именования, однако, в отличие от ReferenceClasses не включена в ядро R и требует установки пакета `R6`. Другое отличие от ReferenceClasses / R5 - это опора на S3-классы, а не на S4. Это в какой-то мере упрощает использование модели, но все равно стоит признать, что R6-классы и методы могут быть несколько непривычны для многих R-пользователей.

Ключевое отличие ReferenceClasses/R5/R6 от S3 или S4 моделей заключается в том, как организовано взаимодействие классов и методов. В S3/S4 есть функции, которые могут работать с разными классами (разные методы классов), обобщенные одной функцией (дженериком). При вызове дженерика происходит процесс диспетчеризации методов - определение, объект (объекты) какого класса передаются в функцию и поиск соответствующего метода для этих классов. В R6 приоритет на на функциях, а на классах - каждый класс имеет определенные для него методы, которые прописываются при создании класса или его дополнении. Соответственно, нет необходимости в функциях-дженериках и механизмах диспетчеризации, и на первый план выходят вопросы наследования классов, как эти классы организованы в памяти (мутабельность) и какие элементы класса могут быть доступны пользователю или другим функциям (инкапсуляция).

### Объявление класса и методов

Для начала работы необходимо установить и подключить пакет `R6`:
```{r 09-oop-57, eval=FALSE}
install.packages('R6')
```

Для объявления класса и методов нужна всего одна функция - `R6Class()`. При объявлении класса всегда должен создаваться объект (в S4, например, это необязательно). Обычно названия классов идут в `UpperCamelCase` формате. Объекты, которые задаются при объявлении класса - это поля, а функции - методы этого класса.

Вот так выглядит простое объявление класса, описывающего город (название и аббревиатуру), без методов:

```{r 09-oop-58}
# подключаем пакет
library(R6)

# объявляем класс
City <- R6Class(
  classname = 'City',
  public = list(
    # поля (слоты) класса
    name = NA,
    abb = NA,
    country = 'Russia'
  )
)
```

Функция `R6Class()` создает объект-определение класса. Мы видим, что помимо полей, есть еще дополнительная информация, в частности, указатель окружения, в котором был объявлен класс, и параметры копирования и портирования класса между пакетами.
```{r 09-oop-59}
City
```

### Создание экземпляра класса

Создать экземпляр класса можно с помощью встроенной функции `$new()` - это один из методов по умолчанию, которые объявляются для каждого R6-класса. Доступ к методам и полям класса осуществляется через оператор `$` - то есть, не просто вызов функции в виде `new(R6ClassName)`, а `R6ClassName$new()`:
```{r 09-oop-60}
msk <- City$new()
msk
```

При выводе на печать содержания класса, мы видим, что ни названия города, ни его аббревиатуры нет. Это логично, так как в функции `$new()` не предполагается дополнительных агрументов. Можно дополнительно происвоить значения соответствующим полям класса:
```{r 09-oop-61}
msk$name <- 'Moscow'
msk$abb <- 'Msk'
msk
```

Тем не менее, такой пайплайн работы с новыми классами не очень удобен. Поэтому рекомендуется объявлять публичный метод инициализации класса `$initialize()`, в котором аргументами задать значения необходимым полям. 

Мы объявляем метод `$initialize()` с аргументами `name` и `abb`, по умолчанию они имеют значение `NA` (что позволит при инстанцировании класса указать только один из них). Объект `self` - это, по сути, ссылка на создаваемый экземпляр класса, что и обеспечивает запись значений в поля класса.  Важный нюанс - при объявлении метода `$initialize()` можно в теле метода также написать объявление каких-либо функций.
```{r 09-oop-62}
# объявляем класс
City <- R6Class(
  classname = 'City',
  public = list(
    # поля (слоты) класса
    name = NA,
    abb = NA,
    country = 'Russia',
    
    # функция инициализации класса
    initialize = function(name = NA, abb = NA) {
      self$name <- name
      self$abb <- abb
    }
  )
)
```

Экземпляра класса, в котором объявлен метод `$initialize()` создается все так же с помощью `$new()`, однако тут уже можно будет указать аргументы - функция `$new()` просто вызовет `$initialize()` и передаст значения аргументов ей:

```{r 09-oop-63}
spb <- City$new(name = 'Saint-Petersburg', abb = 'SPb')
spb
```

### Объявление методов
Методы в R6 - это функции, объявленные при определении класса. Упомянутые выше `$new()` и `$initialize()`, а также ряд других функций также являются методами, просто их наличие предполагается самой реализацией модели. Объявление пользовательских методов выглядит аналогичным образом.

Добавим при создании класса метод `set_population()`, который позволит задавать количество населения в городе и выводит на печать соответствующее сообщение:

```{r 09-oop-64}
# объявляем класс
City <- R6Class(
  classname = 'City',
  public = list(
    # поля (слоты) класса
    name = NA,
    abb = NA,
    country = 'Russia',
    population = NA,
    
    # метод для популяции
    set_population = function(x) {
      self$population <- x
      cat('added population', '\n')
    },
    
    # метод инициализации класса
    initialize = function(name = NA, abb = NA) {
      self$name <- name
      self$abb <- abb
    }
  )
)
```

Создаем экземпляр класса и проверяем, как работает метод:
```{r 09-oop-65}
spb <- City$new(name = 'Saint-Petersburg', abb = 'SPb')
spb$set_population(5)
spb
```

### Добавление новых методов

В уже созданные классы добавить новые методы (да и поля тоже) можно с помощью функции `$set()`. Попробуем добавить в класс `City` пользовательский метод `$print()`, который будет выводить не структуру класса, а заданную нами строку. Метод `print()` уже определен для всех R6-классов, однако если мы зададим пользовательский метод, то он будет приоритетнее. Если же необходимо переписать уже существующий метод, то стоит воспользоваться аргументом `overwrite = TRUE`.

```{r 09-oop-66}
City$set('public', 'print', function(x) {
  msg <- paste0('city = ', self$name, ' (', self$abb, ')')
  cat(msg, '\n')
})
```

```{r 09-oop-67}
# создаем экземпляр класса
msk <- City$new('Moscow', 'Msk')

# вызываем метод
msk$print()
```

Мы обновили определение класса `City`, добавив новый метод. Однако у нас уже был один, созданный ранее экземпляр класса `City`. Если попробовать вызвать метод `$print()`, то мы получим ошибку. 

```{r 09-oop-68, error=TRUE}
spb$print()
```

В подобных случаях необходимо пересоздать экземпляр класса:
```{r 09-oop-69}
spb <- City$new(name = 'Saint-Petersburg', abb = 'SPb')
spb$print()
```

Запретить добавление новых полей или методов можно с помощью аргумента `lock_class = TRUE` функции `R6Class()`, либо же с помощью встроенных в каждый класс методов `lock()` / `unlock()`. Если распечатать объект-генератор заблокированного класса, то мы увидим строчки `Locked objects: TRUE` и `Locked class: TRUE`:

```{r 09-oop-70, error=TRUE}
# защищаем класс от изменений
City$lock()

# смотрим результат
City

# пробуем добавить новое поле со значением 5
City$set('public', 'new_value', 5)

# снимаем защиту
City$unlock()
```




### Взаимодействие с S3

Выше мы объявили метод `$print()`. Тем не менее, можно воспользоваться также и классической функцией `print()`:
```{r 09-oop-71}
msk$print()
print(msk)
```

Несмотря на то, что обе функции вывода на печать возвращают одинаковый результат, механизм действия у них несколько разный. В выражении `msk$print()` происходит обращение напрямую к методу `$print()`. В выражении `print(msk)` сначала происходит анализ, объект какого класса надо напечатать, и только потом происходит вызов метода `$print()`. Это различие вызвано тем, что функция `print()` - S3-дженерик, и при ее вызове включается механизм диспетчеризации методов. Если же не объявлять метод `$print()` при создании класса, то будет использоваться определенный разработчиками S3-метод `R6:::print.R6()` (внутренний объект пакета `R6`). 


### Цепочки методов

Объявление методов, в сочетании с механикой `self`, позволяет делать так называемые цепочки методов. Ближайший аналог в R - разного рода пайпы, такие как `magrittr::'%>%'`, `ggplot2::'+'` или чейнинг в `data.table`. Другой пример - синтаксические конструкции в модуле `pandas` в Python, например: `pd.my_df.groupby(col1)['col2'].sum().reset_index()`.

Для того, чтобы в R6 сделать возможным объединение методов в цепочки, необходимо, чтобы методы возвращали объект `self`. То есть, любой метод класса, примененный к конкретному экземпляру класса, возвращает этот же экземпляр (с модификациями, заложенными в методе).

Изменим в нашем классе `City` оба пользовательских метода, так, чтобы их можно было объединять в цепочку. Также добавим еще и метод добавления аббревиатуры (по аналогии с методом добавления численности населения):

```{r 09-oop-72}
# объявляем класс
City <- R6Class(
  classname = 'City',
  public = list(
    # поля (слоты) класса
    name = NA,
    abb = NA,
    country = 'Russia',
    population = NULL,
    
    # метод для популяции
    set_population = function(x) {
      self$population <- x
      cat('added population', '\n')
      return(invisible(self))
    },
    
    # метод для аббревиатуры
    set_abb = function(x) {
      self$abb <- x
      cat('added abbreviation', '\n')
      return(invisible(self))
    },
    
    # метод для вывода на печать
    print = function() {
        msg <- paste0(
          'city = ', self$name, ' (', self$abb, '), population = ', self$population
        )
        cat(msg, '\n')
    },
    
    # метод инициализации класса
    initialize = function(name = NA, abb = NA) {
      self$name <- name
      self$abb <- abb
    }
  )
)
```

Пробуем цепочку:
```{r 09-oop-73}
# создаем экземпляр класса
nsk <- City$new(name = 'Novosibirsk')

# последовательно задаем аббревиатуру, население и выводим на печать
nsk$set_abb('Nsk')$set_population(1.4)$print()
```

Код с цепочками методов можно организовывать в более структурировнном виде:
```{r 09-oop-74}
nsk$
  set_abb('Nsk')$
  set_population(1.4)$
  print()
```

```{r 09-oop-75, eval=FALSE, include=FALSE}
# пример Хэдли
Accumulator <- R6Class(
  'Accumulator',
  public = list(
    sum = 0,
    add = function(x = 1) {
      self$sum <- self$sum + x
      invisible(self)
    }
  )
)

x <- Accumulator$new()

x$add(5)$add(11)$sum
```

### Публичные и приватные методы

Наряду с публичными методами, в `R6` можно задать и приватные методы и поля, которые будут недоступны для пользователя напрямую. Как правило, это позволяет оставить пользователю в доступе лишь несколько наиболее полезных методов, а остальные, в том числе и технические, скрыть. Приватный раздел задается с помощью аргумента `private`, приватные элементы доступны через обращение к `private$element_name` (по аналогии с `self` в публичном разделе).

Создадим метод, в котором в приватной части будет функция `$loc()`, выводящая сообщение, что это приватный метод. А в публичной части - метод, который обращается к приватному методу `$loc()`:
```{r 09-oop-76}
# объявляем класс
Private <- R6Class("Private",
  private = list(
    loc = function() {
      message("it is private method")
    }
  ),
  public = list(
    call_private = function() {
      private$loc()
    }
  )
)
# создаем экземпляр класса
private_ex <- Private$new()
```

Если попробовать напрямую обратиться к методу `$loc()`, то мы получим ошибку, так как приватные методы недоступны для прямого обращения. Публичный метод, который также обращается к `$loc()`, работает:
```{r 09-oop-77, error=TRUE}
private_ex$loc()
private_ex$call_private()
```


### Привязки значений

Одна из весьма необычных для большинства пользователей R механик - так называемые активные привязки. Обычно, когда мы связываем объект и значение, то вызвав название объекта, мы получаем значение:
```{r 09-oop-78}
x <- 5
x
```

В активных привязках нет какого-то константного значения, значением выступает функция. Соответственно, при вызове объекта, происходит вызов привязанной функции, и в результате мы получаем тот объект, который возвращает функция. То есть, название объекта служит чем-то вроде алиаса к функции. 

В базовом R активные привязки можно сделать с помощью `makeActiveBinding()`, в `R6` под это отведен отдельный аргумент `active` функции `R6Class()`. При создании класса мы создаем поле `distr`, которое задает тип распределения, а в аргументе `active` формируем привязку:

```{r 09-oop-79}
Sampler <- R6Class(
  'Sampler',
  public = list(
    distr = NA,
    initialize = function(distr = 'rnorm') {
      self$distr <- get(distr)
    }
  ),
  active = list(
    rnd = function() self$distr(1)
  )
)

dist_sample <- Sampler$new('rlnorm')
dist_sample$rnd
```

Несмотря на то, что `rnd` объявляется как функция, в результате из-за активной привязки это уже именно объект со своим классом:
```{r 09-oop-80}
class(dist_sample$rnd)
```

### Ссылочная семантика

В отличие от подавляющего большинства R-конструкций, в R6 реализован доступ и хранение значений по ссылке (что, ко всему прочему, подразумевает мутабельность). Референсная семантика и мутабельность объектов в R6 возможны из-за лежащей в основе R6-классов работы с окружениями. Так, метод `$new`, если посмотреть код метода, создает отдельные окружения для публичного и приватного разделов.

#### Совместное использование объектов
Доступ к значениям по ссылке в некоторых случаях может приводить к ситуации совместного использования одного и того же объекта несколькими разными объектами. Примером может быть, когда класс в качестве поля содержит другой R6-класс (по сути, ссылку на значение в памяти):

```{r 09-oop-81}
# объявляем R6-класс
SimpleClass <- R6Class('SimpleClass',
  public = list(x = NULL)
)

# объявляем класс, в котором ранее объявленный класс 
# инстанцируется и записывается в поле e
SharedField <- R6Class('SharedField',
  public = list(
    e = SimpleClass$new()
  )
)

# создаем экземпляр класса и записываем значение
shared_1 <- SharedField$new()
shared_1$e$x <- 1

# создаем второй экземпляр класса и также записываем значение
shared_2 <- SharedField$new()
shared_2$e$x <- 2

# объект e$x оказывается совместно используемым
shared_1$e$x
shared_2$e$x
```

В документации по пакету (откуда взят пример), для избежания таких ситуаций, рекомендуется объект `e`, в который записывается мутабельный тип, объявлять явно как элемент окружения, в данном случае `self`, в методе инициализации класса:

```{r 09-oop-82}
# создаем класс с методом $initialize
NonSharedField <- R6Class('NonSharedField',
  public = list(
    e = NULL,
    initialize = function() self$e <- SimpleClass$new()
  )
)

# создаем экземпляр класса и записываем значение
non_shared_1 <- NonSharedField$new()
non_shared_1$e$x <- 1

# создаем второй экземпляр класса и записываем значение
non_shared_2 <- NonSharedField$new()
non_shared_2$e$x <- 2

# оба объекта e$x заличаются
non_shared_1$e$x
non_shared_2$e$x
```


#### Копирование R6-классов
С другим примером специфичного поведения мутабельных объектов можно столкнуться при попытке скопировать объект R6-класса с последующим изменением копии:

```{r 09-oop-83}
# создаем класс с одним полем, в котором есть значение по умолчанию
Ref <- R6Class('Ref', public = list(value = 'origin'))

# создаем объект этого класса
ref_1 <- Ref$new()
ref_1$value

# делаем копию объекта и меняем value
ref_2 <- ref_1
ref_2$value <- 'copy'
```

Смотрим результат. И-за того, что `ref_2` является не самостоятельным объектом, а только ссылкой на объект `ref_1`, то поле `value` меняется и в `ref_1`, и в `ref_2`:
```{r 09-oop-84}
ref_1$value
ref_2$value
```

Для того, чтобы правильно скопировать объект в новый объект, а не просто создать ссылку, следует воспользоваться методом `$clone()`:

```{r 09-oop-85}
# создаем объект этого Ref
ref_1 <- Ref$new()

# делаем копию объекта и меняем value
ref_2 <- ref_1$clone()
ref_2$value <- 'copy'

# смотрим значение value в обоих объектах
ref_1$value
ref_2$value
```

#### Глубокое копирование
В тех ситуациях, когда в качестве значения поля или метода R6-класса выступает другой R6-объект, следует отдельно указывать, что нужна глубокая копия всех вложенных объектов - `$clone(deep = TRUE)`. Впрочем, стоит учитывать, что такое глубокое копирование работает только с R6-классами и не работает с другими мутабельными объектами (окружениями, референсными классами или объектами, которые включают в себя мутабельные объекты, наподобие списка нескольких R6-классов). В таких случаях необходимо написать собственный приватный метод `$deep_clone()`, в котором копируемые объекты будут конвертироваться в окружения и копироваться поэлементно.

Если объявлен метод `$deep_clone()`, то клонирование с `$clone()` с аргументом `deep = TRUE` приведет к его вызову:
```{r 09-oop-86}
DeepCloneEnvs <- R6Class(
  'DeepCloneEnvs',
  public = list(
    a = NULL,
    v = 'regular value',
    initialize = function() {
      # записываем в поле a окружение
      self$a <- new.env(parent = emptyenv())
      # создаем в этом окружении объек x
      self$a$x <- 1
    }
  ),
  private = list(
    deep_clone = function(name, value) {
      if (is.environment(name)) {
        # если объект - окружение, то все элементы превращаем в список
        # и потом из списка создаем новое окружение
        list2env(as.list.environment(value, all.names = TRUE),
                 parent = emptyenv())
      } else {
        # или просто возвращаем значение
        value
      }
    }
  )
)

# создаем экземпляр класса
deep_clone_1 <- DeepCloneEnvs$new()

# клонируем его в новый объект
deep_clone_2 <- deep_clone_1$clone(deep = TRUE)

# в копии меняем значение x
deep_clone_2$a$x <- 2

# смотрим a$x в обоих объектах
deep_clone_1$a$x
deep_clone_2$a$x
```

### Финализатор

В среде разработчиков рекомендуется аккуратно работать с рабочим пространством - закрывать коннекторы к базе данных, удалять лишние объекты и так далее. В R есть собственный сборщик мусора, а так же есть финализаторы, которые в принудительном порядке удаляют ссылки на блоки в памяти. Например, в base R есть функция ` reg.finalizer()`, которая вызывается при закрытии R-сессии.

В R6 также есть собственный финализатор, который срабатывает при вызове сборщика мусора. Обычно метод `$finalize()` объявляют в приватной части класса (хотя можно и в публичной). Если объявлять этот метод с аргументом `on.exit = TRUE`, то финализатор будет вызываться при завершении сессии.

Простейший пример - объявляем класс, в котором есть единственный метод - финализатор. При вызове этого метода на печать должа быть выведена надпись `Finalizer has been called!` (пример взят из документации по R6). Для того, чтобы финализатор отработал, необходимо вызвать сборщик мусора:

```{r 09-oop-87, error=TRUE}
# объявляем класс с одним приватным методом
Finish <- R6Class(
  'Finish', 
  private = list(
    finalize = function() {
      print('finished him!')
      }
  )
)

# создаем экземпляр класса
finish_object <- Finish$new()

# удаляем объект
rm(finish_object)
exists(finish_object)

# принудительно вызываем сборщик мусора
gc()
```


### Наследование классов

Как и в большинстве моделей ООП, в R6 реализовано наследование классов. Суперкласс указывается через аргумент `inherit`, в котором указывается объект-определение суперкласса. К методам суперкласса можно обращаться через объект `super` (по аналогии с `self` и `private`).

Создадим класс `District`, который будет наследовать классу `City`. Как мы видим, в списке полей есть не только поля объявленного класса, но и поля суперкласса. 

```{r 09-oop-88}
District <- R6Class(
  'District',
  inherit = City,
  public = list(
    d_name = NA,
    # метод инициализации класса
    initialize = function(d_name = NA) {
      self$d_name <- d_name
    },
    # метод для вывода на печать
    print = function() {
        msg <- paste0('district = ', self$d_name)
        cat(msg, '\n')
    }
  )
)

# создаем экземпляр класса
vasileostrovsky <- District$new('Vasileostrovsky')
```

Если посмотреть структуру объекта класса `District`, видно, что он содержит как собственные поля (`d_name`), так и отнаследованные поля и методы (name, abb, population, set_abb, set_population).
```{r 09-oop-89}
str(vasileostrovsky)
```

Функция `$print()` определена для класса `District`, поэтому она не наследуется от `City`и имеет собственное поведение:
```{r 09-oop-90}
vasileostrovsky$print()
```



### Портируемость классов

R6-классы могут использоваться и наследоваться между разными пакетами - так, класс в одном пакете вполне может быть отнаследован от какого-то класса в другом пакете. В целом, схема наследования идентична, как если бы классы были в одном пакете (окружении). Однако есть небольшой нюанс, который касается объектов окружения, в которых был объявлен родительский класс. Например, если суперкласс использует какую-либо функцию своего пакета, то отнаследованный от него класс в другом окружении не будет иметь возможность обратиться к этой функции.

Пример из документации:
```{r 09-oop-91, error=TRUE}
# создаем два окружения для симуляции поведения пакетов
pkgA <- new.env()
pkgB <- new.env()

# создаем функцию в одном из окружений
pkgA$fun <- function() cat('Fun from pkgA', '\n')

# создаем класс в окружении pkgA
ClassA <- R6Class('ClassA',
  portable = FALSE,
  public = list(
    pkg_fun = function() fun()
  ),
  parent_env = pkgA
)

# создаем класс, который отнаследован от pkgA
ClassB <- R6Class('ClassB',
  portable = FALSE,
  inherit = ClassA,
  parent_env = pkgB
)

# создаем экземпляры классов
s_class <- ClassA$new()
c_class <- ClassB$new()

# тестируем метод $pkg_fun()
s_class$pkg_fun()
c_class$pkg_fun()
```

В этом примере видно, что отнаследованный класс `ClassB` не может использовать функцию `fun()`, так как она была объявлена в окружении, где был создан суперкласс `ClassA` и в процессе наследования никак не участвует. Это синтетический пример, так явно выставлен параметр `portable = FALSE` - по умолчанию он равен `TRUE`, в результате если в отнаследованном классе вызывается какой-то метод суперкласса (по цепочке наследований), то он выполняется в окружении суперкласса.

Тот же самый пример, в котором 

```{r 09-oop-92}
# создаем два окружения для симуляции поведения пакетов
pkgA <- new.env()
pkgB <- new.env()

# создаем функцию в одном из окружений
pkgA$fun <- function() cat('Fun from pkgA', '\n')

# создаем класс в окружении pkgA
ClassA <- R6Class('ClassA',
  public = list(
    pkg_fun = function() fun()
  ),
  parent_env = pkgA
)

# создаем класс, который отнаследован от pkgA
ClassB <- R6Class('ClassB',
  inherit = ClassA,
  parent_env = pkgB
)

# создаем экземпляры классов
s_class <- ClassA$new()
c_class <- ClassB$new()

# тестируем метод $pkg_fun()
s_class$pkg_fun()
c_class$pkg_fun()
```


