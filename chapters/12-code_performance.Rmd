# Производительность кода
## Время выполнения кода
При написании сложных функций и нетривиальном процессинге данных необходимо контролировать время выполнения кода и корректировать те операции, которые занимают слишком много времени или памяти. Для анализа времени выполнения кода в R можно использовать как базовую функцию `system.time()`, так и функции более подходящих пакетов `bench` или `microbenchmark`. 

Функция `system.time()` является оберткой над двумя вызовами `proc.time()`, и возвращает, сколько времени заняло выполнение выражения. `user time` (пользователь) - сколько времени прошло для выполнения всего выражения (в том числе парсинг выражения и запуск процесса), `system time` (система) - сколько потребовалось времени процессора для выполнения процесса операционной системой.
```{r 12-code-performance-1 }
set.seed(123)
system.time(for(i in 1:1000) log(runif(1000)))
```

Несмотря на простоту, `system.time()`, не лучший инструмент для измерений - как минимум, могут быть параллельные процессы, более приоритетные для системы. При единичном измерении легко ошибиться, и даже аргумент `gcFirst = TRUE`, вызывающий сборщик мусора при выполнении, неконтролируемо полезен. В качестве альтернативы, лучше пользоваться функциями `microbenchmark::microbenchmark()` и `bench::mark()`, которые выполняют измерение заданное количество раз, и в выводе отдают опиcательные статистики по времени выполнения выражения.

Функция `microbenchmark()` одноименного пакета измеряет время выполнения выражения в заданном количестве испытаний, и отдает квартили распределения времени выполнения. Обычно бенчмарки используют для сравнения нескольких разных выражений (функций). Неоптимальное выражение цикла в функции `f1()` задано умышленно:
```{r 12-code-performance-2 }
library(microbenchmark)
f1 <- function(n) {
  res <- vector(mode = 'numeric')
  for (i in 1:n) res <- c(res, log(runif(1)))
  res
}

f2 <- function(n)
  sapply(seq_len(n), function(x) log(runif(1)))


microbenchmark(f1(1000), f2(1000), times = 100)
```

Функция `mark()` пакета `bench` отдает медианное время выполнения выражения в ходе итераций, а так же сопутствующую информацию. При этом у пакета есть одно не очень явное ограничение, "защита от дурака"" - нельзя сравнивать блоки кода, которые возвращают разный результат. `mark()` учитывает и позволяет выводить результаты измерений с разными параметрами - и относительне оценки (коэффициенты относительно самого быстрого выражения), и надо ли учитывать работу сборщика мусора, и сколько места в памяти потребовалось для измерения. 
```{r 12-code-performance-3 }
bench_res <- bench::mark(f1(100), iterations = 100)
bench_res
```


Расширение функции `mark()`, функция `press()` позволяет использовать `mark()` в указанном диапазоне параметров. То есть, вместо цикла с перебором количества итераций можно просто воспользоваться `press()`:
```{r 12-code-performance-4 }
# bench::press(rep = c(1, 10, 100), f1(100))
```


## Профилирование кода
Оценка производительности кода обычно лишь первый этап - бывает так, что функция или блок кода очень большие, и включают в себя множество разнообразных операций. Соответственно, определить, какая из этих операций требует много времени для выполнения, без дополнительного инструментария достаточно сложно. 

В базовом R есть функция `Rprof()`, с помощью которой можно записать результаты профилирования в файл, чтобы потом c помощью `summaryRprof()` его прочитать и интерпретировать. Тем не менее, ощутимо удобнее использовать пакет `profvis`, который также использует `Rprof() / summaryRprof()`, но результаты представляет в удобном интерактивном виде.

Посмотрим, какие операции требуют больше всего времени в функции подсчета, сколько раз встречается та или иная цифра в заданном векторе. Для усложнения возьмем длинный вектор, с чисткой прочих символов, кроме цифр.

```{r 12-code-performance-5 }
# определяем функцию
numbers <- function(x) {
  x <- as.character(x)
  x <- gsub('[^0-9]', '', x)
  x <- strsplit(x, '')
  x <- unlist(x)
  digit_vector <- factor(x, levels = 0:9)
  res <- table(digit_vector)
  as.numeric(res)
}

# пример работы функции
numbers(c('097-8', '97', '2-25-0'))
```

Для того, чтобы отследить время выполнения каждого выражения функции, передадим в `profvis()` не саму функцию `numbers()`, а ее тело (при работе с большими скриптами можно просто указывать `source(your_script.R)`).
```{r 12-code-performance-6, eval=FALSE}
library(profvis)
vec <- sample(10000, 1e5, replace = TRUE)
profvis(
  expr = {
    x <- as.character(vec)
    x <- gsub('[^0-9]', '', x)
    x <- strsplit(x, '')
    x <- unlist(x)
    digit_vector <- factor(x, levels = 0:9)
    res <- table(digit_vector)
    as.numeric(res)
  }, 
  height = 500
)
```

`Rprof()` и, следовательно, `profvis()` не напрямую измеряют время выполнение кода, а с определенным интервалом записывают состояние интерпретатора (для `profvis()` это 10мс по умолчанию), какое выражение обрабатывается в этом интервале. Как следствие, для профилирования очень быстрых выражений потребуется определенным образом "замедлить" выполнение - например, увеличить длину вектора, как в примере выше. Без такого "замедления" можно получить ошибку `Error in parse_rprof(prof_output, expr_source) : No parsing data available. Maybe your function was too fast?`.


## Оптимизация кода
R нередко называется медленным языком. В этом есть некоторая доля истины, однако в немалой части случаев "неторопливость" вызвана низким качеством кода и неоптимальными конструкциями. К наиболее частым ошибкам или причинам невысокой скорости работы кода можно отнести игнорирование векторизации и ряда других особенностей языка, неоптимальное использование циклов, игнорирование специализированных пакетов и так далее. В сообществе пользователей R нередко даже встречается фраза "пишите на R, а не на <другой язык> средствами R".

### Оптимизация циклов
Очень часто циклы в R пишут неоптимально, вплоть до того, что установка "не надо никогда пользоваться циклами" известна даже начинающим пользователям. Меж тем, это не совсем верно - как правило, "плохой" цикл начинается с создания пустого объекта, и потом последовательное в цикле добавление к нему новых элементов. 

Например, у нас есть строковый вектор, каждый элемент которого мы хотим разделить по какому-то символу с помощью `strsplit()` и извлечь вторую часть каждого элемента. 
```{r 12-code-performance-7 }
# создаем строковый вектор
N <- 1e4
set.seed(12345)

uids <- paste0('uid_', sample(N), sample(letters, N, TRUE))
uids[1:3]

# для примера из первого элемента извлекаем второе значение
uids_splitted <- strsplit(uids, '_')
uids_splitted[[1]][2]
```

Неоптимальный цикл будет выглядеть следующим образом:
```{r 12-code-performance-8 }
uids_second <- c()
for (i in seq_len(N))
  uids_second <- c(uids_second, uids_splitted[[i]][2])
uids_second[1:3]
```

Такой цикл плох тем, что на каждой итерации создается новый объект `uids_second`, в который записывается старый объект `uids_second` и присоединенное к нему на этой итерации новое значение. Старый объект удаляется сборщиком мусора. При больших датасетах эта операция становится очень дорогой, особенно когда дело касается добавления новой строки в большую таблицу.
```{r 12-code-performance-9 }
uids_second <- c()
for (i in seq_len(3)) {
  uids_second <- c(uids_second, uids_splitted[[i]][2])
  print(tracemem(uids_second))
}
```

Корректным в данном случае было бы создание объекта и изменение его во время итераций. В англоязычной литературе по R этот ход обычно называют `memory preallocation`, что не очень точно, так как в данном случае не происходит реального выделения памяти, а всего лишь избегается копирование и удаление объектов на каждой итерации.

Целевой вектор мы создаем с помощью `vector()` и изменяем его по индексам. Для примера возьмем только первые три элемента, чтобы не удлинять цикл, и посмотрим, как меняется адрес объекта `uids_second` в памяти.

```{r 12-code-performance-10 }
uids_second <- vector('character', 3)
for (i in seq_len(3)) {
  uids_second[i] <- uids_splitted[[i]][2]
  print(tracemem(uids_second))
}
uids_second
```

Неявные циклы, к которым относится семейство функций `*pply` (`lapply()` в частности), работают практически аналогично циклам с преаллокацией, только с рядом дополнительных оптимизаций, в первую очередь за счет вызова С-функции и преаллокацией на уровне C. 

Сравним скорость трех вариантов цикла, различие на порядки:
```{r 12-code-performance-11 }
loops_bench <- microbenchmark(
  'for + c()' = {
    uids_second <- c()
    for (i in seq_len(N))
      uids_second <- c(uids_second, uids_splitted[[i]][2])
    },
  'for + vector()' = {
    uids_second <- vector('character', N)
    for (i in seq_len(N))
      uids_second[i] <- uids_splitted[[i]][2]
    },
  'lapply()' = unlist(lapply(uids_splitted, '[[', 2)),
  times = 100
)
print(loops_bench, signif = 3)
```

### Векторизация выражений
Еще один способ ускорить выполнение выражений - не игнорировать особенности языка. В частности, в R очень активно используется векторизация, когда функция применяется ко всем элементам вектора.

В частности, задачу по извлечению второй части составного строкового идентификатора эффективнее всего решать с помощью векторизованной функции `gsub()`, которая находит и заменяет записанный регулярными выражениями паттерн на тот или иной набор символов. 

Сравним самый быстрый вариант цикла `lapply()` и решение задачи с помощью `gsub()`. Для корректности внесем `lapply()` еще и разбивку строковых элементов вектора на части (собственно, эта функция также векторизована). В предыдущем сравнении циклов эта операция была вынесена и не учитывалась в бенчмарках. Как мы видим, решение задачи с помощью более релевантной языковой конструкции оказывается эффективнее, чем перебор элементов даже в оптимальном цикле.

```{r 12-code-performance-12 }
loops_bench <- microbenchmark(
  'lapply()' = unlist(lapply(strsplit(uids, '_'), '[[', 2)),
  'gsub()' = gsub('^.*_', '', uids) ,
  times = 100
)
print(loops_bench, signif = 3)
```

### Параллелизация кода
Помимо просто написания хорошего кода с правильными конструкциями, можно распараллеливать выполнение кода - выполнять одинаковые операции в доступных параллельных потоках, в зависимости от количества ядер процессора или количестве процессоров. При этом некоторые пакеты, в частности, `data.table` по умолчанию используют половину ядер (и есть отдельная опция для этого). 


Для параллелизации прочих частей кода можно воспользоваться как базовой функцией `mclapply()` (на Windows использует только одно ядро, адекватная замена - `parLapply()`), которая обращается к пакету `parallel`, так и спец.пакетами `foreach` и `doParallel`, которые служат надстройкой над `parallel` - первый пакет необходим, собственно, для параллелизации, второй служит бекэндом для него.
```{r 12-code-performance-13 }
library(foreach)
library(doParallel)

# задаем количество проб и готовим датасет
trials <- 100
iris_df <- iris[iris$Species != 'setosa', ]

# пишем функцию оценки lm-коффициентов на семпле
lm_bootstrap <- function(df) {
  iris_sample <- df[sample(100, replace = TRUE), ]
  lm_fit <- glm(Species ~ Sepal.Length, iris_sample, family = binomial)
  coefficients(lm_fit)
}

# указываем, какое количество ядер использовать в параллелизации
cores <- detectCores()
cl <- makeCluster(cores)
registerDoParallel(cl)
getDoParWorkers()

# оцениваем каждое выражение
parallel_bench <- microbenchmark(
  'lapply' = lapply(seq_len(trials), function(x) lm_bootstrap(iris_df)),
  'mclapply()' = mclapply(seq_len(trials), function(x) lm_bootstrap(iris_df)),
  'foreach()' = foreach(icount(trials)) %dopar% lm_bootstrap(iris_df),
  times = 10
)
# останавливаем параллелизацию по ядрам
stopCluster(cl)

# смотрим результат
print(parallel_bench, signif = 3)
```

Как мы видим, быстрее всего работает `mclapply()`, чуть медленне `foreach()`. В целом это вполне закономерное поведение, так как при работе `foreach()` появляются дополнительные расходы на запуск и взаимодействие с кластером. Как следствие, `foreach()` может быть не очень эффективен для параллелизации некоторых (обычно быстрых) операций.


### Снижение накладных расходов
Большинство функций пакетов помимо основных операций содержат и дополнительные - проверки типов входных данных, обработка ошибок, проверка на наличие и применение дополнительных аргументов и так далее. Это, конечно же, повышает надежность кода, однако может увеличивать время выполнения.

Достаточно легко роль таких сопутствующих операций можно увидеть на примере вычисления арифметического среднего. Функция `mean()` - обобщённый метод (в данном случае функция расчёта среднего) для большого набора классов, каждый из которых может имплементировать метод по-своему. Соответственно, функция `mean()` будет сначала определять, с каким классом объекта имеет дело, и потом вызывать соответствующий метод. Функция `mean.default()` - это метод по умолчанию, когда конкретная имплементация не найдена или у объекта вообще отсутствует атрибут класса. Соответственно, `mean.default()` должна быть немного быстрее `mean()`. К тому же обе функции имеют свои доп.аргументы (`trim`, `na.rm` или `...`), поэтому будут медленнее, чем прямолинейное вычисление среднего по вектору как отношение суммы элементов и длины вектора.

```{r 12-code-performance-14 }
vec <- rnorm(1e6)

mean_bench <- microbenchmark(
  'mean()' = mean(vec),
  'mean.default()' = mean.default(vec),
  'sum() / len()' = sum(vec) / length(vec),
  times = 100
)
print(mean_bench, signif = 3)
```

### Вставки на С++
Еще одним неочевидным, но вполне допустимым и эффективным методом оптимизации кода может быть использование вставок на других языках программирования, в частности, на `C++` (несмотря на наличие интерфейсов к другим языкам, в частности, к Java или Python). Для вставок `C++` используется пакет `Rcpp` или его аналоги. 

Сравним функцию вычисления среднего c помощью функций R и с помощью вставки на `C++`.
```{Rcpp 12-code-performance-15}
# include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
double mean_Rcpp(NumericVector x) {
  int n = x.size();
  double total = 0;
  
  for(int i = 0; i < n; ++i) {
    total += x[i];
  }
  return total / n;
}
```

Как мы видим, функция получилась быстрая, но все равно чуть-чуть медленнее, чем базовые реализация `sum() / len()` на R. 
```{r 12-code-performance-16 }
library(Rcpp)
mean_bench <- microbenchmark(
  'mean()' = mean(vec),
  'mean.default()' = mean.default(vec),
  'sum() / len()' = sum(vec) / length(vec),
  'mean_Rcpp()' = mean_Rcpp(vec),
  times = 100
)
print(mean_bench, signif = 3)
```
